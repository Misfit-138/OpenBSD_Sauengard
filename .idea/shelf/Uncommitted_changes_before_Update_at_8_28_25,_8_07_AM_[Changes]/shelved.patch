Index: player_module.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Sauengard © Copyright 2022, 2023, 2025 by J.P.\n# This source code is licensed under the license found in the\n# LICENSE.txt file in the root directory of this source tree.\n\nimport math\nimport pickle\nimport random\nimport time\nimport os\nimport sys\nfrom collections import Counter\nfrom dungeons import dungeon_dict\nfrom monster_module import monster_dict, king_boss_list, undead_prophet_list, WickedQueenJannbrielle\nfrom pathlib import Path\nimport itertools\nfrom termios import tcflush, TCIFLUSH\n\n\n# if you call a function and expect to use a return value, like, by printing it, you must first assign a variable in\n# the call itself!!!\n# when passing a list as an argument, remember to use the * unpacking operator\n# seq = [1, 2, 3]\n# foo(*seq)\n\n\ndef ibm_startup_meta_function():\n    # pc_powerup()\n    # sleep(5)\n    # floppy_insert_and_load()\n    ibm_dos_screen()\n\n\ndef os_check():\n    cls()\n    print(\"Welcome!\\nPlease ensure terminal is in full screen mode.\")\n\n    random_startup_list = [ibm_startup_meta_function, commodore_pet_screen, unix_screen]\n    random_startup = random.choice(random_startup_list)\n    random_startup()\n    initial_loading_screen()\n\n\ndef commodore_pet_screen():\n    sleep(3)\n    cls()\n    sleep(2)\n    stop_sound()\n    print(f\"\\n*** COMMODORE PET BASIC 4.0 ***\\n 31743 BYTES FREE\\nREADY.\")\n    sleep(1.5)\n    clacky_keyboard_short2()\n    same_line_teletype(F\"LOAD\\\"$\\\",8\")\n    sleep(.25)\n    same_line_print(\"\\n\")\n    random_floppy_rw_sound()\n    sleep(2)\n    # stop_sound()\n    print(f\"0 \\\"GAME DISK 1\\\"            1       \")\n    print(f\"38   \\\"HANGMAN\\\"             PRG\")\n    print(f\"92   \\\"HAMMURABI\\\"           PRG\")\n    print(f\"64   \\\"BASEBALL\\\"            PRG\")\n    print(f\"54   \\\"CAVE\\\"                PRG\")\n    print(f\"33   \\\"WUMPUS\\\"              PRG\")\n    print(f\"126  \\\"CANYON\\\"              PRG\")\n    print(f\"121  \\\"DUNGEON\\\"             PRG\")\n    print(f\"442  \\\"SAUENGARD\\\"           PRG\")\n    print(f\"12 BLOCKS FREE.\")\n    print(f\"READY.\")\n    sleep(4)\n    clacky_keyboard_short()\n    sleep(.4)\n    same_line_teletype(\"LOAD\\\"SAUENGARD\\\",8\")\n    stop_sound()\n    sleep(.5)\n    print(\"\\n\")\n    sleep(.5)\n    random_floppy_rw_sound()\n    sleep(3)\n    print(f\"READY.\")\n    sleep(2)\n    clacky_keyboard_short()\n    sleep(.25)\n    same_line_teletype(\"RUN\\n\")\n    stop_sound()\n    sleep(1)\n    random_floppy_rw_sound()\n    sleep(2)\n\n\ndef ibm_dos_screen():\n    cls()\n    sleep(2)\n    stop_sound()\n    print(\"Current date is Tue 1-01-1980\")\n    same_line_print(\"Enter new date (mm-dd-yy): \")\n    sleep(.5)\n    clacky_keyboard_short2()\n    same_line_teletype(\"5-27-1984\\n\")\n    sleep(.25)\n    stop_sound()\n    print(\"Current time is 0:00:25:36\")\n    same_line_print(\"Enter new time: \")\n    sleep(1)\n    clacky_keyboard_short()\n    sleep(.4)\n    same_line_teletype(\"8:02\\n\")\n    stop_sound()\n    sleep(1)\n    print(\"\\n\\n\")\n    print(\"The IBM Personal Computer DOS\\n\"\n          \"Version 3.00 (C)opyright IBM Corp 1984\")\n    sleep(1)\n    same_line_print(\"A> \")\n    sleep(1)\n    clacky_keyboard_short2()\n    sleep(.25)\n    same_line_teletype(\"SAUENGARD.BAT\")\n    print(\"\\n\")\n    sleep(.5)\n    random_floppy_rw_sound()\n    sleep(1)\n\n\ndef unix_screen():\n    # original devs of\n    # UNIX, 'chess', 'space_travel',\n    # the C programming language,\n    # 'dnd',\n    # 'DND' and\n    # 'Dungeon',\n    # respectively, and, respectfully :)\n    # Note that 'dnd' (lowercase) (Whisenhunt, Wood, Dirk Pellett, Flint Pellett, developed on the PLATO network)\n    # and 'DND' (UPPERCASE) (Daniel Lawrence) are different games with an interesting, and contentious history.\n    # Lawrence later wrote 'Telengard', a game based on 'DND'. 'Telengard' was a commercial success.\n    # Lawrence denied having ever played 'dnd' on PLATO.\n    # dnd maintainer and author, Dirk Pellett, claims that Daniel Lawrence outright plagiarized it.\n    # For more: http://www.armory.com/~dlp/dnd1.html)\n    user_list = [\"ken_thompson\", \"dennis_ritchie\",\n                 \"gary_whisenhunt\", \"ray_wood\", \"dirk_pellett\", \"flint_pellett\",\n                 \"daniel_lawrence\",\n                 \"don_daglow\"]\n    user = random.choice(user_list)\n    cls()\n    print(\"digital PDP 11/23 PLUS\")\n    sleep(.5)\n    cls()\n    same_line_print(\"BOOT> \")\n    sleep(1.5)\n    same_line_teletype(\"DU 0\\n\")\n    sleep(.5)\n    print(\"73Boot from ra(0,0,0) at 0172150\")\n    sleep(.5)\n    print(\":\\n: ra(0,0,0)unix\")\n    sleep(.5)\n    print(\"Boot: bootdev=02400 bootcsr=0172150\")  # I'm curious about what 'bootcsr' means.\n    sleep(.5)\n    print(\"total real memory       = 1024000\")\n    sleep(.25)\n    print(\"total available memory  = 901068\\n\")\n    sleep(.25)\n    print(\"AT&T UNIX System V Release 1.0 version 1.1\")\n    print(\"(Bell Labs internal USG UNIX 5.0 codebase. *Not for re-distribution*)\")\n    print(\"Copyright (c) 1983 AT&T\")\n    print(\"All Rights Reserved\")\n    sleep(1.5)\n    same_line_print(\"The system is coming up.  \")\n    sleep(1)\n    same_line_print(\"Please wait. \")\n    spinner(100)  # this is anachronistic, but I thought it looked cool, like openBSD or something. consider removing.\n    # sleep(2)\n    cls()\n    same_line_print(\"Console Login: \")\n    sleep(1)\n    same_line_teletype(user)\n    print()\n    sleep(.5)\n    print()\n    sleep(.5)\n    same_line_print(\"Password: \")\n    sleep(1.5)\n    print(\"\\n\")\n    print(\"AT&T UNIX System V Release 1.0 version 1.1\")\n    print(\"Copyright (c) 1983 AT&T\")\n    print(\"All Rights Reserved\")\n    print(\"Last login: Thu Sep 10 01:50:13 on console\")\n    sleep(.5)\n    print(\"/        :    Disk space 5.14 MB of 10 MB available (51.4%) \")\n    sleep(1)\n    same_line_print(\"$ \")\n    sleep(1.5)\n    same_line_teletype(\"cd /usr/games\\n\")\n    sleep(.5)\n    same_line_print(\"$ \")\n    sleep(1.5)\n    same_line_teletype(\"ls\\n\")\n    sleep(.25)\n    print(f\"adventure\\ncanyon\\ndnd\\nDND\\ndungeon\\nchess\\nspace_travel\\nsauengard\\n\")\n    same_line_print(\"$ \")\n    sleep(1.5)\n    same_line_teletype(\"./sauengard\\n\")\n    print(\"\\n\")\n    sleep(2)\n\n\ndef clacky_keyboard_short():\n    sound_player('clacky_keyboard_short.wav')\n\n\ndef clacky_keyboard_short2():\n    sound_player('clacky_keyboard_short2.wav')\n\n\ndef initial_loading_screen():\n    cls()\n    same_line_print(f\"\\nLOADING.\")\n    dot_dot_dot(20)\n\n\ndef random_floppy_rw_sound():\n    floppy_sound = [floppy_rw, floppy_rw2]\n    loading_sound = random.choice(floppy_sound)\n    loading_sound()\n\n\ndef loading_screen():\n    cls()\n    random_floppy_rw_sound()\n    same_line_print(f\"\\nLOADING.\")\n    dot_dot_dot(20)\n\n\ndef quit_game():\n    cls()\n    teletype(\"Quit game..\")\n    teletype(\"Any unsaved progress will be lost....\\n\")\n\n    if are_you_sure():\n        print(f\"Farewell. . .\")\n        sleep(1)\n        cls()\n        sys.exit()\n\n    else:\n        return\n\n\ndef are_you_sure():\n    while True:\n        confirm = input(\"Are you sure (y/N)? \").lower()\n\n        if confirm == 'y':\n            return True\n        else:\n            return False\n\n\ndef spinner(number_of_spins):\n    # silly little function for a progress spinner.\n    spin_cycle = itertools.cycle(['-', '/', '|', '\\\\'])\n\n    for i in range(number_of_spins):\n        sys.stdout.write(next(spin_cycle))   #\n        sys.stdout.flush()\n        sys.stdout.write('\\b')  # erase the last written char\n        sleep(.005)\n\n\ndef escape_key_interrupt_teletype(message):\n    # I am proud of this little snippet I figured out,\n    # but unfortunately, it does not work reliably on *nix due to permissions problems with the 'keyboard' module.\n    return False\n    #if os.name == 'nt':\n\n    #    if keyboard.is_pressed('Esc'):  # Skip through teletype message straight to printing, if escape is pressed:\n    #        cls()\n    #        print()  # skip a line, just like teletype(), so printed text will line up perfectly with teletyped text\n    #        print(message)\n    #        return True\n\n     #   else:\n     #       return False\n\n    #else:\n    #    return False\n\n\ndef same_line_print(string):\n    # simple function that does not add a carriage return, allowing next item to be printed on same line\n    sys.stdout.write(string)\n    sys.stdout.flush()\n\n\ndef same_line_teletype(string):\n    for each_character in string:\n        sys.stdout.write(each_character)\n        sys.stdout.flush()\n        sleep(0.07)\n\n\ndef dot_dot_dot(number_of_dots):\n    # print a series of specified periods '.' after same_line_print(string)\n    for i in range(number_of_dots):\n        sleep(.1)\n        same_line_print(\".\")\n\n\ndef teletype(message):\n    # based this snippet on a snippet from 101computing.net:\n    print()  # skip a line\n    for each_character in message:\n        sys.stdout.write(each_character)\n        sys.stdout.flush()\n        sleep(0.00001)  # 0.0065, 0.01 all seem good\n        if escape_key_interrupt_teletype(message):\n            return\n\n    sleep(0.01)\n    return\n\n\ndef print_txt_file(txt_file_name):\n    cls()\n    p = \"\"\n    try:\n        text_folder = Path(__file__).with_name(\"text\")\n        p = text_folder / txt_file_name\n        # p = Path(__file__).with_name(txt_file_name)\n        with p.open('r') as txt:\n            if txt.readable():\n                print(txt.read())\n\n    except FileNotFoundError:\n        print(f\"Missing {p} or bad file path.\")\n\n\ndef teletype_txt_file(txt_file_name):\n    cls()\n    p = \"\"\n    try:\n        text_folder = Path(__file__).with_name(\"text\")\n        p = text_folder / txt_file_name\n        # p = Path(__file__).with_name(txt_file_name)\n        with p.open('r') as message:\n            if message.readable():\n                teletype(message.read())\n\n    except FileNotFoundError:\n        print(f\"Missing {p} or bad file path.\")\n\n\ndef game_splash():\n    while True:\n        cls()\n        print_txt_file('splash_art.txt')\n        print(\"                     \"\n              \"W  E  L  C  O  M  E    T O    S  A  U  E  N  G  A  R  D.\")\n        print(f\"                            Copyright 2022, 2023, by Jules Pitsker\")\n        choice = input(f\"               \"\n                       f\"(Quit) to Desktop  (A)bout  (T)ips  (C)redits  \"\n                       f\"(L)icense  (B)egin \").lower()\n\n        if choice == 'a':\n            teletype_txt_file('about.txt')\n            pause()\n\n        elif choice == 't':\n            teletype_txt_file('tips.txt')\n            pause()\n\n        elif choice == 'c':\n            print_txt_file('credits.txt')\n            pause()\n\n        elif choice == 'l':\n            print_txt_file('LICENSE.txt')\n            pause()\n\n        elif choice == 'quit':\n            quit_game()\n\n        elif choice == 'b':\n            return\n\n\ndef convert_list_to_string(list1):\n    # no brackets, no quotes, no commas\n    return str(list1).replace('[', '').replace(']', '').replace(\"'\", \"\").replace(\",\", \"\")\n\n\ndef convert_list_to_string_with_commas_only(list1):\n    # no brackets, no quotes. WITH commas\n    return str(list1).replace('[', '').replace(']', '').replace(\"'\", \"\")\n\n\ndef convert_list_to_string_with_and(list1):\n    # no brackets, no quotes. WITH commas. add \"and\" before last element to be more naturally readable\n    list1.insert(-1, 'and')\n    readable_list = str(', '.join(list1[:-2]) + ' ' + ' '.join(list1[-2:]))\n    return readable_list\n\n\n# def compare():  # unused function?\n#    lambda x, y: collections.Counter(x) == collections.Counter(y)\n\n\ndef pause():\n    # for cross-platform compatibility, I have tried to make this as best I can.\n    # MS Windows users will have a slight convenience in the ability to hit any key,\n    # whereas Posix/GNU/Linux users must hit ENTER\n    if os.name == 'nt':\n        os.system('pause')\n\n    else:\n        tcflush(sys.stdin, TCIFLUSH)  # flush input stream to prevent game disruption by player mashing ENTER key!\n        input(\"Press [ENTER] to continue . . . \")\n\n    return\n\n\ndef cls():\n    # for cross-platform compatibility\n    #if os.name == 'nt':\n    #    os.system('cls')\n\n    #else:\n    os.system('clear')\n\n    return\n\n\ndef sleep(seconds):\n    time.sleep(seconds)\n    return\n\n\ndef dice_roll(no_of_dice, no_of_sides):\n    dice_rolls = []  # create list for multiple die rolls\n\n    for dice in range(no_of_dice):\n        dice_rolls.append(random.randint(1, no_of_sides))\n\n    your_roll_sum = sum(dice_rolls)\n    return your_roll_sum\n\n\ndef dungeon_command_choices():\n    command = input(\"(QUIT) to desktop, (R)estart game, (L)ook at surroundings, (STAY) where you are,\\n\"\n                    \"use (MAP), (C)larifying elixir, Town (P)ortal, (H)ealing potion, (M)anage inventory,\\n\"\n                    \"(G)iant strength potion, (V)ial of Antidote, (I)nventory, (Q)uantum effects,\\n\"\n                    \"or W-A-S-D to navigate. --> \").lower()\n    return command\n\n\ndef character_generator():\n    cls()\n    explanation_dict = {\"Strength\": \"Strength is a measure of one's physical force. A character high\\n\"\n                                    \"in Strength can do more damage with melee weapons.\\nAlso essential for \"\n                                    \"lifting heavy objects when interacting with certain dungeon features.\",\n                        \"Dexterity\": \"Dexterity is a measure of a character’s speed, swiftness, and \"\n                                     \"coordination.\\nIt is also an essential component of stealth attempts and \"\n                                     \"your Armor Class.\",\n                        \"Constitution\": \"Constitution defines one's general stoutness and resistence to evil \"\n                                        \"effects, like poison and Quantum necrosis.\\n\"\n                                        \"Constitution is also proportional to one's hit points.\",\n                        \"Intelligence\": \"Intelligence determines how well your character learns and discerns. It is\\n\"\n                                        \"important for certain quantum effects, your ability to recall \\n\"\n                                        \"languages and read runes, as well as your ability to investigate your \\n\"\n                                        \"surroundings.\",\n                        \"Wisdom\": \"Wisdom represents action based on intelligence and understanding; \"\n                                  \"the ability\\n\"\n                                  \"to practically apply one's knowledge successfully, solve problems, avoid or \"\n                                  \"avert\\n\"\n                                  \"dangers, and attain goals. Wisdom is absolutely critical for \"\n                                  \"harnessing\\n\"\n                                  \"many Quantum effects, as well as avoiding many Quantum attacks.\",\n                        \"Charisma\": \"Charisma measures one's personal attraction and social skills. A character with \"\n                                    \"high charisma will have a\\n\"\n                                    \"better chance of favorable outcomes when encountering certain monsters.\\n\"\n                                    \"Charisma can mean the difference between great fortune and death.\"}\n\n    default_stats = f\"Attribute Value    \tAttribute Modifier\\n\" \\\n                    f\"15\t                            +3\\n14\t                            \" \\\n                    f\"+2\\n13\t                            +1\\n12\t                            +1\\n10\" \\\n                    f\"\t                            +0\\n9\t                            -1\\n\"\n\n    stats = {\n        \"strength\": 15,\n        \"dexterity\": 14,\n        \"constitution\": 13,\n        \"intelligence\": 10,\n        \"wisdom\": 12,\n        \"charisma\": 9,\n    }\n\n    while True:\n        cls()\n        player_name = input(f\"Please enter character name: \")\n\n        if len(player_name) < 3:\n            print(f\"Minimum 3 characters!\")\n            sleep(.25)\n            continue\n\n        confirm_player_name = input(f\"Player name is {player_name}. Is this ok (y/N)? \").lower()\n\n        if confirm_player_name == 'y':\n            break\n\n        else:\n            continue\n\n    cls()\n    # print(f\"{player_name}:\")\n    print(f\"Default Stats (Recommended if unsure)\")\n\n    for key, value in stats.items():\n        print(key.capitalize(), \":\", value)\n    default_choice = input(f\"[ENTER] to use the above default stats or (C)ustomize? ([ENTER]/C): \").lower()\n\n    if default_choice != 'c':\n        player_1 = Player(name=player_name, **stats)\n        # pause()\n        return player_1\n\n    cls()\n    print(f\"Customization involves assigning your own attribute values.\\n\"\n          f\"The stats are picked from a set pool of six values: 15, 14, 13, 12, 10, 9\\n\"\n          f\"Each number will be matched with one of the six character attributes.\\n\"\n          f\"Note that each attribute value has a corresponding modifier, which\\n\"\n          f\"acts as a bonus, (or, as a penalty, in the case of a negative modifier),\\n\"\n          f\"and will become more important as you progress.\\n\"\n          f\"Attributes and modifiers increase as you level up.\\n\")\n    print(default_stats)\n    pause()\n    score_list = [15, 14, 13, 12, 10, 9]\n\n    while len(score_list):\n\n        for key in stats:\n            cls()\n            print(default_stats)\n            human_key = key.capitalize()\n            print(f\"{human_key}:\")\n            print(explanation_dict[human_key])\n            scores = convert_list_to_string_with_commas_only(score_list)\n            print(f\"Available scores: {scores}\")\n\n            try:\n                score = int(input(f\"Enter score to assign to {human_key} (or hit [ENTER] to start over): \"))\n\n                if score in score_list:\n                    print(f\"{key} = {score}\")\n                    sleep(.5)\n                    stats[key] = score\n                    score_list.remove(score)\n\n                else:\n                    score_list = [15, 14, 13, 12, 10, 9]  # re-set list\n                    print(f\"Valid scores are listed above.\")\n                    sleep(0.5)\n                    print(f\"Starting over.\")\n                    sleep(0.5)\n                    break\n\n            except ValueError:\n                print(f\"Invalid entry..\")\n                score_list = [15, 14, 13, 12, 10, 9]  # re-set list\n                sleep(0.5)\n                print(f\"Starting over.\")\n                sleep(0.5)\n                break\n    # for key, value in stats.items():\n    # print(key, \":\", value)\n    player_1 = Player(name=player_name, **stats)  # **stats sends the 'stats' dictionary as parameters\n    # pause()\n    return player_1\n\n\ndef game_start():\n    # called from main loop\n    while True:\n        sad_cello_theme()\n        game_splash()\n        cls()\n        player_1 = \"\"  # to get rid of undefined warning\n\n        intro_or_not = input(\"View Introduction? (y/N) \").lower()\n        if intro_or_not == 'y':\n            teletype_txt_file('introduction.txt')\n            pause()\n\n        while True:\n            cls()\n            new_game_or_load = input(\"(S)tart a new character, (L)oad a saved one, or go (B)ack to main menu: \").lower()\n\n            if new_game_or_load == 'b':\n                break\n\n            if new_game_or_load not in ('s', 'l'):\n                continue\n\n            elif new_game_or_load == 'l':\n                player_name = input(\"Enter name of saved character: \")\n                load_a_character = player_name + \".sav\"\n                p = Path(__file__).with_name(load_a_character)\n                random_floppy_rw_sound()\n                sleep(2)\n                if p.is_file():\n                    with p.open('rb') as saved_player:  # 'rb'\n                        same_line_print(f\"{player_name} found\")\n                        player_1 = pickle.load(saved_player)\n                        dot_dot_dot(5)\n                        same_line_print(f\"{player_name} read.\\n\")\n                        sleep(2)\n                        # dungeon = dungeon_dict[player_1.dungeon_key]  # diagnostic - remove after testing\n                        # print(dungeon.name)  # diagnostic - remove after testing\n                        # print(player_1.coordinates)  # diagnostic - remove after testing\n                        player_1.loaded_game = True\n                        sleep(1)\n                        return player_1\n\n                else:\n                    print(f\"Could not find {player_name} \")\n                    sleep(1.5)\n                    continue\n\n            elif new_game_or_load == 's':\n                accept_stats = \"\"\n\n                while accept_stats != 'y':\n                    player_1 = character_generator()\n                    player_1.hud()\n                    # print(f\"Dungeon Key {player_1.dungeon_key}\")\n                    accept_stats = input(f\"Accept character and continue? (y/N)? \").lower()\n\n                if accept_stats == \"y\":\n                    # player_1.dungeon_key = 1  # unneeded\n                    # player_1.dungeon = dungeon_dict[player_1.dungeon_key]  # should be unneeded\n                    (player_1.x, player_1.y) = player_1.dungeon.staircase\n                    player_1.position = 0\n                    player_1.hud()\n                    return player_1\n\n\ndef unknown_command():\n    print(\"Unknown command..\")\n    sleep(.25)\n\n\ndef npc_ally_hud_sub_function(npc):\n    # called from self.hud()\n    npc_ally_hud_hit_points = npc.hit_points\n    npc_readiness = \"(OK)\"\n    if npc.hit_points < 1:\n        npc_ally_hud_hit_points = 1\n        npc_readiness = \"(RETREATING)\"\n    print(f\"{npc.name}  HP: {npc_ally_hud_hit_points} {npc_readiness}\")\n\n\ndef augmentation_intro():\n    cls()\n    print(f\"                                  *Attribute Augmentation*\")\n    print()\n    print(\n        f\"You may choose to improve a single attribute, such as strength, and increase it by 2 points.\\n\"\n        f\"\\n\"\n        f\"                           *OR*\\n\"\n        f\"\\n\"\n        f\"You may choose to improve two attributes, such as charisma and constitution, by 1 point each.\\n\"\n        f\"\\n\"\n        f\"NOTES: \\n\"\n        f\"* Attribute *modifiers* improve with each ascending even-numbered score, therefore, if unsure,\\n\"\n        f\"  it is generally recommended to apply 1 point to odd-numbered attribute values and apply \\n\"\n        f\"2 points to even-numbered values.\\n\"\n        f\"* When your Constitution modifier increases by 1, your hit point maximum increases by 1 for each\\n\"\n        f\"  level you have attained.\\n\"\n        f\"                         *The maximum score for any attribute is 20*\"\n        f\"\\n\")\n    pause()\n\n\ndef stop_sound():\n    pass\n    #winsound.PlaySound(None, 0)\n\n\ndef sound_player(sound_file):\n    # a sound player function which simply plays sound_file asynchronously\n    pass\n    #if os.name == 'nt':\n    #    p = \"\"\n    #    try:\n    #        sound_folder = Path(__file__).with_name(\"sound\")\n    #        p = sound_folder / sound_file\n    #        # p = Path(__file__).with_name(sound_file)\n    #        with p.open('rb') as sound:\n    #            if sound.readable():\n    #                winsound.PlaySound(str(p), winsound.SND_FILENAME | winsound.SND_ASYNC)\n    #    except FileNotFoundError:\n            # pass  # restore after testing\n    #        print(f\"{p} not found.\")  # remove after testing\n    #        pause()  # remove after testing\n\n\ndef sound_player_loop(sound_file):\n    # a sound player function which plays sound_file asynchronously on a continuous loop\n    pass\n    #if os.name == 'nt':\n    #    p = \"\"\n    #    try:\n    #        sound_folder = Path(__file__).with_name(\"sound\")\n    #        p = sound_folder / sound_file\n    #        # print(p)\n    #        # p = Path(__file__).with_name(sound_file)\n    #        with p.open('rb') as sound_loop:\n    #            if sound_loop.readable():\n    #                winsound.PlaySound(str(p), winsound.SND_FILENAME | winsound.SND_LOOP | winsound.SND_ASYNC)\n    #    except FileNotFoundError:\n            # pass  # restore after testing\n    #        print(f\"{p} not found.\")  # remove after testing\n    #        pause()  # remove after testing\n\n\ndef gong():\n    # notice the gong is not looped!\n    sound_player('gong.wav')\n\n\ndef pc_powerup():\n    sound_player('pc_powerup.wav')\n\n\ndef floppy_rw():\n    sound_player('floppy_rw.wav')\n\n\ndef floppy_rw2():\n    sound_player('floppy_rw2.wav')\n\n\ndef floppy_insert_and_load():\n    sound_player('floppy_insert.wav')\n    sleep(1)\n    sound_player_loop('floppy_rw.wav')\n    # floppy_rw()\n    # sound_player('floppy_insert_and_load.wav')\n\n\ndef sad_cello_theme():\n    sound_player_loop('sad_cello_darren_curtis.wav')\n\n\ndef blacksmith_theme():\n    sound_player_loop('blacksmith_theme_2.wav')\n\n\ndef chemist_theme():\n    sound_player_loop('chemist_theme.wav')\n\n\ndef mountain_king_theme():\n    sound_player_loop('mountain_king.wav')\n\n\ndef pit_theme():\n    sound_player_loop('creepy_dungeon_theme_loop.wav')\n\n\ndef boss_battle_theme():\n    sound_player_loop('boss_battle_2.wav')\n\n\ndef town_theme():\n    sound_player_loop('town_(tavern)_loop_by_alexander_nakarada.wav')\n\n\ndef tavern_theme():\n    sound_player_loop('silvermansound_the medieval_banquet.wav')\n\n\ndef queen_confrontation_theme():\n    sound_player_loop('queen_confrontation.wav')\n\n\ndef final_victory_theme():\n    sound_player_loop('final_victory.wav')\n\n\nclass Weapon:\n\n    def __init__(self):\n        self.name = \"\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 0\n        self.to_hit_bonus = 0\n        self.sell_price = 0\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f\"{self.name} - Damage Bonus: {self.damage_bonus}  To-hit bonus: {self.to_hit_bonus}  \" \\\n               f\"Minimum level: {self.minimum_level}  Purchase Price: {self.buy_price} GP\"\n\n\nclass ShortSword(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Short Sword\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 0\n        self.to_hit_bonus = 0\n        self.sell_price = 5\n        self.buy_price = 10\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass BroadSword(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Broad Sword\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 2\n        self.to_hit_bonus = 1\n        self.sell_price = 5\n        self.buy_price = 25\n        self.minimum_level = 2\n        self.a_an = \"a\"\n\n\nclass GreatSword(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Great Sword\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 3\n        self.to_hit_bonus = 2\n        self.sell_price = 150\n        self.buy_price = 500\n        self.minimum_level = 4\n        self.a_an = \"a\"\n\n\nclass ElvishGreatSword(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Elvish Great Sword\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 10\n        self.to_hit_bonus = 4\n        self.sell_price = 2500\n        self.buy_price = 5000\n        self.minimum_level = 10\n        self.a_an = \"an\"\n\n\nclass WeirdSword(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Weird Sword\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 15  # 5\n        self.to_hit_bonus = 7\n        self.sell_price = 6000\n        self.buy_price = 55000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass QuantumSword(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Quantum Sword\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 12  # 5\n        self.to_hit_bonus = 5\n        self.sell_price = 5000\n        self.buy_price = 8000\n        self.minimum_level = 12\n        self.a_an = \"a\"\n\n\nclass QuantumAxe(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Quantum Axe\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 15  # 5\n        self.to_hit_bonus = 5\n        self.sell_price = 5000\n        self.buy_price = 8000\n        self.minimum_level = 12  # 3\n        self.a_an = \"a\"\n\n\nclass ShortAxe(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Short Axe\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 2\n        self.to_hit_bonus = -1\n        self.sell_price = 1\n        self.buy_price = 5\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass BattleAxe(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Battle Axe\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 3\n        self.to_hit_bonus = 0\n        self.sell_price = 5\n        self.buy_price = 50\n        self.minimum_level = 3\n        self.a_an = \"a\"\n\n\nclass GreatAxe(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Great Axe\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 4\n        self.to_hit_bonus = 0\n        self.sell_price = 15\n        self.buy_price = 500\n        self.minimum_level = 4\n        self.a_an = \"a\"\n\n\nclass ElvishGreatAxe(Weapon):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Elvish Great Axe\"\n        self.item_type = \"Weapons\"\n        self.damage_bonus = 12\n        self.to_hit_bonus = 4\n        self.sell_price = 2750\n        self.buy_price = 6000\n        self.minimum_level = 12\n        self.a_an = \"an\"\n\n\nclass Armor:\n\n    def __init__(self):\n        self.name = \"\"\n        self.item_type = \"Armor\"\n        self.armor_bonus = 0\n        self.ac = 0\n        self.sell_price = 0\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a set of\"\n\n    def __repr__(self):\n        return f'{self.name} - AC: {self.ac}  Armor bonus: {self.armor_bonus}  ' \\\n               f'Minimum level: {self.minimum_level}  Purchase Price: {self.buy_price} GP'\n\n\nclass PaddedArmor(Armor):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Padded Armor\"\n        self.item_type = \"Armor\"\n        self.ac = 10\n        self.armor_bonus = 0\n        self.sell_price = 1\n        self.buy_price = 5\n        self.minimum_level = 1\n        self.a_an = \"a set of\"\n\n\nclass LeatherArmor(Armor):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Leather Armor\"\n        self.item_type = \"Armor\"\n        self.ac = 11\n        self.armor_bonus = 0\n        self.sell_price = 5\n        self.buy_price = 15\n        self.minimum_level = 1\n        self.a_an = \"a set of\"\n\n\nclass StuddedLeatherArmor(Armor):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Studded Leather Armor\"\n        self.item_type = \"Armor\"\n        self.ac = 12\n        self.armor_bonus = 0\n        self.sell_price = 30\n        self.buy_price = 45\n        self.minimum_level = 2\n        self.a_an = \"a set of\"\n\n\nclass ScaleMail(Armor):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Scale Mail\"\n        self.item_type = \"Armor\"\n        self.ac = 14\n        self.armor_bonus = 0\n        self.sell_price = 300\n        self.buy_price = 500\n        self.minimum_level = 7\n        self.a_an = \"a set of\"\n\n\nclass HalfPlate(Armor):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Half Plate Armor\"\n        self.item_type = \"Armor\"\n        self.ac = 16\n        self.armor_bonus = 0\n        self.sell_price = 550\n        self.buy_price = 750\n        self.minimum_level = 12\n        self.a_an = \"a set of\"\n\n\nclass FullPlate(Armor):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Full Plate Armor\"\n        self.item_type = \"Armor\"\n        self.ac = 18\n        self.armor_bonus = 0\n        self.sell_price = 1000\n        self.buy_price = 1500\n        self.minimum_level = 15\n        self.a_an = \"a set of\"\n\n\nclass Shield:\n\n    def __init__(self):\n        self.name = \"Shield\"\n        self.item_type = \"Shields\"\n        self.ac = 0\n        self.sell_price = 0\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - AC: {self.ac}  Minimum level: {self.minimum_level}  Purchase Price: {self.buy_price} GP'\n\n\nclass NoShield(Shield):  # default\n    def __init__(self):\n        super().__init__()\n        self.name = \"No Shield\"\n        self.item_type = \"Shields\"\n        self.ac = 0\n        self.sell_price = 0\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"\"\n\n\nclass Buckler(Shield):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Buckler\"\n        self.item_type = \"Shields\"\n        self.ac = 1\n        self.sell_price = 5\n        self.buy_price = 50\n        self.minimum_level = 1  # 2\n        self.a_an = \"a\"\n\n\nclass KiteShield(Shield):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Kite Shield\"\n        self.item_type = \"Shields\"\n        self.ac = 2\n        self.sell_price = 50\n        self.buy_price = 100\n        self.minimum_level = 7\n        self.a_an = \"a\"\n\n\nclass QuantumTowerShield(Shield):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Quantum Tower Shield\"\n        self.item_type = \"Shields\"\n        self.ac = 3\n        self.sell_price = 375\n        self.buy_price = 700\n        self.minimum_level = 12\n        self.a_an = \"a\"\n\n\nclass Boots:\n\n    def __init__(self):\n        self.name = \"\"\n        self.item_type = \"Boots\"\n        self.ac = 0\n        self.sell_price = 0\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a pair of\"\n\n    def __repr__(self):\n        return f'{self.name} - AC: {self.ac}  Minimum level: {self.minimum_level}  Purchase Price: {self.buy_price} GP'\n\n\nclass LeatherBoots(Boots):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Leather Boots\"\n        self.item_type = \"Boots\"\n        self.ac = 0\n        self.sell_price = 1\n        self.buy_price = 1\n        self.minimum_level = 1\n        self.a_an = \"a pair of\"\n\n\nclass ElvenBoots(Boots):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Elven Boots\"\n        self.item_type = \"Boots\"\n        self.ac = 1\n        self.sell_price = 30\n        self.buy_price = 50\n        self.minimum_level = 1\n        self.a_an = \"a pair of\"\n\n\nclass AncestralFootsteps(Boots):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Ancestral Footsteps\"\n        self.item_type = \"Boots\"\n        self.ac = 2\n        self.sell_price = 300\n        self.buy_price = 500\n        self.minimum_level = 10\n        self.a_an = \"a pair of\"\n\n\nclass Cloak:\n\n    def __init__(self):\n        self.name = \"\"\n        self.item_type = \"Cloaks\"\n        self.stealth = 0\n        self.sell_price = 0\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Stealth: {self.stealth}  Minimum level: {self.minimum_level}  ' \\\n               f'Purchase Price: {self.buy_price} GP'\n\n\nclass CanvasCloak(Cloak):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Canvas Cloak\"\n        self.item_type = \"Cloaks\"\n        self.stealth = 0\n        self.sell_price = 1\n        self.buy_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass ElvenCloak(Cloak):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Elven Cloak\"\n        self.item_type = \"Cloaks\"\n        self.stealth = 1\n        self.sell_price = 25\n        self.buy_price = 50\n        self.minimum_level = 1\n        self.a_an = \"an\"\n\n\n# belt items\nclass Healing:\n    def __init__(self):\n        self.name = \"\"\n        self.item_type = \"Healing\"\n        self.heal_points = 0\n        self.buy_price = 0\n        self.sell_price = 0\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Purchase Price: {self.buy_price} GP'\n\n\nclass Elixir:\n    def __init__(self):\n        self.name = \"Clarifying Elixir\"\n        self.item_type = \"Elixirs\"\n        self.uses = 0\n        self.buy_price = 50\n        self.sell_price = 20\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Purchase Price: {self.buy_price} GP'\n\n\nclass Antidote:\n    def __init__(self):\n        self.name = \"Vial of Antidote\"\n        self.item_type = \"Antidotes\"\n        self.uses = 0\n        self.buy_price = 50\n        self.sell_price = 20\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Purchase Price: {self.buy_price} GP'\n\n\nclass HealingPotion(Healing):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Potion of Healing\"\n        self.item_type = \"Healing\"\n        self.heal_points = 0\n        self.buy_price = 50\n        self.sell_price = 20\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Purchase Price: {self.buy_price} GP'\n\n\nclass StrengthPotion:\n    def __init__(self):\n        self.name = \"Potion of Strength\"\n        self.item_type = \"Potions of Strength\"\n        self.duration = 5\n        self.buy_price = 50\n        self.sell_price = 20\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Purchase Price: {self.buy_price} GP'\n\n\nclass TownPortalImplements:\n\n    def __init__(self):\n        self.name = \"Scroll of Town Portal\"\n        self.item_type = \"Town Portal Implements\"\n        self.protect = 1\n        self.sell_price = 25\n        self.buy_price = 50\n        self.minimum_level = 1\n        self.uses = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return f'{self.name} - Purchase Price: {self.buy_price} GP'\n\n\n# rings\nclass Regeneration:\n\n    def __init__(self):\n        self.name = \"Ring of Regeneration\"\n        self.item_type = \"Rings of Regeneration\"\n        self.regenerate = 0\n        self.sell_price = 10000\n        self.buy_price = 10000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return self.name\n\n\nclass DefaultRingOfRegeneration(Regeneration):\n    def __init__(self):\n        super().__init__()\n        self.name = \"No Ring of Regeneration\"\n        self.item_type = \"Rings of Regeneration\"\n        self.regenerate = 0\n        self.sell_price = 10000\n        self.buy_price = 10000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass RingOfRegeneration(Regeneration):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Ring of Regeneration\"\n        self.item_type = \"Rings of Regeneration\"\n        self.regenerate = 1\n        self.sell_price = 10000\n        self.buy_price = 10000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass Protection:\n\n    def __init__(self):\n        self.name = \"\"\n        self.item_type = \"Rings\"\n        self.protect = 0\n        self.sell_price = 10000\n        self.buy_price = 10000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n    def __repr__(self):\n        return self.name\n\n\nclass DefaultRingOfProtection(Protection):\n    def __init__(self):\n        super().__init__()\n        self.name = \"No Ring of Protection\"\n        self.item_type = \"Rings of Protection\"\n        self.protect = 0\n        self.sell_price = 10000\n        self.buy_price = 10000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\nclass RingOfProtection(Protection):\n    def __init__(self):\n        super().__init__()\n        self.name = \"Ring of Protection\"\n        self.item_type = \"Rings of Protection\"\n        self.protect = 1\n        self.sell_price = 10000\n        self.buy_price = 10000\n        self.minimum_level = 1\n        self.a_an = \"a\"\n\n\ntop_level_loot_dict = {\n    'Armor': [LeatherArmor, StuddedLeatherArmor, ScaleMail, HalfPlate, FullPlate],\n    'Shields': [Buckler, KiteShield, QuantumTowerShield],\n    'Boots': [ElvenBoots, AncestralFootsteps],\n    'Cloaks': [ElvenCloak],\n    'Weapons': [ShortAxe, BroadSword, GreatSword, ElvishGreatSword, QuantumSword,\n                BattleAxe, GreatAxe, QuantumAxe],\n    'Elixirs': [Elixir],\n    'Healing': [HealingPotion],\n    'Rings of Regeneration': [RingOfRegeneration],\n    'Rings of Protection': [RingOfProtection],\n    'Town Portal Implements': [TownPortalImplements],\n    'Potions of Strength': [StrengthPotion],\n    'Antidotes': [Antidote]}\n\n\ndef undead_prophet_returns():\n    return \"Undead Prophet\"\n\n\ndef king_returns():\n    return \"King Boss\"\n\n\ndef nothing_happens():\n    print(f\"Nothing happens....\")\n    pause()\n    return\n\n\ndef npc_retreat_counter_logic(npc):\n    # called from self.monster_attacks_npc_meta(), for each npc, if retreating\n    npc.retreat_counter += 1\n    if npc.retreat_counter >= npc.retreat_counter_threshold:\n        return npc_end_of_turn_calculation(npc)\n\n\ndef npc_end_of_turn_calculation(npc):\n    # called from npc_calculation()\n    # when monster defeated, turned, or no longer in proximity, npc allies no longer in retreat\n    # they also fully heal\n    # also called from npc_retreat_counter_logic() when npc.retreat_counter >= npc.retreat_counter_threshold\n    if npc.retreating:\n        npc.retreating = False\n        npc.retreat_counter = 0\n        print(f\"{npc.name} is no longer retreating\")\n        sleep(1)\n    if npc.hit_points < npc.maximum_hit_points:\n        print(f\"{npc.name} heals to full strength.\")\n        npc.hit_points = npc.maximum_hit_points\n        sleep(1)\n\n\n# NPC allies\n\n\nclass VozzBozz:\n\n    def __init__(self):\n        self.name = \"Vozzbozz\"\n        self.level = 13\n        self.quantum_level = 6\n        self.maximum_quantum_units = 6000\n        self.quantum_units = 6000\n        self.experience = 0\n        self.base_dc = 10\n        self.gold = random.randint(2500, 4000)\n        self.wielded_weapon = QuantumSword()\n        self.armor = HalfPlate()\n        self.shield = NoShield()\n        self.boots = ElvenBoots()\n        # self.armor_bonus = self.armor.armor_bonus + self.shield.ac + self.boots.ac\n        self.strength = 13\n        self.strength_bonus = 1\n        self.strength_modifier = math.floor((self.strength - 10) / 2)\n        self.dexterity = 16\n        self.dexterity_modifier = math.floor((self.dexterity - 10) / 2)\n        self.constitution = 14\n        self.constitution_modifier = math.floor((self.constitution - 10) / 2)\n        self.intelligence = 20\n        self.intelligence_modifier = math.floor((self.intelligence - 10) / 2)\n        self.wisdom = 20\n        self.wisdom_modifier = math.floor((self.wisdom - 10) / 2)\n        self.charisma = 18\n        self.charisma_modifier = math.floor((self.charisma - 10) / 2)\n        self.hit_dice = 8\n        self.acumen = 1 + math.ceil(self.level / 4)\n        self.maximum_hit_points = 199 + self.constitution_modifier\n        self.hit_points = self.maximum_hit_points\n        self.armor_class = (self.armor.ac + self.armor.armor_bonus + self.shield.ac +\n                            self.boots.ac + self.dexterity_modifier)\n        self.protect = 6\n        self.retreating = False\n        self.retreat_counter = 0\n        self.retreat_counter_threshold = 1  # 1 full round of retreat, not including initial round\n\n\nclass SiKira:\n\n    def __init__(self):\n        self.name = \"Si'Kira\"\n        self.level = 10\n        self.quantum_level = 2\n        self.maximum_quantum_units = 2\n        self.quantum_units = 6\n        self.experience = 0\n        self.base_dc = 8\n        self.gold = random.randint(2500, 4000)\n        self.wielded_weapon = ElvishGreatSword()\n        self.armor = ScaleMail()\n        self.shield = KiteShield()\n        self.boots = ElvenBoots()\n        # self.armor_bonus = self.armor.armor_bonus + self.shield.ac + self.boots.ac\n        self.strength = 13\n        self.strength_bonus = 1\n        self.strength_modifier = math.floor((self.strength - 10) / 2)\n        self.dexterity = 17\n        self.dexterity_modifier = math.floor((self.dexterity - 10) / 2)\n        self.constitution = 14\n        self.constitution_modifier = math.floor((self.constitution - 10) / 2)\n        self.intelligence = 16\n        self.intelligence_modifier = math.floor((self.intelligence - 10) / 2)\n        self.wisdom = 16\n        self.wisdom_modifier = math.floor((self.wisdom - 10) / 2)\n        self.charisma = 18\n        self.charisma_modifier = math.floor((self.charisma - 10) / 2)\n        self.hit_dice = 8\n        self.acumen = 1 + math.ceil(self.level / 4)\n        self.maximum_hit_points = 70 + self.constitution_modifier\n        self.hit_points = self.maximum_hit_points\n        self.armor_class = (self.armor.ac + self.armor.armor_bonus + self.shield.ac + self.boots.ac\n                            + self.dexterity_modifier)\n        self.protect = 3\n        self.retreating = False\n        self.retreat_counter = 0\n        self.retreat_counter_threshold = 2  # 2 full rounds of retreat, not including initial round\n\n\nclass TorBron:\n\n    def __init__(self):\n        self.name = \"Tor'Bron\"\n        self.level = 10\n        self.quantum_level = 2\n        self.maximum_quantum_units = 2\n        self.quantum_units = 6\n        self.experience = 0\n        self.base_dc = 8\n        self.gold = random.randint(2500, 4000)\n        self.wielded_weapon = QuantumSword()\n        self.armor = HalfPlate()\n        self.shield = KiteShield()\n        self.boots = AncestralFootsteps()\n        # self.armor_bonus = self.armor.armor_bonus + self.shield.ac + self.boots.ac\n        self.strength = 17\n        self.strength_bonus = 1.5\n        self.strength_modifier = math.floor((self.strength - 10) / 2)\n        self.dexterity = 15\n        self.dexterity_modifier = math.floor((self.dexterity - 10) / 2)\n        self.constitution = 18\n        self.constitution_modifier = math.floor((self.constitution - 10) / 2)\n        self.intelligence = 14\n        self.intelligence_modifier = math.floor((self.intelligence - 10) / 2)\n        self.wisdom = 10\n        self.wisdom_modifier = math.floor((self.wisdom - 10) / 2)\n        self.charisma = 10\n        self.charisma_modifier = math.floor((self.charisma - 10) / 2)\n        self.hit_dice = 12\n        self.acumen = 1 + math.ceil(self.level / 4)\n        self.maximum_hit_points = 100 + self.constitution_modifier\n        self.hit_points = self.maximum_hit_points\n        self.armor_class = (self.armor.ac + self.armor.armor_bonus +\n                            self.shield.ac + self.boots.ac + self.dexterity_modifier)\n        self.protect = 4\n        self.retreating = False\n        self.retreat_counter = 0\n        self.retreat_counter_threshold = 1  # 1 full round of retreat, not including initial round\n\n\nclass Magnus:\n\n    def __init__(self):\n        self.name = \"Magnus\"\n        self.level = 10\n        self.quantum_level = 5\n        self.maximum_quantum_units = 15\n        self.quantum_units = 15\n        self.experience = 0\n        self.base_dc = 8\n        self.gold = random.randint(2500, 4000)\n        self.wielded_weapon = QuantumAxe()\n        self.armor = HalfPlate()\n        self.shield = KiteShield()\n        self.boots = AncestralFootsteps()\n        # self.armor_bonus = self.armor.armor_bonus + self.shield.ac + self.boots.ac\n        self.strength = 16\n        self.strength_bonus = 1.33\n        self.strength_modifier = math.floor((self.strength - 10) / 2)\n        self.dexterity = 15\n        self.dexterity_modifier = math.floor((self.dexterity - 10) / 2)\n        self.constitution = 16\n        self.constitution_modifier = math.floor((self.constitution - 10) / 2)\n        self.intelligence = 14\n        self.intelligence_modifier = math.floor((self.intelligence - 10) / 2)\n        self.wisdom = 10\n        self.wisdom_modifier = math.floor((self.wisdom - 10) / 2)\n        self.charisma = 10\n        self.charisma_modifier = math.floor((self.charisma - 10) / 2)\n        self.hit_dice = 10\n        self.acumen = 1 + math.ceil(self.level / 4)\n        self.maximum_hit_points = 100 + self.constitution_modifier\n        self.hit_points = self.maximum_hit_points\n        self.armor_class = (self.armor.ac + self.armor.armor_bonus +\n                            self.shield.ac + self.boots.ac + self.dexterity_modifier)\n        self.protect = 4\n        self.retreating = False\n        self.retreat_counter = 0\n        self.retreat_counter_threshold = 1  # 1 full round of retreat, not including initial round\n\n\n# Human Player:\n\n\nclass Player:\n\n    def __init__(self, name, strength, dexterity, constitution, intelligence, wisdom, charisma):\n        self.name = name\n        self.level = 1\n        self.quantum_level = 1\n        self.maximum_quantum_units = 2\n        self.quantum_units = self.maximum_quantum_units\n        self.encounter = 0\n        self.experience = 0\n        self.base_dc = 8\n        self.gold = 0\n        self.monsters_on = True  # diagnostic\n        self.wielded_weapon = ShortSword()\n        self.wielded_weapon.damage_bonus = 0\n        self.armor = PaddedArmor()\n        self.shield = NoShield()\n        self.boots = LeatherBoots()\n        # self.armor_bonus = self.armor.armor_bonus + self.shield.ac + self.boots.ac\n        self.strength = strength\n        self.strength_modifier = math.floor((self.strength - 10) / 2)\n        self.dexterity = dexterity\n        self.dexterity_modifier = math.floor((self.dexterity - 10) / 2)\n        self.constitution = constitution\n        self.constitution_modifier = math.floor((self.constitution - 10) / 2)\n        self.intelligence = intelligence\n        self.intelligence_modifier = math.floor((self.intelligence - 10) / 2)\n        self.wisdom = wisdom\n        self.wisdom_modifier = math.floor((self.wisdom - 10) / 2)\n        self.charisma = charisma\n        self.charisma_modifier = math.floor((self.charisma - 10) / 2)\n        self.hit_dice = 10\n        self.acumen = 1\n        self.maximum_hit_points = 12 + self.constitution_modifier\n        self.hit_points = self.maximum_hit_points  # Hit Points at 1st Level: 10 + your Constitution modifier\n        self.in_proximity_to_monster = False\n        self.is_paralyzed = False\n        self.cloak = CanvasCloak()\n        self.ring_of_prot = DefaultRingOfProtection()\n        self.ring_of_reg = DefaultRingOfRegeneration()\n        self.extra_attack = False\n        self.armor_class = (self.armor.ac + self.armor.armor_bonus +\n                            self.shield.ac + self.boots.ac + self.dexterity_modifier)\n        self.stealth = self.cloak.stealth\n        self.town_portals = 1\n        self.elixirs = 1\n        self.potions_of_healing = 1\n        self.antidotes = 1\n        self.potions_of_strength = 1\n        self.potion_of_strength_effect = False\n        self.potion_of_strength_uses = 0\n        self.max_quantum_strength_uses = self.quantum_level + self.strength_modifier\n        self.quantum_strength_uses = 0\n        self.quantum_strength_effect = False\n        self.protection_effect = False\n        self.protection_effect_uses = 0\n        self.max_protection_effect_uses = self.quantum_level + self.constitution_modifier\n        self.protection_effect_value = 0\n        self.poisoned = False\n        self.poisoned_turns = 0\n        self.max_poisoned_turns = 0\n        self.necrotic = False\n        self.necrotic_turns = 0\n        self.dot_multiplier = 1\n        self.dot_turns = 1\n        # self.current_dungeon_level = 1\n        self.dungeon_key = 1\n        self.dungeon = dungeon_dict[self.dungeon_key]\n        self.discovered_interactives = []\n        self.discovered_monsters = []\n        self.position = 0\n        self.x = 0\n        self.y = 0\n        self.coordinates = (self.x, self.y)\n        self.previous_x = 0\n        self.previous_y = 0\n        self.in_a_pit = False\n        self.vanquished_foes = []\n        self.sikira = SiKira()\n        self.torbron = TorBron()\n        self.magnus = Magnus()\n        self.vozzbozz = VozzBozz()\n        self.sikira_ally = False\n        self.torbron_ally = False\n        self.magnus_ally = False\n        self.vozzbozz_ally = False\n        self.boss_hint_1 = False\n        self.boss_hint_1_event = False\n        self.boss_hint_2 = False\n        self.boss_hint_2_event = False\n        self.boss_hint_3 = False\n        self.boss_hint_3_event = False\n        self.forced_portal = False\n        # self.boss_hint_4 = False\n        # self.boss_hint_4_event = False\n        # self.boss_hint_5 = False\n        # self.boss_hint_5_event = False\n        # self.boss_hint_6 = False\n        # self.boss_hint_6_event = False\n        self.loaded_game = False\n        self.forest_explored = False\n        self.town_portal_exists = False\n        self.in_town = False\n        self.in_dungeon = False\n        self.game_complete = False\n        self.pack = {\n            'Armor': [],\n            'Shields': [],\n            'Boots': [],\n            'Weapons': [],\n            'Cloaks': []\n\n        }\n\n    def dungeon_theme(self):\n        if os.name == 'nt':\n            if not self.in_a_pit:\n                sound_player_loop('dungeon_theme_2.wav')\n            else:\n                pit_theme()\n\n    def regenerate(self):\n        if self.hit_points < self.maximum_hit_points and self.ring_of_reg.regenerate > 0:\n            regeneration = self.ring_of_reg.regenerate\n            self.hit_points = self.hit_points + regeneration\n            if self.hit_points > self.maximum_hit_points:\n                self.hit_points = self.maximum_hit_points\n            print(f\"*YOU REGENERATE + {regeneration}*\")  # remove after testing\n            sleep(1)\n        return\n\n    def restart(self):\n        # called from self.town_navigation()\n        print(\"Restart..\")\n        sleep(.5)\n        if are_you_sure():\n            random_floppy_rw_sound()\n            sleep(3)\n            cls()\n            self.in_town = False\n            return \"Restart\"\n        else:\n            return False\n\n    def end_game_check(self, monster):\n        # called from main loop\n        if monster.proper_name == \"Queen Jannbrielle the Wicked\":\n            self.game_complete = True\n            return True\n        else:\n            return False\n\n    def end_game_character_condition_resets(self):  # player defeats final boss\n        # called from main loop.\n        # reset character conditions before saving character with end_game_routine()\n\n        # give player weird sword as reward for game completion\n        self.wielded_weapon = WeirdSword()\n\n        # remove allies\n        self.torbron_ally = False\n        self.magnus_ally = False\n        self.vozzbozz_ally = False\n        self.sikira_ally = False\n\n        # reset calculations\n        self.poisoned = False\n        self.poisoned_turns = 0\n        self.necrotic = False\n        self.necrotic_turns = 0\n        self.potion_of_strength_effect = False\n        self.potion_of_strength_uses = 0\n        self.quantum_strength_effect = False\n        self.quantum_strength_uses = 0\n        self.protection_effect = False\n        self.protection_effect_uses = 0\n        self.protection_effect_value = 0\n\n        # reset to full health:\n        self.hit_points = self.maximum_hit_points\n        # reset to full quantum units:\n        self.quantum_units = self.maximum_quantum_units\n\n        # put player back at level 1:\n        self.monsters_on = True\n        self.town_portal_exists = True  # transport player back to town. on replay, player will re-enter portal\n        self.dungeon_key = 1\n        self.dungeon = dungeon_dict[self.dungeon_key]\n        (self.x, self.y) = self.dungeon.staircase\n        self.coordinates = (self.x, self.y)\n        self.previous_x = self.x\n        self.previous_y = self.y\n        self.position = 0  # self.dungeon.grid[self.y][self.x]\n        self.hud()\n\n    def end_game_routine(self):\n        # called from self.choose_to_play_again()\n        self.game_complete = False  # reset condition for replay\n        final_victory_theme()\n        cls()\n        teletype_txt_file('end_game.txt')\n        pause()\n        cls()\n        teletype_txt_file('end_game2.txt')\n        pause()\n        cls()\n        teletype(f\"Congratulations!\\nYou have defeated Wicked Queen Jannbrielle and restored peace to the realm.\\n\")\n        pause()\n\n        save_a_character = self.name + \".sav\"\n        p = Path(__file__).with_name(save_a_character)\n        # same_line_print(f\"Saving {self.name}\")\n        # random_floppy_rw_sound()\n        # dot_dot_dot(15)\n\n        with p.open('wb') as character_filename:  # 'wb'\n            # noinspection PyTypeChecker\n            pickle.dump(self, character_filename)\n            print(f\"Well done, {self.name}.\\n\")\n            sleep(2)\n\n        cls()\n        teletype_txt_file('credits.txt')\n        pause()\n        cls()\n        teletype_txt_file('credits2.txt')\n        pause()\n        cls()\n        teletype_txt_file('credits3.txt')\n        pause()\n        cls()\n        print(f\"\\nSauengard Copyright 2022, JULES PITSKER  (pitsker@proton.me)\\nAll rights reserved\\n\")\n        pause()\n\n        '''while True:\n            cls()\n            try_again = input(\"Do you wish to play again (y/n)? \").lower()\n            if try_again == \"y\":\n                sleep(1.5)\n                cls()\n                self.in_proximity_to_monster = False\n                self.in_dungeon = False\n                self.in_town = False\n                # player_is_dead = False\n                return True  # return to self.choose_to_play_again() and main loop, which will break and reset game\n            if try_again == \"n\":\n                print(f\"Farewell.\")\n                sleep(1.5)\n                cls()\n                sys.exit()'''\n\n    def save_character(self):\n        # called from self.town_navigation()\n        save_a_character = self.name + \".sav\"\n        p = Path(__file__).with_name(save_a_character)\n\n        if p.is_file():\n\n            while True:\n                self.hud()\n                confirm_save = input(f\"{self.name} already saved. Overwrite? (y/n)? \").lower()\n\n                if confirm_save == 'n':\n                    return\n\n                elif confirm_save == 'y':\n                    break\n\n        same_line_print(f\"Saving {self.name}\")\n        random_floppy_rw_sound()\n        dot_dot_dot(15)\n        with p.open('wb') as character_filename:  # 'wb'\n            # noinspection PyTypeChecker\n            pickle.dump(self, character_filename)\n            same_line_print(f\"{self.name} saved.\\n\")\n            sleep(2)\n        tavern_theme()\n        # town_theme()\n        return\n\n    def hud(self):\n        cls()\n        print(f\"{self.name}\")\n\n        print(f\"Level: {self.level} ({self.level}d{self.hit_dice})\")\n        print(f\"Experience: {self.experience}\")\n        print(f\"Gold: {self.gold}\")\n        print(f\"Weapon: {self.wielded_weapon.name} (Damage Bonus: {self.wielded_weapon.damage_bonus}) \"\n              f\"(To-hit bonus: {self.wielded_weapon.to_hit_bonus})\")\n        if self.armor.armor_bonus > 0:\n            print(f\"Armor: {self.armor.name} (AC: {self.armor.ac}) (ARMOR BONUS: {self.armor.armor_bonus}\")\n        else:\n            print(f\"Armor: {self.armor.name} (AC: {self.armor.ac})\")\n        print(f\"Shield: {self.shield.name} (AC: {self.shield.ac})\")\n        print(f\"Boots: {self.boots.name} (AC: {self.boots.ac})\")\n        print(f\"Your Armor Class: {self.armor_class}\")\n        print(f\"Strength: {self.strength} (Modifier: {self.strength_modifier})\")\n        print(f\"Dexterity: {self.dexterity} (Modifier: {self.dexterity_modifier})\")\n        print(f\"Constitution: {self.constitution} (Modifier: {self.constitution_modifier})\")\n        print(f\"Intelligence: {self.intelligence} (Modifier: {self.intelligence_modifier})\")\n        print(f\"Wisdom: {self.wisdom} (Modifier: {self.wisdom_modifier})\")\n        print(f\"Charisma: {self.charisma} (Modifier: {self.charisma_modifier})\")\n        print(f\"Hit points: {self.hit_points}/{self.maximum_hit_points}\")\n        print(f\"Quantum units: {self.quantum_units}/{self.maximum_quantum_units}\")\n        print(f\"Cloak: {self.cloak.name} (Stealth: {self.stealth})\")\n\n        if self.potions_of_strength > 0:\n            print(f\"Potions of Giant Strength: {self.potions_of_strength}\")\n        if self.potions_of_healing > 0:\n            print(f\"Potions of Healing: {self.potions_of_healing}\")\n        if self.town_portals > 0:\n            print(f\"Town Portal Scrolls: {self.town_portals}\")\n        if self.elixirs > 0:\n            print(f\"Elixirs: {self.elixirs}\")\n        if self.antidotes > 0:\n            print(f\"Vials of Antidote: {self.antidotes}\")\n        if self.ring_of_reg.name != \"No Ring of Regeneration\":\n            print(f\"Ring of Regeneration: +{self.ring_of_reg.regenerate}\")\n        if self.ring_of_prot.name != \"No Ring of Protection\":\n            print(f\"Ring of Protection: +{self.ring_of_prot.protect}\")\n        if self.potion_of_strength_effect and self.potion_of_strength_uses > -1:\n            print(f\"(STRENGTH POTION EFFECT)  ({self.potion_of_strength_uses}/{self.max_quantum_strength_uses})\")\n        if self.quantum_strength_effect and self.quantum_strength_uses > -1:\n            print(f\"QUANTUM STRENGTH EFFECT)  ({self.quantum_strength_uses}/{self.max_quantum_strength_uses})\")\n        if self.protection_effect and self.protection_effect_uses > -1:\n            print(f\"(PROT/EVIL: {self.protection_effect_value}) \"\n                  f\"({self.protection_effect_uses}/{self.max_protection_effect_uses})\")\n        if self.poisoned:\n            print(f\"(POISONED)  Poison clarifying: ({self.poisoned_turns}/{self.dot_turns})\")\n        if self.necrotic:\n            print(f\"(NECROTIC)  Necrotic clarifying: ({self.necrotic_turns}/{self.dot_turns})\")\n        if self.sikira_ally:\n            print(f\"ALLIES:\")\n            npc_ally_hud_sub_function(self.sikira)\n            if self.torbron_ally:\n                npc_ally_hud_sub_function(self.torbron)\n            if self.magnus_ally:\n                npc_ally_hud_sub_function(self.magnus)\n            if self.vozzbozz_ally:\n                npc_ally_hud_sub_function(self.vozzbozz)\n        print()\n        return\n\n    # CALCULATION\n    def monster_attacks_npc_meta(self, monster):\n        # called from main loop, after monster attacks human player. (also called after paralyze attacks.)\n        # if monster has multi_attack ability, monster attacks all npc allies\n        self.hud()\n        # monster.multi_attack ability allows monster to attack ALL npc allies\n        if monster.multi_attack:\n            if self.sikira_ally:\n                if not self.sikira.retreating:\n                    monster.meta_monster_vs_npc_function(self.sikira)\n                    self.npc_retreat_logic(self.sikira)\n                    self.hud()\n                else:\n                    npc_retreat_counter_logic(self.sikira)\n            if self.torbron_ally:\n                if not self.torbron.retreating:\n                    monster.meta_monster_vs_npc_function(self.torbron)\n                    self.npc_retreat_logic(self.torbron)\n                    self.hud()\n                else:\n                    npc_retreat_counter_logic(self.torbron)\n            if self.magnus_ally:\n                if not self.magnus.retreating:\n                    monster.meta_monster_vs_npc_function(self.magnus)\n                    self.npc_retreat_logic(self.magnus)\n                    self.hud()\n                else:\n                    npc_retreat_counter_logic(self.magnus)\n            if self.vozzbozz_ally:\n                if not self.vozzbozz.retreating:\n                    monster.meta_monster_vs_npc_function(self.vozzbozz)\n                    self.npc_retreat_logic(self.vozzbozz)\n                    self.hud()\n                else:\n                    npc_retreat_counter_logic(self.vozzbozz)\n            return\n\n        elif monster.lesser_multi_attack:\n\n            # monster.lesser_multi_attack. create a list of non-retreating allies, if any:\n            allies = []\n\n            if self.sikira_ally:\n                if not self.sikira.retreating:\n                    allies.append(self.sikira)\n                else:\n                    npc_retreat_counter_logic(self.sikira)\n\n            if self.torbron_ally:\n                if not self.torbron.retreating:\n                    allies.append(self.torbron)\n                else:\n                    npc_retreat_counter_logic(self.torbron)\n\n            if self.magnus_ally:\n                if not self.magnus.retreating:\n                    allies.append(self.magnus)\n                else:\n                    npc_retreat_counter_logic(self.magnus)\n\n            if self.vozzbozz_ally:\n                if not self.vozzbozz.retreating:\n                    allies.append(self.vozzbozz)\n                else:\n                    npc_retreat_counter_logic(self.vozzbozz)\n\n            # one ally is then randomly chosen and attacked by monster:\n            if len(allies):\n                ally = random.choice(allies)\n                monster.meta_monster_vs_npc_function(ally)\n                self.npc_retreat_logic(ally)\n\n    def npc_retreat_logic(self, npc):\n        # called from self.monster_attacks_npc_meta(), after monster attack turn\n        if npc.hit_points < 1:\n            npc.retreating = True\n            self.hud()\n            print(f\"{npc.name} is retreating!\")\n            pause()\n\n    def npc_calculation(self):\n        # called from main loop, after player end_of_turn_calculation()\n        # when monster defeated, turned, or no longer in proximity, npc allies no longer in retreat\n        # they also fully heal\n        if self.sikira_ally:\n            npc_end_of_turn_calculation(self.sikira)\n        if self.torbron_ally:\n            npc_end_of_turn_calculation(self.torbron)\n        if self.magnus_ally:\n            npc_end_of_turn_calculation(self.magnus)\n        if self.vozzbozz_ally:\n            npc_end_of_turn_calculation(self.vozzbozz)\n\n    def end_of_turn_calculation(self):\n        # called from main loop at end of player navigation, or battle turn\n        self.regenerate()\n        self.calculate_potion_of_strength()  # potions of strength have max uses = self.max_quantum_strength_uses\n        self.calculate_quantum_strength()  # self.max_quantum_strength_uses= self.quantum_level + self.strength_modifier\n        self.calculate_protection_effect()  # max_protection_effect_uses= self.quantum_level+ self.constitution_modifier\n        self.calculate_poison()  # poison wears off after self.dot_turns which = monster.dot_turns during battle\n        self.calculate_necrotic_dot()  # necrosis wears off after self.dot_turns which = monster.dot_turns during battle\n\n    def calculate_stealth(self):\n        # called from found_cloak_substitution() as well as item_management()\n        self.stealth = self.cloak.stealth\n        return\n\n    def calculate_armor_class(self):\n        # called from monster_likes_you(), item_management(), found_shield_substitution, found_armor_substitution()\n        self.armor_class = self.armor.ac + self.armor.armor_bonus + \\\n                           self.shield.ac + self.boots.ac + self.dexterity_modifier\n        return\n\n    def calculate_poison(self):\n        # called from end_of_turn_calculation() meta function\n        if self.poisoned:\n\n            if self.poisoned_turns >= self.dot_turns:\n                self.poisoned = False\n                self.poisoned_turns = 0\n                print(f\"The poison leaves your body..\")\n                sleep(1.5)\n\n            else:\n                self.poisoned = True\n                self.poisoned_turns += 1\n                poison_damage = (1 * self.dot_multiplier)\n                self.hit_points -= poison_damage\n                print(f\"*POISON DAMAGE: {poison_damage}*\")\n                sleep(1.5)\n\n        return self.poisoned\n\n    def calculate_necrotic_dot(self):\n        # called from end_of_turn_calculation() meta function\n        if self.necrotic:\n\n            if self.necrotic_turns >= self.dot_turns:\n                self.necrotic = False\n                self.necrotic_turns = 0\n                print(f\"The necrotic plague leaves your body..\")\n                sleep(1.5)\n\n            else:\n                self.necrotic = True\n                self.necrotic_turns += 1\n                necrotic_damage = (1 * self.dot_multiplier)\n                self.hit_points -= necrotic_damage\n                print(f\"*NECROTIC DAMAGE -{necrotic_damage}*\")\n                sleep(1.5)\n\n        return self.necrotic\n\n    def calculate_quantum_strength(self):\n        # called from end_of_turn_calculation() meta function\n        if self.quantum_strength_effect:\n\n            if self.quantum_strength_uses >= self.max_quantum_strength_uses:  # self.quantum_lvl+self.strength_modifier\n                self.quantum_strength_effect = False\n                self.quantum_strength_uses = 0\n                print(f\"The Quantum Effects wear off....the giant strength leaves your body..\")\n                pause()\n\n            else:\n                self.quantum_strength_effect = True\n                self.quantum_strength_uses += 1\n\n        return self.quantum_strength_effect\n\n    def calculate_potion_of_strength(self):\n        # called from end_of_turn_calculation() meta function\n        if self.potion_of_strength_effect:\n\n            if self.potion_of_strength_uses >= self.max_quantum_strength_uses:  # self.strength_modifier + 2:\n                self.potion_of_strength_effect = False\n                self.potion_of_strength_uses = 0\n                print(f\"The potion's effect wears off....the giant strength leaves your body..\")\n                pause()\n\n            else:\n                self.potion_of_strength_effect = True\n                self.potion_of_strength_uses += 1\n\n        return self.potion_of_strength_effect\n\n    def calculate_protection_effect(self):\n        # called from end_of_turn_calculation() meta function\n        if self.protection_effect:\n\n            if self.protection_effect_uses >= self.max_protection_effect_uses:\n                self.protection_effect = False\n                self.protection_effect_uses = 0\n                self.protection_effect_value = 0\n                print(f\"The Quantum Protection effect wears off...\")\n                pause()\n\n            else:\n                self.protection_effect = True\n                self.protection_effect_uses += 1\n                # self.protection_effect_value = (2 + self.level)\n                if self.protection_effect_value > 10:  # beta\n                    self.protection_effect_value = 10\n\n        return self.protection_effect\n\n    def calculate_modifiers(self):\n        # called from augmentation_system(), increase_random_ability(), decrease_random_ability(),\n        # level_up(), increase_lowest_ability() and decrease_lowest_ability()\n        self.strength_modifier = math.floor((self.strength - 10) / 2)\n        self.dexterity_modifier = math.floor((self.dexterity - 10) / 2)\n        # When your Constitution modifier increases by 1,\n        # your hit point maximum increases by 1 for each level you have attained.\n        before_con_mod = self.constitution_modifier\n        self.constitution_modifier = math.floor((self.constitution - 10) / 2)\n        after_con_mod = self.constitution_modifier\n        if after_con_mod > before_con_mod:\n            print(f\"Weird powers are stirred up within you...\")\n            sleep(1)\n            self.maximum_hit_points += self.level\n            self.hit_points = self.maximum_hit_points\n            print(f\"Your Constitution Modifier has increased from {before_con_mod} to {after_con_mod}!\")\n            sleep(1)\n            print(f\"You gain {self.level} maximum hit points!\")\n            sleep(1)\n            print(f\"You feel your vitality surge.\")\n            sleep(1)\n        self.intelligence_modifier = math.floor((self.intelligence - 10) / 2)\n        self.wisdom_modifier = math.floor((self.wisdom - 10) / 2)\n        self.charisma_modifier = math.floor((self.charisma - 10) / 2)\n        self.max_protection_effect_uses = self.quantum_level + self.constitution_modifier\n        self.max_quantum_strength_uses = self.quantum_level + self.strength_modifier\n        return\n\n    def calculate_acumen(self):\n        # called from level_up()\n        if self.level == 1:\n            self.acumen = 1\n\n        if self.level > 1 < 4:\n            self.acumen = 2\n\n        if self.level > 3 < 7:\n            self.acumen = 3\n\n        if self.level > 6 < 13:\n            self.acumen = 4\n\n        if self.level > 12 < 17:\n            self.acumen = 5\n\n        if self.level > 16:\n            self.acumen = 6\n\n        return\n\n    # Quantum LEVEL   EXPERIENCE LEVEL\n    #                    NEEDED TO USE\n    # 1                       1\n    # 2                       3\n    # 3                       6\n    # 4                       9\n    # 5                       12\n    # 6                       15\n\n    def calculate_current_level(self):\n        # called from level_up()\n        if self.experience < 300:\n            self.level = 1\n            self.quantum_level = 1\n            self.maximum_quantum_units = 2\n\n        if self.experience >= 300 < 900:\n            self.level = 2\n            self.quantum_level = 1\n            self.maximum_quantum_units = 4\n\n        if self.experience >= 900 < 2700:\n            self.level = 3\n            self.quantum_level = 2\n            self.maximum_quantum_units = 6\n\n        if self.experience >= 2700 < 6500:\n            self.level = 4\n            self.quantum_level = 2\n            self.maximum_quantum_units = 6\n\n        if self.experience >= 6500 < 14000:\n            self.level = 5\n            self.quantum_level = 2\n            self.maximum_quantum_units = 6\n\n        if self.experience >= 14000 < 23000:\n            self.level = 6\n            self.quantum_level = 3\n            self.maximum_quantum_units = 8\n\n        if self.experience >= 23000 < 34000:\n            self.level = 7\n            self.quantum_level = 3\n            self.maximum_quantum_units = 8\n\n        if self.experience >= 34000 < 48000:\n            self.level = 8\n            self.quantum_level = 4\n            self.maximum_quantum_units = 10\n\n        if self.experience >= 48000 < 64000:\n            self.level = 9\n            self.quantum_level = 4\n            self.maximum_quantum_units = 10\n\n        if self.experience >= 64000 < 85000:\n            self.level = 10\n            self.quantum_level = 5\n            self.maximum_quantum_units = 12\n\n        if self.experience >= 85000 < 100000:\n            self.level = 11\n            self.quantum_level = 5\n            self.maximum_quantum_units = 12\n\n        if self.experience >= 100000 < 120000:\n            self.level = 12\n            self.quantum_level = 5\n            self.maximum_quantum_units = 14\n\n        if self.experience >= 120000 < 140000:\n            self.level = 13\n            self.quantum_level = 5\n            self.maximum_quantum_units = 16\n\n        if self.experience >= 140000 < 165000:\n            self.level = 14\n            self.quantum_level = 5\n            self.maximum_quantum_units = 18\n\n        if self.experience >= 165000 < 195000:\n            self.level = 15\n            self.quantum_level = 6\n            self.maximum_quantum_units = 18\n\n        if self.experience >= 195000 < 225000:\n            self.level = 16\n            self.quantum_level = 6\n            self.maximum_quantum_units = 20\n\n        if self.experience >= 225000 < 265000:\n            self.level = 17\n            self.quantum_level = 6\n            self.maximum_quantum_units = 24\n\n        if self.experience >= 265000 < 305000:\n            self.level = 18\n            self.quantum_level = 6\n            self.maximum_quantum_units = 30\n\n        if self.experience >= 305000 < 355000:\n            self.level = 19\n            self.quantum_level = 6\n            self.maximum_quantum_units = 36\n\n        if self.experience >= 355000:\n            self.level = 20\n            self.quantum_level = 6\n            self.maximum_quantum_units = 1000\n\n        return\n\n    # LEVEL AND EXPERIENCE\n    def augment_eligibility(self):\n        if self.strength < 20 or self.dexterity < 20 or self.constitution < 20 or self.intelligence < 20 \\\n                or self.wisdom < 20 or self.charisma < 20:\n            return True\n        else:\n            print(f\"All attributes at maximum!\")  # remove after testing\n            return False\n\n    def augmentation_system(self):\n        # called from level_up()\n        # Attribute augmentation at levels 4, 6, 8, 10, 12, 14, 16, 18\n        # also, if player goes up more than one level, by gaining a large amount of experience,\n        # augmentation is available\n\n        while True:\n            self.hud()\n            tries = 0\n            points = 2\n            while True:\n                self.hud()\n\n                if tries > 1:\n                    return\n\n                attribute_dict = self.__dict__  # create variable as actual copy of player dict attribute\n                attribute_lst = []  # list to be populated with all attributes < 20\n                # the working dict and 'for' loop just takes the place of many 'if:' statements\n                working_dict = {'strength': self.strength, 'dexterity': self.dexterity,\n                                'constitution': self.constitution, 'intelligence': self.intelligence,\n                                'wisdom': self.wisdom, 'charisma': self.charisma}\n\n                # add all attributes < 20 in working dict to ability_lst to define attributes you are allowed to change:\n                for key, value in working_dict.items():\n                    if value < 20:\n                        attribute_lst.append(key)\n\n                # this code is reachable if stats are maxed out, and level_up() calls it:\n                if not len(attribute_lst):  # if ability list is empty, all stats at 20; no more improvements allowed\n                    print(f\"All of your attributes are at the maximum level!\")\n                    sleep(1.25)\n                    return\n\n                print(f\"Attribute Augmentation\\n\"\n                      f\"Player level: {self.level}\")\n                print(f\"Points to distribute: {points}\")\n                # create a subset ability dictionary from the ability list by indexing, and then print out\n                attribute_dict_subset_too = {}\n                for attribute in attribute_lst:\n                    if len(attribute_lst):\n                        attribute_dict_subset_too[attribute_lst.index(attribute)] = attribute\n                for key, value in attribute_dict_subset_too.items():\n                    print(key + 1, ':', value.capitalize())  # add 1 to key since indexing begins at 0\n\n                try:\n                    attribute_index = int(input(f\"Enter the attribute to improve.\\n\"\n                                                f\"(THIS IS PERMANENT!) : \"))\n                    attribute_index -= 1  # indexing begins at zero...\n                    attribute_to_improve = (attribute_dict_subset_too[attribute_index])\n                    old_score = attribute_dict[attribute_to_improve]\n                    attribute_dict[attribute_to_improve] += 1\n                    print(\n                        f\"Your {attribute_to_improve} has been increased from {old_score} \"\n                        f\"to {attribute_dict[attribute_to_improve]}!\")\n                    self.calculate_modifiers()\n                    tries += 1\n                    points -= 1\n                    pause()\n                    continue\n\n                except (ValueError, KeyError):\n                    print(\"Invalid entry..\")\n                    sleep(1)\n                    continue\n\n    def level_up(self, exp_award, monster_gold):\n        # called from main loop after victory\n        self.gold += monster_gold\n\n        before_level = self.level\n        before_quantum_level = self.quantum_level\n        before_acumen = self.acumen\n\n        self.experience += exp_award\n        self.calculate_current_level()\n        self.calculate_acumen()\n\n        after_acumen = self.acumen\n        after_level = self.level\n        level_multiplier = (after_level - before_level)  # in case player goes up more than 1 level\n        after_quantum_level = self.quantum_level\n\n        if after_level > before_level:\n            self.quantum_units = self.maximum_quantum_units  # necessary code for advancing from level 1 to 2\n\n            if monster_gold > 0:\n                print(f\"You snarf {monster_gold} gold pieces.\")\n                sleep(1)\n            print(f\"You gain {exp_award} experience points.\")\n            sleep(2)\n            gong()\n            if level_multiplier > 1:\n                print(f\"You have gained {level_multiplier} experience levels!\")\n            elif level_multiplier == 1:\n                print(f\"You went up a level!!\")\n            sleep(2)\n            print(f\"You are now level {self.level}.\")\n            sleep(2)\n            self.dungeon_theme()\n            self.calculate_acumen()\n            gain_hit_points1 = (dice_roll(1, self.hit_dice) + self.constitution_modifier) * level_multiplier  # method 1\n            gain_hit_points2 = (6 + self.constitution_modifier) * level_multiplier  # hp increase method 2\n            hit_point_list = [gain_hit_points1, gain_hit_points2]\n            gain_hit_points = max(hit_point_list)  # the highest of method 1 and 2\n            self.hit_points += gain_hit_points  # you heal and gain max hp (previous HP + Hit Die roll + CON modifier)\n            self.maximum_hit_points += gain_hit_points\n            print(f\"You gain {gain_hit_points} hit points\")\n            sleep(2.5)\n\n            # Attribute augmentation at levels 4, 6, 8, 10, 12, 14, 16, 18\n            # augmentation logic\n            # This logic also works for players going up more than one level,\n            # e.g. vanquishing a monster with very high experience reward\n            # Logic works by creating 2 lists and comparing whether the player's current level, or any levels between\n            # their last level and current level are augmentation eligible.\n            # Ranges are initially counterintuitive in python;\n            # they do not include the last number in range, so I added +1 to end_range\n            # Also, for the current purposes, I added +1 to start_range as well, since we don't want to award augments\n            # based on the previous experience level, only on current level and any eligible levels between.\n\n            range_1 = range((before_level + 1), (after_level + 1), 1)  # enumerate levels between, inc. after_level by 1\n            all_levels_between = list(range_1)  # create a list containing levels between, including after_level\n            augment_levels = [4, 6, 8, 10, 12, 14, 16, 18]\n\n            # check if any levels between are augmentation levels by comparing elements from both lists\n            # number_of_augment_awards = sum of all_levels_between elements which exist in augment_levels:\n            number_of_augment_awards = sum(el in all_levels_between for el in augment_levels)\n            augment_level_check = False\n            if number_of_augment_awards > 0:\n                augment_level_check = True\n\n            if augment_level_check:\n                if self.augment_eligibility():  # ensure player has at least 1 ability value < 20\n                    if number_of_augment_awards > 1:\n                        print(f\"You have earned {number_of_augment_awards} ability augments!\")\n                        pause()\n\n                    augmentation_intro()\n                    for i in range(number_of_augment_awards):\n                        self.augmentation_system()\n                    if not self.game_complete:\n                        print(f\"You savor the empowering augmentation you have gained..\\n\"\n                              f\"And yet, the dungeon horde grows more powerful with you!\")\n                        pause()\n                    self.hud()\n\n            self.calculate_modifiers()\n\n            if 5 in all_levels_between:  # players gain extra attack skill at level 5 # if self.level == 5:\n                self.extra_attack = True\n                print(\"You gain the Extra Attack skill!!\")\n                pause()\n                self.hud()\n\n            if after_acumen > before_acumen:\n                print(f\"Your Acumen increases from {before_acumen} to {after_acumen}!\")\n                pause()\n                self.hud()\n\n            if after_quantum_level > before_quantum_level:\n                print(f\"Your Quantum knowledge level increases from {before_quantum_level} to {after_quantum_level}!\")\n                self.quantum_units = self.maximum_quantum_units\n                pause()\n                self.hud()\n\n            self.hud()\n\n        else:\n            if monster_gold > 0:\n                if monster_gold == 1:\n                    print(f\"You snarf {monster_gold} gold piece.\")\n                else:\n                    print(f\"You snarf {monster_gold} gold pieces.\")\n                sleep(1)\n            print(f\"You gain {exp_award} experience points.\")\n            sleep(2)\n            self.hud()\n\n    # BATTLE AND PROXIMITY TO MONSTER OCCURRENCES\n\n    def try_again_sub_function(self):\n\n        while True:\n            cls()\n            try_again = input(\"Do you wish to play again (y/n)? \").lower()\n            if try_again == \"y\":\n                sleep(1.5)\n                cls()\n                self.in_proximity_to_monster = False\n                self.in_dungeon = False\n                self.in_town = False\n                # player_is_dead = False\n                return True\n            if try_again == \"n\":\n                print(f\"Farewell.\")\n                sleep(1.5)\n                cls()\n                sys.exit()\n\n    def choose_to_play_again(self):\n        # called from main loop if game_over variable is True\n        cls()\n        gong()\n        if not self.game_complete:\n            print_txt_file('grim_reaper.txt')\n            teletype(f\"\\n                 \"\n                     f\"Another adventurer has fallen prey to the Sauengard Dungeon!\")\n            sleep(4.5)\n            random_floppy_rw_sound()\n            sleep(1)\n            if self.try_again_sub_function():\n                return True\n            '''self.in_proximity_to_monster = False\n            self.in_dungeon = False\n            self.in_town = False'''\n        else:\n            self.end_game_routine()  # game is completed\n            if self.try_again_sub_function():  # if player chooses to play again\n                return True\n            '''self.game_complete = False  # reset condition for replay\n            mountain_king_theme()\n            teletype(f\"Congratulations!\\nYou have defeated Wicked Queen Jannbrielle and restored peace to the realm.\\n\")\n            pause()\n\n            save_a_character = self.name + \".sav\"\n            p = Path(__file__).with_name(save_a_character)\n            same_line_print(f\"Saving {self.name}\")\n            random_floppy_rw_sound()\n            dot_dot_dot(15)\n\n            with p.open('wb') as character_filename:\n                pickle.dump(self, character_filename)\n                same_line_print(f\"{self.name} saved.\\n\")\n                sleep(2)\n\n            cls()\n            teletype_txt_file('credits.txt')\n            pause()\n            cls()\n            teletype_txt_file('credits2.txt')\n            pause()\n            cls()\n            teletype_txt_file('credits3.txt')\n            pause()\n            cls()\n            print(f\"\\n        Sauengard Copyright 2022, JULES PITSKER  (pitsker@proton.me)\\nAll rights reserved\\n\")\n            pause()\n        while True:\n            cls()\n            try_again = input(\"Do you wish to play again (y/n)? \").lower()\n            if try_again == \"y\":\n                sleep(1.5)\n                cls()\n                self.in_proximity_to_monster = False\n                self.in_dungeon = False\n                self.in_town = False\n                # player_is_dead = False\n                return True\n            if try_again == \"n\":\n                print(f\"Farewell.\")\n                sleep(1.5)\n                cls()\n                sys.exit()'''\n\n    def encounter_logic(self):\n        # called from main loop\n        if self.monsters_on:\n            self.encounter = dice_roll(1, 20)\n        else:\n            self.encounter = 15  # this will make it so there are no monsters at all except bosses (for testing, etc)\n\n    def the_monster_is_not_amused(self, monster):\n        # called from self.battle_menu_choices() for invalid inputs\n        print(f\"The {monster.name} is not amused.\")\n        sleep(.75)\n        self.hud()\n        return\n\n    def monster_introduction(self, monster):\n        # called from main loop\n        if monster.name in self.discovered_monsters:\n            self.hud()  # placing a hud() here erases the dungeon description; more appropriate\n            # print(f\"(TESTING) Discovered monsters: {self.discovered_monsters}\")  # remove after testing\n            print(f\"You have encountered {monster.a_an} {monster.name}. Challenge level: {monster.level}\")\n            # remove lvl after testing\n            pause()\n        else:\n            self.hud()  # placing a hud() here erases the dungeon description; more appropriate\n            print(f\"{monster.introduction}\")\n\n            if self.encounter < 21:  # if not a boss\n                self.discovered_monsters.append(monster.name)\n            pause()\n\n    def monster_likes_you_or_steals_from_you(self, monster):\n        # called from main loop\n        if self.encounter < 21:  # if not a boss, monster may like you or steal from you\n\n            if self.monster_likes_you(monster):\n                self.in_proximity_to_monster = False\n                # player_1.event_logic()  # this will trigger an event without using (L)ook\n                self.dungeon_description()\n                return True\n\n            if self.quick_move(monster):\n                self.in_proximity_to_monster = False\n                # player_1.event_logic()  # this will trigger an event without using (L)ook\n                self.dungeon_description()\n                return True  # if monster steals something he gets away clean, if not, battle\n\n            else:\n                return False\n\n        else:\n            return False\n\n    def battle_menu_choices(self, monster):\n        # main loop battle menu. note that a party of adventurers cannot evade\n        while True:\n            self.hud()\n            monster.monster_data()\n\n            if not self.sikira_ally and not self.torbron_ally and not self.magnus_ally and not self.vozzbozz_ally:\n                battle_choice = input(\"(F)ight, (H)ealing potion, (C)larifying elixir,\\n\"\n                                      \"(G)iant Strength potion, (V)ial of Antidote,\\n(Q)uantum Effects or \"\n                                      \"(E)vade\\nF/H/C/G/V/Q/E --> \").lower()\n\n                if battle_choice in ('f', 'h', 'c', 'g', 'v', 'q', 'e'):\n                    return battle_choice\n\n                else:  # invalid inputs\n                    self.the_monster_is_not_amused(monster)\n                    continue\n\n            else:  # a party of adventurers cannot evade\n                battle_choice = input(\"(F)ight, (H)ealing potion, (C)larifying elixir,\\n\"\n                                      \"(G)iant Strength potion, (V)ial of Antidote,\\nor (Q)uantum Effects\\n\"\n                                      \"F/H/C/G/V/Q --> \").lower()\n\n                if battle_choice in ('f', 'h', 'c', 'g', 'v', 'q'):\n                    return battle_choice\n\n                else:  # invalid inputs\n                    self.the_monster_is_not_amused(monster)\n                    continue\n\n    def check_for_boss(self, event):\n\n        if event == \"Elite Monster\":\n            self.encounter = 95\n        if event == \"Legendary Monster\":\n            self.encounter = 96\n        elif event == \"Undead Prophet\":\n            self.encounter = 97\n        elif event == \"King Boss\":\n            self.encounter = 98\n        elif event == \"Exit Boss\":\n            self.encounter = 99\n        elif event == \"Wicked Queen\":\n            self.encounter = 100\n        else:\n            return False\n\n    def victory_statements(self, monster):\n        statements_list = [f\"You are victorious!\", f\"You have defeated the {monster.name}.\", f\"You have vanquished\"\n                                                                                             f\" the {monster.name}.\",\n                           \"You have defeated your enemy.\", \"Your enemy is defeated.\"]\n        if self.encounter > 20:  # if victory over boss\n            gong()\n            if monster.proper_name != \"None\":\n                print(f\"You have vanquished {monster.proper_name}! You are victorious!\")\n                self.vanquished_foes.append(monster.proper_name)\n            else:\n                print(f\"You have vanquished the {monster.name}!\")\n            sleep(4)\n            self.dungeon_theme()\n        else:\n            statement = random.choice(statements_list)\n            print(statement)\n\n    def victory_over_boss_logic(self):\n        # called from main loop\n        if self.encounter == 99:  # if dungeon level exit boss\n            self.boss_hint_logic()\n\n    def random_death_statement(self):\n        # called from main loop\n        random_statements = [\"You have succumbed to your injuries!\",\n                             \"Bravely you have fought. Bravely you have died. Rest in Peace.\"\n                             ]\n        print(f\"{self.name} Level {self.level}\")\n        print(random.choice(random_statements))\n        return\n\n    def meta_monster_generator(self):\n        # called from main loop\n        monster = None\n\n        if self.encounter < 11:  # regular monster\n            monster = self.regular_monster_generator()\n            # put testing monster here:\n            # from monster_module import Doppelganger\n            # monster = Doppelganger()\n            return monster\n\n        elif self.encounter == 100:  # final boss\n            monster = self.wicked_queen_generator()\n\n        elif self.encounter == 99:  # level exit boss fight\n            monster = self.exit_boss_generator()\n\n        elif self.encounter == 98:  # undead king\n            monster = self.king_monster_generator()\n\n        elif self.encounter == 97:  # undead prophet\n            monster = self.undead_prophet_generator()\n\n        elif self.encounter == 96:  # legendary monster\n            monster = self.legendary_monster_generator()\n\n        elif self.encounter == 95:  # elite\n            monster = self.elite_monster_generator()\n\n        gong()\n        sleep(4)\n\n        if self.encounter == 98:\n            mountain_king_theme()\n\n        else:\n            boss_battle_theme()\n\n        pause()\n        self.hud()\n        return monster\n\n    def monster_booster(self, monster):\n        # called from monster_generators to boost hit points and experience rewards\n        # depending on the existence of NPC allies\n        if self.sikira_ally:\n            monster.hit_points += self.sikira.hit_points\n            monster.experience_award = round(monster.experience_award * 1.25)\n        if self.torbron_ally:\n            monster.hit_points += self.torbron.hit_points\n            monster.experience_award = round(monster.experience_award * 1.25)\n        if self.magnus_ally:\n            monster.hit_points += self.magnus.hit_points\n            monster.experience_award = round(monster.experience_award * 1.25)\n        if self.vozzbozz_ally:\n            monster.hit_points += self.vozzbozz.hit_points\n            monster.experience_award = round(monster.experience_award * 1.25)\n\n        if self. sikira_ally or self.torbron_ally or self.magnus_ally or self.vozzbozz_ally:\n            if monster.to_hit_bonus <= self.acumen:  # consider modifying for balance\n                monster.to_hit_bonus = self.acumen + 1\n\n            if monster.proper_name == \"None\":\n                monster.name = f\"{monster.name} Dreadnought\"\n            else:\n                monster.name = f\"{monster.name} Dreadnought\"\n                monster.proper_name = f\"{monster.proper_name} Dreadnought\"\n        return monster\n\n    def wicked_queen_generator(self):\n        # called from meta_monster_generator() if encounter == 100\n        wicked_queen = WickedQueenJannbrielle()  # monster_dict([4][0])()\n        self.hud()  # this clears the screen at a convenient point, so that the automatic description is removed\n        print(f\"The Queen rises from the grotesque throne, her eyes burning with murderous intent!\")\n        return wicked_queen\n\n    def legendary_monster_generator(self):\n        # called from meta_monster_generator() if encounter == 96\n        rndm_boss_names = ['Sarlen', 'Sinedor', 'Birlendor', 'Lichtor', 'Renburr',\n                           'Belorg', 'Sirlak', 'Gruldirren', 'Falldorren', 'Tilenbor', 'Durjinn',\n                           'Morgenoth', 'Tergoam', 'Terdannor', 'Lorenqor', 'Worgoth',\n                           'Hahrbinnor', 'Korrendor', 'Karbrath', 'Qintar', 'Wobard',\n                           'Sorrikon', 'Dellbrion', 'Selanius', 'Qorron', 'Sorrendir',\n                           'Mawleon', 'Sador', 'Qardormirr', 'Bendorn', 'Vallqedon',\n                           'Merlkandon']\n\n        # just in case I forget to make level 21 monsters.\n        if self.level < 20:\n            monster_key = (self.level + 1)\n        else:\n            monster_key = self.level\n        monster_cls = random.choice(monster_dict[monster_key])\n        boss_monster = monster_cls()\n        first_name = random.choice(rndm_boss_names)\n        boss_monster.proper_name = f\"{first_name} the Legendary {boss_monster.name}\"\n        boss_monster.hit_points = math.ceil(boss_monster.hit_points * 2)\n        boss_monster.experience_award = math.ceil(boss_monster.experience_award * 2)\n        boss_monster.strength += 4\n        boss_monster.dexterity += 4\n        boss_monster.constitution += 4\n        boss_monster.intelligence += 4\n        boss_monster.wisdom += 4\n        boss_monster.charisma += 4\n        boss_monster.armor_class += 2\n        boss_monster.resistances = [\"All\"]\n        boss_monster.weapon_bonus = math.ceil(self.acumen * 2.5)\n        self.hud()  # this clears the screen at a convenient point, so that the automatic description is removed\n        checked_monster = self.monster_booster(boss_monster)  # beta\n        print(f\"Before you stands {checked_monster.proper_name}!\")\n        return checked_monster  # beta\n        # return boss_monster\n\n    def elite_monster_generator(self):\n        # called from meta_monster_generator() if encounter == 95\n        rndm_boss_names = ['Sarlongrath', 'Sundor', 'Birrenol', 'Sontor', 'Marburr',\n                           'Belok', 'Sorlak', 'Grildorren', 'Falaur', 'Tildor', 'Durj',\n                           'Morgenor', 'Talgram', 'Teldanoth', 'Linmat', 'Worcon',\n                           'Hahrmon', 'Kardon', 'Corbrath', 'Willentor', 'Weggard',\n                           'Norrikon', 'Fellbrion', 'Sajanus', 'Qorrat', 'Sorenmir',\n                           'Kraw', 'Kullador', 'Qardrommir', 'Wiltendorn', 'Valwark',\n                           'Morluk']\n\n        # just in case I forget to make level 21 monsters.\n        if self.level < 20:\n            monster_key = (self.level + 1)\n        else:\n            monster_key = self.level\n        monster_cls = random.choice(monster_dict[monster_key])\n        boss_monster = monster_cls()\n        first_name = random.choice(rndm_boss_names)\n        boss_monster.proper_name = f\"{first_name} the Elite {boss_monster.name}\"\n        boss_monster.hit_points = math.ceil(boss_monster.hit_points * 2)\n        boss_monster.experience_award = math.ceil(boss_monster.experience_award * 1.5)\n        boss_monster.strength += 2\n        boss_monster.dexterity += 2\n        boss_monster.constitution += 2\n        boss_monster.intelligence += 2\n        boss_monster.wisdom += 2\n        boss_monster.charisma += 2\n        boss_monster.armor_class += 2\n        boss_monster.dot_multiplier = self.acumen\n        boss_monster.experience_award = 350 * self.level\n        boss_monster.weapon_bonus = math.ceil(self.level * 1.5)\n        self.hud()  # this clears the screen at a convenient point, so that the automatic description is removed\n        checked_monster = self.monster_booster(boss_monster)  # beta\n        print(f\"Before you stands {checked_monster.proper_name}!\")\n        return checked_monster  # beta\n        #  return boss_monster\n\n    def regular_monster_generator(self):\n        # called from meta_monster_generator() if encounter < 11\n        maximum_level = self.level  # (self.level + 1) makes it too hard\n        minimum_level = 1\n\n        if self.level > 2:\n            minimum_level = (self.level - 2)  # this should keep it more challenging and fun\n\n        regular_monster_key = random.randint(minimum_level, maximum_level)\n\n        if self.encounter == 1:  # beta 5% chance of running into monsters that are +1 level to keep it challenging\n\n            if self.level < 20:\n                regular_monster_key = (self.level + 1)\n\n            else:\n                regular_monster_key = self.level\n\n        regular_monster_cls = random.choice(monster_dict[regular_monster_key])\n        regular_monster = regular_monster_cls()\n        checked_monster = self.monster_booster(regular_monster)\n        return checked_monster\n\n    def undead_prophet_generator(self):\n        # called from meta_monster_generator(), if encounter == 97\n        rndm_prophet_names = ['Tacium', 'Amarrik', 'Arynd', 'Beldonnor', 'Forrg',\n                              'Sambressorr', 'Jornav', 'Tyrnenn', 'Fenlor', 'Yagoddish', 'Borell',\n                              'Ehrnador', 'Thaymorro', 'Gorrel', 'Aureor', 'Linus', 'Mattheus',\n                              'Hahrus', 'Astorem', 'Chardast', 'Brendorin', 'Meradorn',\n                              'Gorrikor', 'Nannukis', 'Torrolom', 'Ornelius', 'Geffenmor',\n                              'Jorrbrialus', 'Koffengen', 'Jyrus', 'Jybrius', 'Tyrrendor',\n                              'Forendilus']\n        rndm_epithets = ['of the Evil Wisdom', 'the Lesser', 'the Elder', 'the Fierce', 'of the Eleven Elders',\n                         'of the Twelve', 'of the Fell Elders', 'the Mad', 'the Blasphemous',\n                         'of the Eleven Elders', 'the Fallen', 'the Insane', 'the Mad Magistrate',\n                         'the Grand King-Priest', 'of the Seven Minds', 'the Bloodsoaked',\n                         'the Accursed', 'the Abandoned', 'the Absolutionist', 'the Avenger', 'of the Seven Horns',\n                         'the Blackhearted', 'the Blind', 'the Bloodthirsty', 'the Cruel',\n                         'the Damned', 'the Foul', 'the Foulest', 'the Feared', 'the Fear-Inspiring'\n                         ]\n\n        undead_prophet = random.choice(undead_prophet_list)\n        name = random.choice(rndm_prophet_names)\n        epithet = random.choice(rndm_epithets)\n        undead_prophet.proper_name = f\"{name} {epithet}\"\n        undead_prophet.hit_points = math.ceil(self.maximum_hit_points * 1.5)\n        undead_prophet.level = self.level\n        undead_prophet.number_of_hd = self.level\n        undead_prophet.weapon_bonus = self.wielded_weapon.damage_bonus\n        undead_prophet.dot_multiplier = self.acumen\n        undead_prophet.experience_award = 350 * self.level\n        self.hud()  # this clears the screen at a convenient point, so that the automatic description is removed\n        checked_monster = self.monster_booster(undead_prophet)  # beta\n        print(f\"The undead prophet, {checked_monster.proper_name} returns!\")\n        return checked_monster  # beta\n        #  return undead_prophet\n\n    def exit_boss_generator(self):\n        # called from meta_monster_generator(), if encounter == 99\n        rndm_boss_names = ['Gwarlek', 'Srentor', 'Borrnol', 'Sentollor', 'Morluk',\n                           'Twinbelor', 'Sornog', 'Grenyor', 'Fallraur', 'Timboth', 'Surj',\n                           'Morozzor', 'Tharbor', 'Tenbrok', 'Lorrius', 'Filwor',\n                           'Hahrmon', 'Kardon', 'Corbrin', 'Billentor', 'Weggard',\n                           'Norrus', 'Fellbrion', 'Sajanus', 'Qorag', 'Sorenmor',\n                           'Kraw', 'Kullador', 'Qendor', 'Willenbor', 'Valwar',\n                           'Moonror']\n\n        # just in case I forget to make level 21 monsters.\n        if self.level < 20:\n            monster_key = (self.level + 1)\n        else:\n            monster_key = self.level\n        monster_cls = random.choice(monster_dict[monster_key])\n        exit_boss = monster_cls()\n        exit_boss.hit_points = math.ceil(exit_boss.hit_points * 1.25)\n        first_name = random.choice(rndm_boss_names)\n        exit_boss.proper_name = f\"{first_name} the Elite {exit_boss.name} guardian\"\n        # exit_boss.hit_points = math.ceil(self.maximum_hit_points * 1.5)\n        exit_boss.level = self.level\n        exit_boss.number_of_hd = self.level\n        exit_boss.dot_multiplier = self.dungeon.level\n        exit_boss.experience_award = 450 * self.level\n        exit_boss.weapon_bonus = self.wielded_weapon.damage_bonus\n        checked_monster = self.monster_booster(exit_boss)\n        self.hud()  # this clears the screen at a convenient point, so that the automatic description is removed\n        print(f\"In the archway to the staircase leading down to {self.dungeon.name} \"\n              f\"stands {checked_monster.proper_name}!\\n\"\n              f\"Without fear, without thought, the guardian looks upon you and readies itself for battle...\")\n\n        return checked_monster\n        #  return exit_boss\n\n    def king_monster_generator(self):\n        # called from meta_monster_generator(), if encounter == 98\n        rndm_king_names = ['Tartyrtum', 'Amarrok', 'Aaryn', 'Baldrick', 'Farrendal',\n                           'Dinenlell', 'Jorn', 'Tyrne', 'Fen', 'Jagod', 'Bevel',\n                           'Elrik', 'Thayadore', 'Grummthel', 'Aureus', 'Sylgor',\n                           'Hahr', 'Astor', 'Cordast', 'Breckenborn', 'Megarrd',\n                           'Gorrik', 'Nannuk', 'Borrodred', 'Metalbeard', 'Geffen',\n                           'Jortindale', 'Koffgen', 'Tyrus', 'Tybrius', 'Tyr',\n                           'Hammersthorn']\n        rndm_epithets = ['the Wise', 'the Lesser', 'the Elder', 'the Fierce', 'of the Eleven', 'of the Twelve',\n                         'of the Elders', 'the Brave', 'the Insane', 'the Great', 'the Grand Magistrate',\n                         'the Grand King-Priest', 'of the Seven Riddles', 'the Strong', 'the Able', 'the Bloodsoaked',\n                         'the Accursed', 'the Abandoned', 'the Absolutist', 'the Avenger', 'the Battle-weary',\n                         'the Blackhearted', 'the Blind', 'the Bloodthirsty', 'the Conqueror', 'the Cruel',\n                         'the Crusader', 'the Damned'\n                         ]\n\n        king_monster = random.choice(king_boss_list)\n        name = random.choice(rndm_king_names)\n        epithet = random.choice(rndm_epithets)\n        king_monster.proper_name = f\"{name} {epithet}\"\n        king_monster.hit_points = math.ceil(self.maximum_hit_points * 1.25)\n        king_monster.level = self.level\n        king_monster.number_of_hd = self.level\n        king_monster.weapon_bonus = self.wielded_weapon.damage_bonus\n        king_monster.dot_multiplier = self.dungeon.level\n        king_monster.experience_award = 350 * self.level\n        self.hud()  # this clears the screen at a convenient point, so that the automatic description is removed\n        checked_monster = self.monster_booster(king_monster)  # beta\n        print(f\"The undead King {checked_monster.proper_name} returns!\")\n        return checked_monster  # beta\n        #  return king_monster\n\n    def monster_likes_you(self, monster):\n        # called from main loop after encounter with regular monster\n        if dice_roll(1, 20) > 19 and monster.intelligence > 12 and monster.charisma > 14 and self.charisma > 11:\n            print(f\"The {monster.name} likes you!\")\n            sleep(1)\n            upgradeable = True\n\n            while upgradeable:\n\n                if self.armor.ac < 18 or self.shield.ac < 3 or self.wielded_weapon.damage_bonus < 15 or \\\n                        self.wielded_weapon.to_hit_bonus < 6 or self.boots.ac < 3 \\\n                        or self.hit_points < self.maximum_hit_points:\n                    upgradeable = True\n\n                else:\n                    upgradeable = False\n\n                if not upgradeable:\n                    gold_gift = random.randint(100, 5000)\n                    print(f\"{monster.he_she_it.capitalize()} gives you {gold_gift} GP!\")\n                    self.gold += gold_gift\n                    pause()\n                    return True\n\n                gift_item = dice_roll(1, 6)\n\n                if gift_item == 1:\n                    if (self.armor.ac + self.armor.armor_bonus) < 18:\n                        if self.armor.name != \"Padded Armor\":\n                            self.armor.armor_bonus += 1\n                            self.calculate_armor_class()\n                            print(f\"{monster.he_she_it.capitalize()} enhances your {self.armor.name} \"\n                                  f\"with an Armor Bonus +{self.armor.armor_bonus}!\")\n                        else:\n                            self.armor = LeatherArmor()\n                            print(f\"{monster.he_she_it.capitalize()} gives you {self.armor.name}!\")\n                            self.calculate_armor_class()\n                        pause()\n                        return True\n                    else:\n                        continue\n\n                if gift_item == 2:\n                    if self.shield.ac < 3:\n                        if self.shield.name != \"No Shield\":\n                            self.shield.ac += 1\n                            self.calculate_armor_class()\n                            print(f\"{monster.he_she_it.capitalize()} enhances your {self.shield.name} \"\n                                  f\"to AC {self.shield.ac}!\")\n                        else:\n                            self.shield = Buckler()\n                            print(f\"{monster.he_she_it.capitalize()} gives you a {self.shield.name}!\")\n                            self.calculate_armor_class()\n                        pause()\n                        return True\n                    else:\n                        continue\n\n                if gift_item == 3:\n\n                    if self.wielded_weapon.damage_bonus < 15:\n\n                        if self.wielded_weapon.name != \"Short Sword\":\n                            self.wielded_weapon.damage_bonus += 1\n                            print(f\"{monster.he_she_it.capitalize()} enhances your {self.wielded_weapon.name} \"\n                                  f\"damage bonus to + \"\n                                  f\"{self.wielded_weapon.damage_bonus}!\")\n                            pause()\n                            return True\n\n                        else:\n                            self.wielded_weapon = BroadSword()\n                            print(f\"{monster.he_she_it.capitalize()} gives you a {self.wielded_weapon.name}!\")\n                            pause()\n                            return True\n                    else:\n                        continue\n\n                if gift_item == 4:\n                    if self.wielded_weapon.to_hit_bonus < 6:\n                        if self.wielded_weapon.name != \"Short Sword\":\n                            self.wielded_weapon.to_hit_bonus += 1\n                            print(f\"{monster.he_she_it.capitalize()} enhances your {self.wielded_weapon.name} \"\n                                  f\"to-hit bonus to + \"\n                                  f\"{self.wielded_weapon.to_hit_bonus}!\")\n                            pause()\n                            return True\n\n                        else:\n                            self.wielded_weapon = BroadSword()\n                            print(f\"{monster.he_she_it.capitalize()} gives you a {self.wielded_weapon.name}!\")\n                            pause()\n                            return True\n                    else:\n                        continue\n\n                if gift_item == 5:\n                    if self.boots.ac < 3:\n\n                        if self.boots.name != \"Leather Boots\":\n                            self.boots.ac += 1\n                            self.calculate_armor_class()\n                            print(f\"{monster.he_she_it.capitalize()} enhances your {self.boots.name} \"\n                                  f\"to AC {self.boots.ac}!\")\n                        else:\n                            self.boots = ElvenBoots()\n                            print(f\"{monster.he_she_it.capitalize()} gives you a pair of {self.boots.name}!\")\n                            self.calculate_armor_class()\n                        pause()\n                        return True\n                    else:\n                        continue\n\n                if gift_item == 6:\n                    if self.hit_points < self.maximum_hit_points:\n                        self.hit_points = self.maximum_hit_points\n                        print(f\"{monster.he_she_it.capitalize()} heals you to full strength!\")\n                        pause()\n                        return True\n                    else:\n                        continue\n\n        else:\n            return False\n\n    def quick_move(self, monster):\n        # called from main loop\n        self.hud()\n        quick_move_roll = dice_roll(1, 20)  # - self.stealth\n        if quick_move_roll == 20:\n            print(f\"The {monster.name} makes a quick move...\")\n            sleep(1.5)\n            # pack inventory logic:\n            pack_item_types_to_steal = []\n            belt_item_types_to_steal = [self.potions_of_strength, self.potions_of_healing,\n                                        self.town_portals, self.elixirs, self.antidotes]\n            for i in self.pack.keys():  # gather all available\n                if len(self.pack[i]) > 0:  # item types to steal based on player's current item TYPES and put them\n                    pack_item_types_to_steal.append(i)  # in available_item_types_to_steal = []\n\n            if len(pack_item_types_to_steal) > 0:\n                item_type = random.choice(pack_item_types_to_steal)  # Get random item *TYPE* you want to \"steal\"\n                if len(self.pack[item_type]) > 0:  # If the player has an item of type \"item_type\" in their pack\n                    # pop random item from that item type. -1 because indexes start at 0\n                    stolen_item = (self.pack[item_type].pop(random.randint(0, len(self.pack[item_type]) - 1)))\n                    print(f\"{monster.he_she_it.capitalize()} steals the {stolen_item.name} \"\n                          f\"from your pack!\")\n                    pause()\n                    return True  # True means monster gets away clean\n\n            # if pack is empty, the thief moves to the belt.\n            # Belt inventory is handled differently.\n            # belt inventory logic:\n            elif sum(belt_item_types_to_steal) > 0:\n                item_string = \"\"\n                # Define list of attributes you are allowed to change\n                self_dict = self.__dict__  # create self_dict variable as actual copy of player dict attribute\n                stealing_lst = []\n                # the working dict and 'for' loop just takes the place of many 'if:' statements\n                working_dict = {'potions_of_strength': self.potions_of_strength,\n                                'potions_of_healing': self.potions_of_healing,\n                                'town_portals': self.town_portals, 'elixirs': self.elixirs,\n                                'antidotes': self.antidotes}\n                # add all items > 0 in working dict to stealing list\n                for key, value in working_dict.items():\n                    if value > 0:\n                        stealing_lst.append(key)\n                random_stolen_item = random.choice(stealing_lst)\n                # I am proud of this next bit of code :)\n                grammar_dict = {'potions_of_strength': 'potion of strength',\n                                'potions_of_healing': 'potion of healing',\n                                'town_portals': 'scroll of town portal', 'elixirs': 'clarifying elixir',\n                                'antidotes': 'vial of antidote'}\n                for key, value in grammar_dict.items():\n                    if random_stolen_item == key:\n                        item_string = value\n                print(f\"{monster.he_she_it.capitalize()} steals a {item_string} right off of your belt!\")\n                self_dict[random_stolen_item] -= 1\n                pause()\n                return True  # True means monster gets away clean\n            else:\n                print(f\"You have nothing {monster.he_she_it} wants to steal!\")\n                pause()\n                # sleep(2)\n                return True  # Changing this to False means your inventory is empty and monster sticks around to fight\n        else:\n            return False  # False here means monster failed check, and he sticks around to fight; invisible to player\n\n    def reduce_health(self, damage):\n        # called from main loop after monster does damage to human player\n        self.hit_points -= damage\n        # if self.hit_points < 0:  # restore after testing\n        #    self.hit_points = 0  # restore after testing\n        return\n\n    def check_dead(self):\n        # called from main loop after damage and calculations\n        # I am proud of this code...it was very difficult for me and took many hours\n        if self.hit_points > 0:\n            return False\n        else:\n            self.hud()\n            if self.necrotic and self.poisoned:\n                print(f\"You are necrotic, poisoned, unconscious and moribund!\")\n            elif self.necrotic:\n                print(f\"You are necrotic, unconscious and moribund!\")\n            elif self.poisoned:\n                print(f\"You are poisoned, unconscious and moribund!\")\n            else:\n                print(f\"You are unconscious and moribund!\")\n            sleep(1)\n            print(f\"Death resistance throw!\")\n            sleep(1)\n            successes = 0\n            fails = 0\n            attempt = 0\n            while successes < 3 or fails < 3:\n                if successes == 3:\n                    print(f\"You are revived!\")\n                    sleep(1)\n                    self.hit_points = 1\n                    return False  # player is NOT dead\n                if fails >= 3:\n                    print(f\"Death resistence has failed!\")\n                    sleep(1)\n                    return True  # player IS dead\n                death_save = dice_roll(1, 20)\n                attempt += 1\n                print(f\"Attempt {attempt}: {death_save}\")\n                sleep(1)\n                if death_save == 20:\n                    print(f\"20 Roll! You are revived!\")\n                    sleep(1)\n                    self.hit_points = 1\n                    return False  # player is NOT dead\n                if death_save > 9:\n                    successes += 1\n                    if successes == 1:\n                        print(f\"{successes} Successful save..\")\n                    else:\n                        print(f\"{successes} Successful saves..\")\n                    sleep(1)\n                if 10 > death_save > 1:\n                    fails += 1\n                    if fails == 1:\n                        print(f\"{fails} Failed save..\")\n                    else:\n                        print(f\"{fails} Failed saves..\")\n                    sleep(1)\n                if death_save == 1:\n                    fails += 2\n                    print(f\"Rolling a 1 adds 2 failed saves. \")\n                    print(f\"{fails} Failed saves..\")\n                    sleep(1)\n            return True  # player IS dead\n\n    def initiative(self, monster):\n        # called from main loop after encountering monster.\n        self.hud()\n        if self.level > 6:\n            player_initiative = dice_roll(1, 20) + self.dexterity_modifier + self.acumen\n        else:\n            player_initiative = dice_roll(1, 20) + self.dexterity_modifier\n        if monster.level > 6:  # beta testing\n            monster_initiative = dice_roll(1, 20) + monster.dexterity_modifier + monster.evil_bonus\n        else:\n            monster_initiative = dice_roll(1, 20) + monster.dexterity_modifier\n        print(f\"Your initiative: {player_initiative}\\n{monster.name} initiative: {monster_initiative}\")\n        pause()  # remove after testing\n        if player_initiative >= monster_initiative:\n            return True\n        else:\n            return False\n\n    def melee(self, monster):\n        # called from main loop if player chooses to (F)ight\n        one_roll = [\"You awkwardly strike, and lose your footing..\",\n                    \"Off balance and late, you manage a pitiful attempt and fail.\",\n                    \"Your aim is poor; you miserably fail to land a blow..\",\n                    \"Distracted and unfocused, you lose your concentration and miss..\"]\n        miss_list = [f\"Your {self.wielded_weapon.name} bounces off {monster.his_her_its} {monster.armor_name}!\",\n                     f\"{monster.he_she_it.capitalize()} nimbly moves aside!\",\n                     f\"{monster.he_she_it.capitalize()} deflects your blow!\",\n                     f\"{monster.he_she_it.capitalize()} dodges your blow!\",\n                     f\"{monster.his_her_its.capitalize()} {monster.armor_name} absorbs the damage!\"]\n        hit_list = [\"You land a stabbing blow!\", \"You successfully land a cutting blow!\",\n                    f\"You manage to wound {monster.him_her_it}!\", f\"You wound {monster.him_her_it}!\",\n                    f\"You slash {monster.him_her_it}!\", f\"You land a blow and wound {monster.him_her_it}!\",\n                    f\"Your {self.wielded_weapon.name} lands and wounds {monster.him_her_it}!\"]\n        strength_bonus = 1\n        if self.potion_of_strength_effect:\n            strength_bonus = 1.33\n        if self.quantum_strength_effect:\n            strength_bonus = 2\n        self.hud()\n        roll_d20 = dice_roll(1, 20)  # attack roll\n        print(f\"You strike at the {monster.name}..\")\n        print(f\"Melee Attack Roll: {roll_d20}\")\n        sleep(1)\n        if roll_d20 == 1:\n            print(random.choice(one_roll))\n            sleep(1)\n            pause()\n            self.hud()\n            return 0\n        if roll_d20 == 20 or \\\n                (roll_d20 + self.acumen + self.dexterity_modifier + self.wielded_weapon.to_hit_bonus) \\\n                - monster.armor_class >= 10:\n            critical_bonus = 2\n            hit_statement = \"CRITICAL HIT!!\"\n\n        else:\n            critical_bonus = 1\n            hit_statement = random.choice(hit_list)\n        print(f\"Dexterity modifier: {self.dexterity_modifier}\\nAcumen: {self.acumen}\")\n        if self.wielded_weapon.to_hit_bonus > 0:\n            print(f\"Weapon to-hit bonus: {self.wielded_weapon.to_hit_bonus}\")\n        roll_total = roll_d20 + self.acumen + self.dexterity_modifier + self.wielded_weapon.to_hit_bonus\n        print(f\"Your Total Attack Roll: {roll_total}\")\n        print(f\"Monster armor class {monster.armor_class}\")\n        if roll_d20 == 20 or roll_d20 + self.acumen + \\\n                self.dexterity_modifier + self.wielded_weapon.to_hit_bonus >= monster.armor_class:\n            damage_roll = dice_roll((self.level * critical_bonus), self.hit_dice)\n            damage_to_opponent = math.ceil(\n                (damage_roll + self.strength_modifier + self.wielded_weapon.damage_bonus) * strength_bonus)\n            if damage_to_opponent > 0:\n                print(hit_statement)\n                sleep(1)\n                print(f\"{self.level * critical_bonus}d{self.hit_dice} Damage Roll: {damage_roll}\\n\"\n                      f\"Strength modifier: {self.strength_modifier}\")\n                if self.wielded_weapon.damage_bonus > 0:\n                    print(f\"Weapon bonus: {self.wielded_weapon.damage_bonus}\")\n                if strength_bonus > 1:\n                    print(f\"x Strength Bonus Multiplier: {strength_bonus}\")\n                print(f\"Your Damage Total: {damage_to_opponent}\")\n                print(f\"You inflict {damage_to_opponent} points of damage!\")\n                pause()\n                self.hud()\n                return damage_to_opponent\n            else:\n                print(f\"Your attack is barely effective. You manage 1 point of damage.\")  # zero damage result\n                sleep(1)\n                return 1\n        elif self.extra_attack:  # self.level > 4\n            print(random.choice(miss_list))\n            # print(\"You missed..\")\n            sleep(1)\n            print(\"Extra chance to hit!\")\n            sleep(1)\n            roll_d20 = dice_roll(1, 20)\n            if roll_d20 == 20 or roll_d20 + self.acumen + self.dexterity_modifier + \\\n                    self.wielded_weapon.to_hit_bonus >= monster.armor_class:\n                damage_roll = dice_roll(self.level, self.hit_dice)\n                damage_to_opponent = \\\n                    math.ceil((damage_roll + self.strength_modifier + self.wielded_weapon.damage_bonus)\n                              * strength_bonus)\n                print(random.choice(hit_list))\n                print(f\"You inflict {damage_to_opponent} points of damage!\")\n                pause()\n                self.hud()\n                return damage_to_opponent\n            else:\n                print(random.choice(miss_list))\n                # print(\"You miss again..\")\n                pause()\n                self.hud()\n                return 0\n        else:\n            print(random.choice(miss_list))\n            # print(f\"You missed...\")\n            pause()\n            self.hud()\n            return 0\n\n    def npc_melee(self, ally, monster_name, monster_armor_class):\n        # called from npc_attack_logic() for npcs who use melee\n        pronoun = 'his'\n        if ally.name == \"Si'Kira\":\n            pronoun = 'her'\n        self.hud()\n        roll_d20 = dice_roll(1, 20)  # attack roll\n        print(f\"{ally.name} strikes at the {monster_name} with {pronoun} {ally.wielded_weapon.name}..\")\n        print(f\"Attack Roll: {roll_d20}\")\n        sleep(1)\n        if roll_d20 == 1:\n            print(f\"{ally.name} misses..\")\n            pause()\n            self.hud()\n            return 0\n        if roll_d20 == 20 or (roll_d20 + self.acumen + self.dexterity_modifier + self.wielded_weapon.to_hit_bonus) \\\n                - monster_armor_class >= 10:\n            critical_bonus = 2\n            hit_statement = \"CRITICAL HIT!!\"\n        else:\n            critical_bonus = 1\n            hit_statement = f\"{ally.name} HITS!\"\n        print(f\"Dexterity modifier: {ally.dexterity_modifier}\\nAcumen: {ally.acumen}\")\n        if ally.wielded_weapon.to_hit_bonus > 0:\n            print(f\"Weapon to-hit bonus {ally.wielded_weapon.to_hit_bonus}\")\n        roll_total = roll_d20 + ally.acumen + ally.dexterity_modifier + ally.wielded_weapon.to_hit_bonus\n        print(f\"{ally.name} Total Attack Roll: {roll_total}\")\n        print(f\"Monster armor class {monster_armor_class}\")\n        if roll_d20 == 20 or roll_d20 + ally.acumen + \\\n                ally.dexterity_modifier + ally.wielded_weapon.to_hit_bonus >= monster_armor_class:\n            damage_roll = dice_roll((ally.level * critical_bonus), ally.hit_dice)\n            damage_to_opponent = math.ceil((damage_roll + ally.strength_modifier + ally.wielded_weapon.damage_bonus)\n                                           * ally.strength_bonus)\n            if damage_to_opponent > 0:\n                print(hit_statement)\n                sleep(1)\n                print(f\"{ally.level * critical_bonus}d{ally.hit_dice} Damage Roll: {damage_roll}\\n\"\n                      f\"Strength modifier: {ally.strength_modifier}\")\n                if ally.wielded_weapon.damage_bonus > 0:\n                    print(f\"Weapon bonus: {ally.wielded_weapon.damage_bonus}\")\n                if ally.strength_bonus > 1:\n                    print(f\"x Strength Bonus Multiplier: {ally.strength_bonus}\")\n                print(f\"{ally.name} Total Damage: {damage_to_opponent}\")\n                print(f\"{ally.name} does {damage_to_opponent} points of damage!\")\n                pause()\n                self.hud()\n                return damage_to_opponent\n            else:\n                print(f\"{ally.name}'s attack is barely effective. It does 1 point of damage.\")  # zero damage result\n                sleep(1)\n                return 1\n        elif ally.level > 4:\n            print(f\"{ally.name} missed..\")\n            sleep(2)\n            print(\"Extra Attack Skill chance to hit!\")\n            sleep(2)\n            roll_d20 = dice_roll(1, 20)\n            if roll_d20 == 20 or roll_d20 + ally.acumen + ally.dexterity_modifier + \\\n                    ally.wielded_weapon.to_hit_bonus >= monster_armor_class:\n                damage_roll = dice_roll(ally.level, ally.hit_dice)\n                damage_to_opponent = \\\n                    math.ceil((damage_roll + ally.strength_modifier + ally.wielded_weapon.damage_bonus)\n                              * ally.strength_bonus)\n                print(f\"{ally.name} attacks again for {damage_to_opponent} points of damage!\")\n                pause()\n                self.hud()\n                return damage_to_opponent\n            else:\n                print(f\"{ally.name} misses again.\")\n                pause()\n                self.hud()\n                return 0\n        else:\n            print(f\"{ally.name} missed...\")\n            pause()\n            self.hud()\n            return 0\n\n    def turn_undead(self, monster):\n        # monster must make wisdom protection roll or be turned away\n        quantum_unit_cost = 1\n        if self.in_proximity_to_monster:\n            print(f\"Turn Undead\")\n            sleep(1)\n            self.hud()\n            if \"Turn Undead\" not in monster.immunities and \"All\" not in monster.immunities and monster.undead:\n                vulnerability_modifier = 0\n                if \"Turn Undead\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Turn Undead\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + \\\n                    self.wisdom_modifier + vulnerability_modifier + level_advantage\n                print(f\"Player Base DC = {self.base_dc}\\n\"\n                      f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                # monster_mod = math.floor((monster.wisdom - 10) / 2)\n                print(f\"{monster.name} Wisdom Modifier: {monster.wisdom_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                monster_total = monster_roll + monster.wisdom_modifier + resistance_modifier\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc > monster_total:  # with >= tie goes to player... with > tie goes to monster\n                    self.quantum_units -= quantum_unit_cost\n                    self.in_proximity_to_monster = False\n                    # print(f\"The {monster.name} runs in fear!!\")\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} runs in fear!!\")\n                    else:\n                        print(f\"The {monster.name} runs in fear!!\")\n                    sleep(1.5)\n                    monster.gold = 0\n                    # pause()\n                    return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost\n                    print(f\"The {monster.name} listens with deaf ears..\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if monster.undead:\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is immune to Turn Undead!!\")\n                        sleep(1)\n                    else:\n                        print(f\"The {monster.name} is immune to Turn Undead!!\")\n                        sleep(1)\n                else:\n                    print(f\"Turn Undead is only effective against undead creatures!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Turn Undead is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def banish(self, monster):\n        # monster must make a successful charisma protection roll or be banished from existence on this plane\n        quantum_unit_cost = 4\n        if self.in_proximity_to_monster:\n            print(f\"Banish\")\n            sleep(1)\n            self.hud()\n            if \"Banish\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerability_modifier = 0\n                if \"Banish\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Banish\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC = {self.base_dc}\\n\"\n                      f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                monster_charisma_modifier = math.floor((monster.charisma - 10) / 2)\n                print(f\"{monster.name} Charisma Modifier: {monster_charisma_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                monster_total = monster_roll + monster_charisma_modifier + resistance_modifier\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc >= monster_total:\n                    self.hud()\n                    self.quantum_units -= quantum_unit_cost\n                    self.in_proximity_to_monster = False\n                    print(f\"BE GONE!!\")\n                    sleep(1)\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} phases out of existence on this plane!!\")\n                    else:\n                        print(f\"The {monster.name} phases out of existence on this plane!!!!\")\n                    sleep(1)\n                    print(f\"You perceive a slight breeze as the air \"\n                          f\"around you collapses into the brief void left behind..\")\n                    sleep(2)\n                    monster.gold = 0\n                    # pause()\n                    return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is unfazed by your attempts!!\")\n                    else:\n                        print(f\"The {monster.name} is unfazed by your attempts!\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Banish!!\")\n                else:\n                    print(f\"The {monster.name} is immune to Banish!!\")\n                sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Banish is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def fear(self, monster):\n        # player wisdom vs monster wisdom. only works on living\n        quantum_unit_cost = 4\n        if self.in_proximity_to_monster:\n            print(f\"Fear.\")\n            sleep(1)\n            self.hud()\n            if \"Fear\" not in monster.immunities and \"All\" not in monster.immunities and not monster.undead:\n                vulnerability_modifier = 0\n                if \"Fear\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Fear\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC = {self.base_dc}\\n\"\n                      f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                # monster_mod = math.floor((monster.wisdom - 10) / 2)\n                print(f\"{monster.name} Wisdom Modifier: {monster.wisdom_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                monster_total = monster_roll + monster.wisdom_modifier + resistance_modifier\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc >= monster_total:  # with >= tie goes to player... with > tie goes to monster\n                    self.quantum_units -= quantum_unit_cost\n                    self.in_proximity_to_monster = False\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} runs in fear!!\")\n                    else:\n                        print(f\"The {monster.name} runs in fear!!\")\n                    sleep(1.5)\n                    monster.gold = 0\n                    # pause()\n                    return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost\n                    print(f\"The {monster.name} ignores your wiles!!\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if not monster.undead:\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is immune to Fear!!\")\n                        sleep(1)\n                    else:\n                        print(f\"The {monster.name} is immune to Fear!!\")\n                        sleep(1)\n                else:\n                    print(f\"Fear is only effective against the living!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Turn Undead is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def quantum_purify(self, monster):\n        # cures poisoned and necrotic condition\n        # works only when poisoned or necrotic, but once engaged, also has powerful hit point healing!\n        if monster is None:\n            print(f\"Purify\")\n        else:\n            print(f\"Purify (BATTLE)\")\n        sleep(1)\n        quantum_unit_cost = 2\n        self.hud()\n        if not self.poisoned and not self.necrotic:\n            print(f\"Your flesh is not corrupted!\")\n            sleep(1)\n            return 0\n        else:\n            print(f\"You quiet your mind and grasp at the elusive Quantum Knowledge...\")\n            sleep(1)\n            self.quantum_units -= quantum_unit_cost\n            self.hud()\n            print(f\"You feel a cleansing of the flesh..\")\n            sleep(1)\n            self.poisoned = False\n            self.poisoned_turns = 0\n            self.necrotic = False\n            self.necrotic_turns = 0\n            print(f\"The foul corruption leaves your body..\")\n            sleep(1)\n            if self.hit_points < self.maximum_hit_points:\n                # number_of_dice = (3 + self.level)  # consider changing to self.quantum_level\n                # heal = dice_roll(number_of_dice, 4) + number_of_dice + self.quantum_level\n                if self.quantum_level < 3:\n                    heal = math.ceil(self.maximum_hit_points * .66)\n                else:\n                    heal = math.ceil(self.maximum_hit_points * .75)\n                print(f\"You heal {heal} hit points\")  # remove after testing\n                self.hit_points += heal\n                if self.hit_points > self.maximum_hit_points:\n                    self.hit_points = self.maximum_hit_points\n                # self.hud()\n                print(f\"Your wounds feel better!\")\n                sleep(1)\n            pause()\n            return 0\n\n    def quantum_petrifaction(self, monster):\n        # like sleep and charm, but always successful.\n        # player has 1 free crit, thereafter monster must pass Constitution protection roll\n        # 2 failed rolls after initial attack = permanent petrifaction for monster.\n        # player gets exp reward, but no gold or loot\n        quantum_unit_cost = 4\n        vulnerability_modifier = 0\n        if self.in_proximity_to_monster:\n            print(f\"Quantum Petrifaction\")\n            sleep(1)\n            self.hud()\n            if \"Petrifaction\" not in monster.immunities and \"All\" not in monster.immunities:\n                self.quantum_units -= quantum_unit_cost\n                if \"Petrifaction\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Petrifaction\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                print(f\"Before {monster.he_she_it} even realizes what is happening, {monster.his_her_its} \"\n                      f\"flesh ripples into a stone replica of {monster.his_her_its} normal state!\")\n                sleep(1)\n                input(f\"Press (ENTER) to attack: \")\n                self.hud()\n                print(f\"You raise your {self.wielded_weapon.name} and swing mightily..\")\n                sleep(1.5)\n                damage_modifier = 2\n                if \"Quantum Petrifaction\" in monster.vulnerabilities:\n                    damage_modifier = 3\n                # if \"Quantum Petrifaction\" in monster.resistances or \"All\" in monster.resistances:\n                #    damage_modifier = 1\n                total_fails = 0\n                while True:\n                    self.hud()\n                    damage_to_monster = dice_roll((self.level * damage_modifier), self.hit_dice)\n                    total_fails += 1\n                    print(f\"You inflict {damage_to_monster} hit points!\")\n                    pause()\n                    self.hud()\n                    monster.reduce_health(damage_to_monster)\n                    if not monster.check_dead():\n                        level_advantage = 0\n                        if self.level > monster.level:\n                            level_advantage = self.level - monster.level\n                        player_dc = self.base_dc + self.acumen + \\\n                            self.wisdom_modifier + vulnerability_modifier + level_advantage\n                        print(f\"Player base DC = {self.base_dc}\\n\"\n                              f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                              f\"Acumen: {self.acumen}\")\n                        if vulnerability_modifier != 0:\n                            print(f\"+ Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                        if level_advantage > 0:\n                            print(f\"+ Level Advantage: {level_advantage}\")\n                        sleep(1)\n                        print(f\"DC Total: {player_dc}\")\n                        sleep(1)\n                        monster_saving_throw = dice_roll(1, 20)\n                        monster_total = monster_saving_throw + monster.constitution_modifier + resistance_modifier\n                        print(f\"Monster Protection Roll: {monster_saving_throw}\")\n                        sleep(1)\n                        print(f\"Monster Constitution Modifier: {monster.constitution_modifier}\")\n                        if resistance_modifier != 0:\n                            print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                        sleep(1)\n                        print(f\"Total: {monster_total}\")\n                        sleep(1)\n\n                        if monster_total >= player_dc:  # dnd\n                            print(f\"The {monster.name} is restored!\")\n                            pause()\n                            return 0  # no damage sent back because already sent to monster.reduce_health()\n                        else:\n                            if total_fails == 3:\n                                print(f\"The {monster.name} forever succumbs to the petrification of stone!\")\n                                sleep(1)\n                                print(f\"You are victorious!\")\n                                sleep(1)\n                                self.in_proximity_to_monster = False  # monster is gone. no loot.\n                                monster.gold = 0  # gold has been turned to stone\n                                return 0\n                            else:\n                                print(f\"It remains stone-petrified!\")\n                                sleep(1)\n                                print(f\"You attack again!\")\n                                sleep(1.5)\n                                continue\n                    else:\n                        print(f\"You have vanquished the {monster.name}!\")\n                        sleep(1)\n                        monster.gold = 0  # gold has been turned to stone\n                        self.in_proximity_to_monster = False  # monster is stone, no loot.\n                        return 0  # no damage sent to main\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to the Quantum Petrifaction Effect!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to the Quantum Petrifaction Effect!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Petrifaction is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def gravity_well(self, monster):\n        # like sleep and charm, but always successful.\n        # initial damage is rolled and then player has 1 free crit,\n        # thereafter monster must pass strength protection roll.\n        # player gets exp reward, but no gold or loot\n        quantum_unit_cost = 5\n        vulnerability_modifier = 0\n        if self.in_proximity_to_monster:\n            print(f\"Gravity Well\")\n            sleep(1)\n            self.hud()\n            if \"Gravity Well\" not in monster.immunities and \"All\" not in monster.immunities:\n                self.quantum_units -= quantum_unit_cost\n                if \"Gravity Well\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n\n                print(f\"Focusing the Quantum Weirdness on the ground beneath the {monster.name}, \"\n                      f\"a growing void of crushing gravity opens between worlds!!\")\n                sleep(1)\n                print(f\"It is pulled in by the insatiable force!\")\n                sleep(1)\n                initial_damage = dice_roll(10, 10)\n                print(f\"The aberrant void inflicts {initial_damage} hit points!\")\n                sleep(1.5)\n                pause()\n                monster.reduce_health(initial_damage)\n                if not monster.check_dead():\n                    damage_modifier = 3\n                    if \"Gravity Well\" in monster.vulnerabilities:\n                        damage_modifier = 4\n                    if \"Gravity Well\" in monster.resistances or \"All\" in monster.resistances:\n                        damage_modifier = 1\n                    # total_fails = 0\n                    while True:\n                        self.hud()\n                        print(f\"The {monster.name} remains trapped in the gravity well!\")\n                        sleep(1)\n                        input(f\"Press (ENTER) to attack: \")\n                        self.hud()\n                        print(f\"You raise your {self.wielded_weapon.name} and swing mightily..\")\n                        sleep(1.5)\n                        damage_to_monster = dice_roll((self.level * damage_modifier), self.hit_dice)\n                        # total_fails += 1\n                        print(f\"You inflict {damage_to_monster} hit points!\")\n                        sleep(1.5)\n                        self.hud()\n                        monster.reduce_health(damage_to_monster)\n                        if not monster.check_dead():\n                            level_advantage = 0\n                            if self.level > monster.level:\n                                level_advantage = self.level - monster.level\n                            player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                                vulnerability_modifier + level_advantage\n                            print(f\"Player base DC = {self.base_dc}\\n\"\n                                  f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                                  f\"Acumen: {self.acumen}\")\n                            if vulnerability_modifier != 0:\n                                print(f\"+ Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                            if level_advantage > 0:\n                                print(f\"+ Level Advantage: {level_advantage}\")\n                            sleep(1)\n                            print(f\"DC Total: {player_dc}\")\n                            sleep(1)\n                            monster_saving_throw = dice_roll(1, 20)\n                            monster_total = monster_saving_throw + monster.strength_modifier\n                            print(f\"Monster Protection Roll: {monster_saving_throw}\")\n                            sleep(1)\n                            print(f\"Monster Strength Modifier: {monster.strength_modifier}\")\n                            sleep(1)\n                            print(f\"Total: {monster_total}\")\n                            sleep(1)\n\n                            if monster_total >= player_dc:  # dnd\n                                print(f\"The {monster.name} breaks out of the gravitational hold!\")\n                                pause()\n                                return 0  # no damage sent back because already sent to monster.reduce_health()\n                            else:\n                                print(f\"It attempts to break free!\")\n                                sleep(1)\n                                print(f\"It is pulled back in!\")\n                                sleep(1.5)\n                                continue\n\n                        else:\n                            print(f\"You have vanquished the {monster.name}!\")\n                            sleep(1)\n                            monster.gold = 0  # gold has been lost to the void\n                            self.in_proximity_to_monster = False  # monster is gone, no loot.\n                            return 0  # no damage sent to main\n\n                else:\n                    print(f\"You have vanquished the {monster.name}!\")\n                    sleep(1)\n                    monster.gold = 0  # gold has been lost to the void\n                    self.in_proximity_to_monster = False  # monster is gone, no loot.\n                    return 0  # no damage sent to main\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to the Gravity Well Effect!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to the Gravity Well Effect!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Gravity Well is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def hold_monster(self, monster):\n        # like sleep and charm, but pits player wisdom against monster strength\n        quantum_unit_cost = 3\n        if self.in_proximity_to_monster:\n            print(f\"Hold Monster\")\n            sleep(1)\n            self.hud()\n            if \"Hold Monster\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerability_modifier = 0\n                if \"Hold Monster\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Hold Monster\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                # turn_roll = dice_roll(1, 20)\n                # player_total = (turn_roll + self.wisdom_modifier + self.acumen + vulnerability_modifier)\n                # The difficulty class (\"DC\") of the Protection Roll should be based on the quantum manipulator:\n                # 8 + acumen + casting ability modifier.\n                # The GM rolls a d20 on behalf of the monster, adds the appropriate saving modifier based on\n                # the monster's stats, and compares to the quantum manipulator's save DC.\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player DC = {self.base_dc}\\n\"\n                      f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"{monster.name} Strength Modifier: {monster.strength_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                monster_total = monster_roll + monster.strength_modifier + resistance_modifier\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc > monster_total:\n                    self.quantum_units -= quantum_unit_cost  # level 3 effect. uses 3 units\n                    print(f\"The {monster.name} is held fast by Quantum Forces!\")\n                    sleep(1)\n                    input(f\"Press (ENTER) to attack: \")\n                    self.hud()\n                    finishing_move_roll = dice_roll(1, 20) + self.wielded_weapon.to_hit_bonus + self.dexterity_modifier\n                    difficulty_class = monster.armor_class\n                    print(f\"1d20 roll: {finishing_move_roll}\")  # remove after testing ?\n                    print(f\"Difficulty Class: {difficulty_class}\")  # remove after testing ?\n                    if finishing_move_roll >= difficulty_class:  #\n                        print(f\"You raise your {self.wielded_weapon.name} and swing mightily..\")\n                        sleep(1.5)\n                        #\n                        return monster.hit_points  # return the total amount of monster hp, effectively killing it\n                    else:\n                        print(f\"It has broken free!!\")\n                        pause()\n                        return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost  # level 2 effect. uses 2 units\n                    print(f\"The {monster.name} resists!\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to the Hold Effect!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to the Hold Effect!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Hold Monster is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def quantum_web(self, monster):\n        # web is a match of player's intuition as reflected by wisdom, vs the monster's ability to dodge\n        # a web that is shooting toward it.\n        quantum_unit_cost = 2\n        if self.in_proximity_to_monster:\n            print(f\"Web\")\n            sleep(1)\n            self.hud()\n            if \"Web\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerability_modifier = 0\n                if \"Web\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Web\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                # turn_roll = dice_roll(1, 20)\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + vulnerability_modifier)\n                # print(f\"Quantum Check: {turn_roll}\")\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                sleep(1)\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Dexterity Protection Roll: {monster_roll}\")\n                print(f\"{monster.name} Dexterity Modifier: {monster.dexterity_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                monster_total = monster_roll + monster.dexterity_modifier + resistance_modifier\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_total >= monster_total:\n                    self.quantum_units -= quantum_unit_cost  # level 2 effect. uses 2 units\n                    print(f\"The {monster.name} is webbed..\")\n                    sleep(1)\n                    input(f\"Press (ENTER) to vanquish: \")\n                    self.hud()\n                    finishing_move_roll = dice_roll(1, 20) + self.wielded_weapon.to_hit_bonus + self.dexterity_modifier\n                    sleeping_difficulty_class = monster.armor_class\n                    print(f\"1d20 roll: {finishing_move_roll}\")  # remove after testing ?\n                    print(f\"Difficulty Class: {sleeping_difficulty_class}\")  # remove after testing ?\n                    if finishing_move_roll > sleeping_difficulty_class:  #\n                        print(f\"You raise your {self.wielded_weapon.name} and swing mightily..\")\n                        sleep(1.5)\n                        # pause()\n                        return monster.hit_points  # return the total amount of monster hp, effectively killing it\n                    else:\n                        print(f\"It broke free!!\")\n                        pause()\n                        return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost  # level 2 effect. uses 2 units\n                    print(f\"The {monster.name} dodges!\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to the Quantum Web Effect!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to the Quantum Web Effect!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Web is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def quantum_charm(self, monster):\n        # Charm matches the player's Charisma vs the monster's wisdom;\n        # your power of persuasion vs their perception\n        quantum_unit_cost = 2\n        if self.in_proximity_to_monster:\n            print(f\"Charm\")\n            sleep(1)\n            self.hud()\n            if \"Charm\" not in monster.immunities and \"All\" not in monster.immunities and not monster.undead:\n                vulnerability_modifier = 0\n                if \"Charm\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Charm\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                # turn_roll = dice_roll(1, 20)\n                # total = (turn_roll + self.charisma_modifier + self.acumen + vulnerability_modifier)\n                # print(f\"Quantum Check: {turn_roll}\\nCharisma Modifier: {self.charisma_modifier}\\n\"\n                #      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier > 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.charisma_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC = {self.base_dc}\\n\"\n                      f\"Charisma Modifier: {self.charisma_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier != 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"{monster.name} Wisdom Modifier: {monster.wisdom_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                monster_total = monster_roll + monster.wisdom_modifier + resistance_modifier\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc >= monster_total:\n                    self.quantum_units -= quantum_unit_cost\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is charmed..\")\n                    else:\n                        print(f\"The {monster.name} is charmed..\")\n                    sleep(1)\n                    input(f\"Press (ENTER) to vanquish: \")\n                    self.hud()\n                    finishing_move_roll = dice_roll(1, 20) + self.wielded_weapon.to_hit_bonus + self.dexterity_modifier\n                    charm_difficulty_class = monster.armor_class\n                    print(f\"1d20 roll: {finishing_move_roll}\")  # remove after testing ?\n                    print(f\"Difficulty Class: {charm_difficulty_class}\")  # remove after testing ?\n                    if finishing_move_roll >= charm_difficulty_class:\n                        print(f\"You raise your {self.wielded_weapon.name} and swing mightily..\")\n                        sleep(1.5)\n                        # pause()\n                        return monster.hit_points  # return the total amount of monster hp, effectively killing it\n                    else:\n                        print(f\"It breaks free from your charm and comes to its senses!!\")\n                        pause()\n                        return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is not persuaded by your charms!\")\n                    else:\n                        print(f\"The {monster.name} is not persuaded by your charms!\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if monster.undead:\n                    print(f\"The undead ignore your wiles!!\")\n                    sleep(1)\n                else:\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is immune to being charmed!\")\n                        sleep(1)\n                    else:\n                        print(f\"The {monster.name} is immune to being charmed!\")\n                        sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Charm is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def quantum_sleep(self, monster):\n        # sleep matches the player's intelligence vs the monster's wisdom;\n        # your knowledge of quantum nature vs their perception\n        quantum_unit_cost = 1\n        if self.in_proximity_to_monster:\n            print(f\"Sleep\")\n            sleep(1)\n            self.hud()\n            if \"Sleep\" not in monster.immunities and \"All\" not in monster.immunities and not monster.undead:\n                vulnerability_modifier = 0\n                if \"Sleep\" in monster.vulnerabilities:\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Sleep\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                # turn_roll = dice_roll(1, 20)\n                # total = (turn_roll + self.intelligence_modifier + self.acumen + vulnerability_modifier)\n                # print(f\"Quantum Check: {turn_roll}\\nIntelligence Modifier: {self.intelligence_modifier}\\n\"\n                #      f\"Acumen: {self.acumen}\")\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.intelligence_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC = {self.base_dc}\\n\"\n                      f\"Intelligence Modifier: {self.intelligence_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier > 0:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                print(f\"Monster Roll: {monster_roll}\")\n                monster_total = monster_roll + monster.wisdom_modifier + resistance_modifier\n                print(f\"{monster.name} Wisdom modifier: {monster.wisdom_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc >= monster_total:\n                    self.quantum_units -= quantum_unit_cost\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is sleeping..\")\n                    else:\n                        print(f\"The {monster.name} is sleeping..\")\n                    sleep(1)\n                    input(f\"Press (ENTER) to vanquish: \")\n                    self.hud()\n                    finishing_move_roll = dice_roll(1, 20) + self.wielded_weapon.to_hit_bonus + self.dexterity_modifier\n                    sleeping_difficulty_class = monster.armor_class\n                    print(f\"1d20 roll: {finishing_move_roll}\")  # remove after testing ?\n                    print(f\"Difficulty Class: {sleeping_difficulty_class}\")  # remove after testing ?\n                    if finishing_move_roll >= sleeping_difficulty_class:\n                        print(f\"You raise your {self.wielded_weapon.name} and swing mightily..\")\n                        sleep(1.5)\n                        pause()\n                        return monster.hit_points  # return the total amount of monster hp, effectively killing it\n                    else:\n                        print(f\"It woke up!!\")\n                        pause()\n                        return 0\n                else:\n                    self.quantum_units -= quantum_unit_cost\n                    print(f\"The {monster.name} isn't sleepy!\")\n                    sleep(1)\n                    pause()\n                    return 0\n            else:\n                if monster.undead:\n                    print(f\"Undead do not sleep!!\")\n                    sleep(1)\n                else:\n                    if monster.proper_name != \"None\":\n                        print(f\"{monster.proper_name} is immune to Quantum Sleep!\")\n                        sleep(1)\n                    else:\n                        print(f\"The {monster.name} is immune to Quantum Sleep!\")\n                        sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Sleep is a Battle Effect only!\")\n            sleep(1)\n            return\n\n    def quantum_strength(self, monster):\n        # heal to full strength and get *2 melee damage multiplier (defined in melee())\n        if monster is None:\n            print(f\"Quantum Strength\")\n        else:\n            print(f\"Quantum Strength (BATTLE)\")\n        sleep(1)\n        self.hud()\n        quantum_unit_cost = 2\n        rndm_phrases = [\n            \"Drawing on all of your innate understanding, you draw out the Quantum Energies.\",\n            \"Retrieving the memories of the effect, you calm yourself and harness the weird energies..\",\n            \"Quietly retreating into the recesses of memory, you grasp at the weird energies..\"\n        ]\n        phrase = random.choice(rndm_phrases)\n        print(f\"{phrase}\")\n        sleep(1)\n        print(f\"Great power courses through your body!\")\n        sleep(1)\n        self.quantum_strength_effect = True\n        self.quantum_units -= quantum_unit_cost\n        self.quantum_strength_uses = -1  # to compensate for end of turn calculation\n        if self.hit_points < self.maximum_hit_points:  # in the rare case player has hit point overage,\n            self.hit_points = self.maximum_hit_points  # this will not disrupt that advantage\n        pause()\n        return 0\n\n    def quantum_medicine(self, monster):\n        if monster is None:\n            print(f\"Quantum Medicine\")\n        else:\n            print(f\"Quantum Medicine (BATTLE)\")\n        sleep(1)\n        self.hud()\n        # perhaps use this math for higher healing effect:\n        # number_of_dice = (3 + self.level - 1)  # 3 dice for lvl 1, 4 for lvl 2, 5 for lvl 3....\n        # heal = dice_roll(number_of_dice, 4)  + (1 * number_of_dice)\n        quantum_unit_cost = 1\n        # number_of_dice = (3 + self.level + self.quantum_level)  # consider changing to self.quantum_level\n        # heal = dice_roll(number_of_dice, 6) + number_of_dice + self.quantum_level\n        heal = math.ceil(self.maximum_hit_points * .75)\n\n        if self.hit_points < self.maximum_hit_points:\n            print(f\"You feel restorative powers welling up within you..\")\n            sleep(1)\n            print(f\"You heal {heal} points..\")  # remove after testing\n            self.hit_points += heal\n            if self.hit_points > self.maximum_hit_points:\n                self.hit_points = self.maximum_hit_points\n            # self.hit_points += math.floor(self.maximum_hit_points * .5)  # round down for cure light wounds.\n            self.quantum_units -= quantum_unit_cost\n        else:\n            print(f\"You are at maximum health!\")\n            sleep(1)\n        pause()\n        return 0\n\n    def quantum_medicine_enhanced_npc_subfunction(self, npc):\n        # called from quantum_medicine_enhanced() for each npc ally, if wounded\n        if npc.hit_points < npc.maximum_hit_points:\n            self.hud()\n            print(f\"{self.name} procures Enhanced Quantum Medicine for {npc.name}.\")\n            sleep(1)\n            print(f\"{npc.name} feels restorative powers welling up within..\")\n            sleep(1)\n            print(f\"{npc.name} heals to full strength..\")  # remove after testing\n            npc.hit_points = npc.maximum_hit_points\n\n            if npc.retreating:\n                npc.retreating = False\n                npc.retreat_counter = 0\n                print(f\"{npc.name} is no longer retreating\")\n                sleep(1)\n\n            pause()\n\n    def quantum_medicine_enhanced(self, monster):\n        # level 3 effect. consider adjusting, depending on playthrough;\n        # player should be able to use this by the time allies are encountered!\n        if monster is None:\n            print(f\"Quantum Medicine, Enhanced\")\n        else:\n            print(f\"Quantum Medicine, Enhanced (BATTLE)\")\n        sleep(1)\n        someone_has_been_healed = False\n        if self.sikira_ally or self.torbron_ally or self.magnus_ally or self.vozzbozz_ally:\n            if self.sikira_ally and self.sikira.hit_points < self.sikira.maximum_hit_points:\n                self.quantum_medicine_enhanced_npc_subfunction(self.sikira)\n                someone_has_been_healed = True\n            if self.torbron_ally and self.torbron.hit_points < self.torbron.maximum_hit_points:\n                self.quantum_medicine_enhanced_npc_subfunction(self.torbron)\n                someone_has_been_healed = True\n            if self.magnus_ally and self.magnus.hit_points < self.magnus.maximum_hit_points:\n                self.quantum_medicine_enhanced_npc_subfunction(self.magnus)\n                someone_has_been_healed = True\n            if self.vozzbozz_ally and self.vozzbozz.hit_points < self.vozzbozz.maximum_hit_points:\n                self.quantum_medicine_enhanced_npc_subfunction(self.vozzbozz)\n                someone_has_been_healed = True\n\n        self.hud()\n        quantum_unit_cost = 3\n        heal = math.ceil(self.maximum_hit_points * .90)\n        if self.hit_points < self.maximum_hit_points:\n            someone_has_been_healed = True\n            print(f\"You procure Enhanced Quantum Medicine.\")\n            sleep(1)\n            print(f\"You feel restorative powers welling up within you..\")\n            sleep(1)\n            print(f\"You heal {heal} points..\")  # remove after testing\n            self.hit_points += heal\n            if self.hit_points > self.maximum_hit_points:\n                self.hit_points = self.maximum_hit_points\n\n        if someone_has_been_healed:\n            self.quantum_units -= quantum_unit_cost\n\n        else:\n            if self.sikira_ally or self.torbron_ally or self.magnus_ally or self.vozzbozz_ally:\n                print(\"All in the party are at maximum health.\")\n            else:\n                print(f\"You are at maximum health.\")\n            sleep(1)\n        pause()\n        return 0\n\n    def protection_from_evil(self, monster):\n        # everything but a 1 roll will succeed\n        if monster is None:\n            print(f\"Protection from Evil\")\n        else:\n            print(f\"Protection from Evil (BATTLE)\")\n        sleep(1)\n        quantum_unit_cost = 1\n        self.hud()\n        rndm_phrases = [\n            \"Concentrating and calming yourself, you attempt to harness your innate Quantum Knowledge..\",\n            \"Quieting your mind, you focus inward to harness the Quantum Energies..\",\n            \"The world around you becomes muted and still as you introspectively draw upon your innate Quantum Skill..\"\n        ]\n        effect_phrase = random.choice(rndm_phrases)\n        prot_roll = dice_roll(1, 20)\n        print(f\"{effect_phrase}\")\n        sleep(1.5)\n        if prot_roll > 1:\n            self.protection_effect = True\n            self.protection_effect_uses = -1  # to compensate for end of turn calculation\n            self.protection_effect_value = (1 + self.acumen)\n            self.quantum_units -= quantum_unit_cost\n            print(f\"You have succeeded!\")\n            sleep(1)\n            print(f\"You gain a Quantum Protection advantage + {self.protection_effect_value}!\")\n            pause()\n            return 0\n        else:\n            print(f\"You are unable to glean the Quantum Effects..\")\n            self.quantum_units -= quantum_unit_cost\n            pause()\n            return 0\n\n    def quantum_help1(self, monster):\n        cls()\n        if monster is None:\n            print(\"HELP\")\n        else:\n            print(\"HELP (BATTLE)\")\n        print(f\"Exp Level: {self.level}  Quantum Knowledge Level: {self.quantum_level}\")\n        print()\n        print(f\"Quantum Missile: Multiple glowing projectiles, corresponding to your Quantum Knowledge and randomness\"\n              f\"\\nare derived from other realities and launched at your enemy. \"\n              f\"Success based on Player Wisdom vs Enemy AC.\")\n        print()\n        print(f\"Quantum Sleep: Your knowledge of Quantum Weirdness allows you to attempt to lull your enemy into a\\n\"\n              f\"dream-like and utterly vulnerable state. Initial success based on Player Intelligence vs Enemy Wisdom\\n\"\n              f\"Final success depends on Enemy AC.\")\n        print()\n        print(f\"Quantum Medicine: Quantum Actions at a subatomic level repair physical wounds, ignoring necrosis and \"\n              f\"poison.\\nEffectiveness equal to 75% of maximum hit points.\")\n        print()\n        print(f\"Protection from Evil: Through Quantum Probabilities, reduce the chances of successful enemy Quantum\\n\"\n              f\"attacks and paralyzing effects. Effectiveness depends on Quantum Knowledge Level. Duration depends on\\n\"\n              f\"player Constitution.\")\n        print()\n        print(f\"Turn Undead: Attempt to strike panic into the Undead by turning the very improbable forces responsible\"\n              f\"\\nfor their weird existence against them. Success based on Player Wisdom vs Enemy Wisdom\")\n        print()\n        pause()\n        return None\n\n    def quantum_help2(self, monster):\n        cls()\n        if monster is None:\n            print(\"HELP\")\n        else:\n            print(\"HELP (BATTLE)\")\n        print(f\"Exp Level: {self.level}  Quantum Knowledge Level: {self.quantum_level}\")\n        print()\n        print(f\"Web: Through improbabilities, shoot a giant web at your enemy, incapacitating them. Initial success\\n\"\n              f\"based on Player Wisdom vs Enemy Dexterity. Final success depends on Enemy AC.\")\n        print()\n        print(f\"Quantum Purify: Works only when poisoned or necrotic, but once engaged, Quantum Weirdness at the \"\n              f\"molecular level purifies the flesh from these\\n\"\n              f\"effects and also increases Hit Points.\")\n        print()\n        print(f\"Quantum Strength: Harnessing Quantum Energies, your Strength and melee damage are increased\\n\"\n              f\"for a maximum duration based on your Quantum Knowledge level and Strength Modifier.\")\n        print()\n        print(f\"Quantum Blaze: Rays of intense flame strike your enemy. Success based on Player Wisdom vs Enemy AC.\")\n        print()\n        print(f\"Quantum Charm: Use your powers of persuasion to lull your enemy into a vulnerable sleep. Initial\\n\"\n              f\"success based on Player Charisma vs Enemy Wisdom. Final success depends on Enemy AC.\")\n        print()\n        pause()\n        return None\n\n    def quantum_help3(self, monster):\n        cls()\n        if monster is None:\n            print(\"HELP\")\n        else:\n            print(\"HELP (BATTLE)\")\n        print(f\"Exp Level: {self.level}  Quantum Knowledge Level: {self.quantum_level}\")\n        print()\n        print(f\"Lightning: Harness an electrical storm to be cast at your enemy, causing burns and arcflash damage.\\n\"\n              f\"Success based on Player Wisdom vs Enemy AC.\")\n        print()\n        print(f\"Hold Monster: Employ Quantum Forces to hold and incapacitate your enemy. Success based on \\n\"\n              f\"Player Wisdom vs Enemy Strength. Final success depends on Enemy AC.\")\n        print()\n        print(f\"Phantasm: By Quantum Tunneling, create a terrifyingly debilitating mental illusion, capturing the\\n\"\n              f\"mind of your enemy and causing agonizing mental damage. Success based on Player Wisdom vs Enemy\\n\"\n              f\"Intelligence. (Undead are unbelieving.)\")\n        print()\n        print(f\"Immolation: A winding trail of flame encircles your enemy, closing until forming a complete immersion\\n\"\n              f\"of deadly fire. Success based on Player Wisdom vs Enemy Dexterity.\")\n        print()\n        print(f\"Vortex: A watery twister forms around your enemy, disorienting, and causing crushing damage.\\n\"\n              f\"Success based on Player Wisdom vs Enemy Strength.\")\n        print()\n        print(f\"Quantum Medicine, Enhanced: Quantum Actions at a subatomic level repair physical wounds, ignoring \"\n              f\"necrosis and poison.\\n\"\n              f\"Effectiveness equal to 90% of maximum hit points. In addition, heals any and all allies to \"\n              f\"full strength.\\nIf procured during battle, healed allies no longer retreat, and immediately re-enter \"\n              f\"the fight.\")\n        pause()\n        return None\n\n    def quantum_help4(self, monster):\n        cls()\n        if monster is None:\n            print(\"HELP\")\n        else:\n            print(\"HELP (BATTLE)\")\n        print(f\"Exp Level: {self.level}  Quantum Knowledge Level: {self.quantum_level}\")\n        print()\n        print(f\"Quantum Firewall: Through Spooky Action at a Distance, a wall of fire forms, seemingly from out of \"\n              f\"your hands,\\n\"\n              f\"looming toward your enemy at great speed. Success based on Player Wisdom vs Enemy Dexterity.\")\n        print()\n        print(f\"Quantum Petrifaction: 100% chance to petrify monster, after which, player has 1 free crit, \"\n              f\"thereafter, enemy\\n\"\n              f\"must pass Constitution protection roll. 2 failed rolls after initial attack = permanent \"\n              f\"petrification.\\n\"\n              f\"Player gets exp reward, but no gold or loot.\")\n        print()\n        print(f\"Fear: Strike terror into the hearts of the living with Quantum Weirdness, sending them retreating.\\n\"\n              f\"Success based on Player Wisdom vs Enemy Wisdom. (Undead are unbelieving)\")\n        print()\n        print(f\"Finger of Death: Concentrating powerful Quantum Energies into a single finger, great pain and high\\n\"\n              f\"damage befall any enemy touched. Success based on Player Wisdom vs Enemy Constitution.\")\n        print()\n        print(f\"Banish: At the will of the Manipulator, a Quantum Tunnel between worlds claims the enemy's existence,\\n\"\n              f\"transferring it offworld. Success based on Player Wisdom vs Enemy Charisma.\")\n        print()\n        pause()\n        return None\n\n    def quantum_help5(self, monster):\n        cls()\n        if monster is None:\n            print(\"HELP\")\n        else:\n            print(\"HELP (BATTLE)\")\n        print(f\"Exp Level: {self.level}  Quantum Knowledge Level: {self.quantum_level}\")\n        print()\n        print(f\"Disentangle: Quantum Energy shoots from your hands toward your enemy.\\n\"\n              f\"On a failed roll, the enemy takes massive damage. All Quantum Particles within the enemy, across\\n\"\n              f\"all realities are disentangled, if hit points reach 0. A disentangled enemy and its entire\\n\"\n              f\"inventory, are gone forever; In fact, they never existed. Player receives experience\\n\"\n              f\"reward but no Gold or Loot. Success based on Player Wisdom vs Enemy Dexterity.\")\n        print()\n        print(f\"Ice Storm: A Quantum squall of frozen death hurls toward your enemy causing overwhelming cold and\\n\"\n              f\"force damage. Success based on Player Wisdom vs Enemy Constitution.\")\n        print()\n        print(f\"Firestorm: Ice Storm's counterpart, encompassed of seething flame, causing high burn damage.\\n\"\n              f\"Success based on Player Wisdom vs Enemy Dexterity.\")\n        print()\n        print(f\"Gravity Well: 100% chance to successfully incapacitate your enemy in an impossible Quantum Gravity\\n\"\n              f\"Singularity which causes initial crushing damage. Player has 1 free crit. Target must make successful \"\n              f\"strength\\n\"\n              f\"protection roll. Upon failed save, enemy remains trapped and player gets additional free crit.\\n\"\n              f\"Enemy and all items are lost to the crushing gravity. Player gets exp reward, but no gold or loot\\n\"\n              f\"unless enemy item is protected by Quantum Weirdness.\")\n        print()\n        pause()\n        return None\n\n    def quantum_help6(self, monster):\n        cls()\n        if monster is None:\n            print(\"HELP\")\n        else:\n            print(\"HELP (BATTLE)\")\n        print(f\"Exp Level: {self.level}  Quantum Knowledge Level: {self.quantum_level}\")\n        print()\n        print(f\"QUANTUM MASTER EFFECTS:\")\n        print()\n        print(f\"Quantum Spoken Word: Through impossibly, unimaginably small probabilities, the Master utters a single\\n\"\n              f\"word. If the enemy has less than 125 Hit Points, death results instantly. No protection roll,\\n\"\n              f\"no defense possible.\")\n        print()\n        print(f\"Quantum Mooncrusher: The Quantum Master rends otherworldly, crushed moon matter into existence and,\\n\"\n              f\"with amplified and compensatory gravity, propels it upon an enemy for a devastating attack yielding\\n\"\n              f\"extremely high force and crushing damage. Success based on Player Wisdom vs Enemy Dexterity.\")\n        print()\n        print(f\"Skeletal Remains: The Master pulls finite Quantum Energies from the ground, impossibly re-animating\\n\"\n              f\"fallen skeletal warriors lost to time and sending them forth as a stampeding army, resulting in\\n\"\n              f\"extreme force, bludgeoning, and melee damage. Success based on Player Wisdom vs Enemy Dexterity.\")\n        print()\n        print(f\"Negative Energy Plague: The Quantum Master harnesses Dark Energy and re-focuses it to form a\\n\"\n              f\"plague of mental agony causing severe damage to all creatures- living and undead. Success based on\\n\"\n              f\"Player Wisdom vs Enemy Intelligence.\")\n        print()\n        pause()\n        return None\n\n    def quantum_effects(self, monster):\n        # called from main loop\n        if self.quantum_units > 0:\n            printable_quantum_book = {1: {1: \"Quantum Missile\",\n                                          2: \"Sleep\",\n                                          3: \"Quantum Medicine\",\n                                          4: \"Protection from Evil\",\n                                          5: \"Turn Undead\"},\n                                      2: {1: \"Web\",\n                                          2: \"Purify\",\n                                          3: \"Quantum Strength\",\n                                          4: \"Scorch\",\n                                          5: \"Charm\"},\n                                      3: {1: \"Lightning\",\n                                          2: \"Hold Monster\",\n                                          3: \"Phantasm\",\n                                          4: \"Immolation\",\n                                          5: \"Vortex\",\n                                          6: \"Quantum Medicine, Enhanced\"},\n                                      4: {1: \"Firewall\",\n                                          2: \"Quantum Petrifaction\",\n                                          3: \"Fear\",\n                                          4: \"Finger of Death\",\n                                          5: \"Banish\"},\n                                      5: {1: \"Quantum Disentangle\",\n                                          2: \"Ice Storm\",\n                                          3: \"Firestorm\",\n                                          4: \"Gravity Well\"},\n                                      6: {1: \"Quantum Spoken Word\",\n                                          2: \"Quantum Mooncrusher\",\n                                          3: \"Skeletal Remains\",\n                                          4: \"Negative Energy Plague\"}\n\n                                      }\n            quantum_book = {1: {0: self.quantum_help1,\n                                1: self.quantum_missile,\n                                2: self.quantum_sleep,\n                                3: self.quantum_medicine,\n                                4: self.protection_from_evil,\n                                5: self.turn_undead},\n                            2: {0: self.quantum_help2,\n                                1: self.quantum_web,\n                                2: self.quantum_purify,\n                                3: self.quantum_strength,\n                                4: self.quantum_blaze,\n                                5: self.quantum_charm},\n                            3: {0: self.quantum_help3,\n                                1: self.quantum_lightning,\n                                2: self.hold_monster,\n                                3: self.phantasm,\n                                4: self.immolation,\n                                5: self.vortex,\n                                6: self.quantum_medicine_enhanced},\n                            4: {0: self.quantum_help4,\n                                1: self.firewall,\n                                2: self.quantum_petrifaction,\n                                3: self.fear,\n                                4: self.finger_of_death,\n                                5: self.banish},\n                            5: {0: self.quantum_help5,\n                                1: self.quantum_disentangle,\n                                2: self.ice_storm,\n                                3: self.fire_storm,\n                                4: self.gravity_well},\n                            6: {0: self.quantum_help6,\n                                1: self.quantum_spoken_word,\n                                2: self.moon_crusher,\n                                3: self.skeletal_remains,\n                                4: self.negative_energy_plague}\n                            }\n            while True:\n                self.hud()\n                try:\n                    print(f\"Your Quantum Knowledge level: {self.quantum_level}\")\n                    q_level = int(input(f\"Quantum Level to cast: \"))\n\n                    if self.quantum_level >= q_level and self.quantum_units >= q_level:\n                        # create key and value lists from nested dict in order to produce cleanly printable dictionary\n                        key_lst = list(printable_quantum_book[q_level].keys())\n                        value_list = list(printable_quantum_book[q_level].values())\n                        working_dict = {key_lst[i]: value_list[i] for i in range(len(key_lst))}\n                        for key, value in working_dict.items():\n                            print(f\"{key}: {value}\")\n                        q_to_cast = int(input(f\"Number of Quantum Effect to cast (or 0 for HELP): \"))\n\n                        # quantum_function = quantum_book[q_level][q_to_cast]  # (monster)  # beta removed (monster)\n                        # and added to function calls below:\n                        if q_to_cast == 0:  # if HELP, call function, which will return here and loop continues\n                            # noinspection PyArgumentList\n                            quantum_book[q_level][q_to_cast](monster)\n                            # pycharm is unhappy calling this method through a reference to the method buried in a dict\n                            # quantum_function(monster)  # beta used to be simply quantum_function\n\n                        else:  # if not HELP, return the damage from function to the main loop\n                            # noinspection PyArgumentList\n                            return quantum_book[q_level][q_to_cast](monster)\n                            # return quantum_function(monster)\n\n                    else:\n                        if self.quantum_level < q_level:\n                            print(f\"You have not yet acquired that level of Quantum knowledge!\")\n                            sleep(1)\n                            continue\n\n                        if self.quantum_units < q_level:\n                            print(f\"You do not have enough Quantum Energy Units!\")\n                            sleep(1)\n                            continue\n\n                except (ValueError, KeyError):\n                    print(f\"Invalid input\")\n                    sleep(.25)\n                    return None  # creates condition for a continue statement in main loop so a turn is not wasted\n        else:\n            print(f\"You have no Quantum unit energy!\")\n            pause()\n            return None  # creates condition for a continue statement in main loop so a turn is not wasted\n\n    def vozzbozz_moon_crusher(self, monster):\n        player_total = self.vozzbozz.base_dc + self.vozzbozz.wisdom_modifier + self.vozzbozz.acumen\n        print(f\"Vozzbozz base DC: {self.vozzbozz.base_dc}\")\n        print(f\"Wisdom modifier: {self.vozzbozz.wisdom_modifier}\")\n        print(f\"Acumen: {self.vozzbozz.acumen}\")\n        print(f\"Total: {player_total}\")\n        sleep(1)\n        monster_roll = dice_roll(1, 20)\n        monster_mod = monster.dexterity_modifier\n        monster_total = monster_roll + monster_mod\n        print(f\"Monster Protection Roll: {monster_roll}\")\n        print(f\"Monster Dexterity Modifier: {monster_mod}\")\n        print(f\"Monster Total: {monster_total}\")\n        if player_total >= monster_total:\n            critical_bonus = 1\n            if dice_roll(1, 20) == 20:\n                critical_bonus = 2\n            number_of_dice = 20 * critical_bonus\n            quantum_hit_die = 6\n            damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice) + \\\n                dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)  # 2nd attack=force damage\n            melee_bonus = dice_roll(self.vozzbozz.acumen, self.vozzbozz.hit_dice)\n            total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n\n            print(f\"Vozzbozz closes his eyes for a moment.\")\n            sleep(1)\n            print(f\"Upon opening them, they burn brighter than the sun!\")\n            pause()\n            self.hud()\n            print(f\"With a world-shaking and awe-inspiring eruption, \"\n                  f\"a sky-filling blanket of flaming moon-matter materializes above and falls upon your enemy!!\")\n            print(f\"{number_of_dice}d{quantum_hit_die} + {number_of_dice}d{quantum_hit_die} force damage + \"\n                  f\"1 per die rolled: \"\n                  f\"{damage_to_opponent}\")\n            print(f\"{self.vozzbozz.acumen}d{self.vozzbozz.hit_dice} Damage Bonus: {melee_bonus}\")\n            print(f\"The great storm of fire and stone explodes directly on target in surreal \"\n                  f\"glory and inflicts {total_damage_to_opponent} points of damage!\")\n            pause()\n            self.hud()\n            return total_damage_to_opponent\n        else:\n            critical_bonus = 1\n            if dice_roll(1, 20) == 20:\n                critical_bonus = 2\n            number_of_dice = 20 * critical_bonus\n            damage_to_opponent = (dice_roll(number_of_dice, 6) + (1 * number_of_dice) +\n                                  dice_roll(number_of_dice, 6) + (1 * number_of_dice)) / 2  # 2nd attack=force damage\n            melee_bonus = dice_roll(self.vozzbozz.acumen, self.vozzbozz.hit_dice)\n            total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n            if damage_to_opponent > 0:\n                print(f\"Vozzbozz closes his eyes for a moment.\")\n                sleep(1)\n                print(f\"His focus is momentarily disrupted by the {monster.name}!\")\n                pause()\n                self.hud()\n                print(f\"Other-worldly moon matter materializes above and falls upon your enemy..\")\n                print(f\"{number_of_dice}d8 + {number_of_dice}d8 force damage + 1 per die rolled: \"\n                      f\"{damage_to_opponent}\")\n                print(f\"{self.vozzbozz.acumen}d{self.vozzbozz.hit_dice} Damage Bonus: {melee_bonus}\")\n                print(f\"The great storm of fire and stone explodes directly on target in surreal \"\n                      f\"glory, but due to the interruption, it only inflicts {total_damage_to_opponent} points\\n\"\n                      f\"of damage!\")\n                pause()\n                self.hud()\n                return total_damage_to_opponent\n\n    def vozzbozz_word_kill(self, monster):\n        # if monster < 125 hp, it dies\n        print(f\"Vozzbozz smiles for an instant, then his face is drained of its humanity..\")\n        sleep(1)\n        self.hud()\n        if monster.hit_points < 125:\n            print(f\"He cries out in a world-shaking voice..\")\n            sleep(1)\n            print(f\"SUPPLICIUM!!\")\n            sleep(1.5)\n            print(f\"The {monster.name} drops like a rock!!!\")\n            pause()\n            return monster.hit_points\n        else:\n            print(f\"The {monster.name} has too much life energy to succumb to the Quantum Spoken Word effect!\")\n            pause()\n            return 0\n\n    def vozzbozz_skeletal_remains(self, monster):\n        print(f\"Vozzbozz Base DC: {self.vozzbozz.base_dc}\")\n        print(f\"Wisdom modifier: {self.vozzbozz.wisdom_modifier}\")\n        print(f\"Acumen: {self.vozzbozz.acumen}\")\n        player_total = self.vozzbozz.base_dc + self.vozzbozz.wisdom_modifier + self.vozzbozz.acumen\n        print(f\"Total: {player_total}\")\n        critical_bonus = 1\n        if dice_roll(1, 20) == 20:\n            critical_bonus = 2\n        monster_roll = dice_roll(1, 20)\n        monster_mod = monster.constitution_modifier\n        monster_total = monster_roll + monster_mod\n        print(f\"Monster Protection Roll: {monster_roll}\")\n        print(f\"Monster Constitution Modifier: {monster_mod}\")\n        print(f\"Monster Total: {monster_total}\")\n        if player_total >= monster_total:\n            #\n            number_of_dice = 15 * critical_bonus\n            quantum_hit_die = 12\n            force_dmg_hit_die = 8\n            damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice) + \\\n                dice_roll(number_of_dice, force_dmg_hit_die) + (1 * number_of_dice)  # 2nd attack = force damage\n            melee_bonus = dice_roll(self.vozzbozz.acumen, self.vozzbozz.hit_dice)\n            total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n            if damage_to_opponent > 0:\n                print(f\"Vozzbozz forms a fist and then beckons the ground with his free hand..\")\n                sleep(1)\n                print(f\"Without warning, the ground swells with the thundering cacophony of countless skeletal\\n\"\n                      f\"warriors arising from an abysmal black chasm!!\")\n                sleep(1)\n                print(f\"Some upon skeletal horseback, others on foot, but with one mind and purpose, they swarm upon\\n\"\n                      f\"your enemy, thrusting ever forward in a voracious clashing of bone, steel and shield!!\")\n                pause()\n                self.hud()\n                print(f\"{number_of_dice}d{quantum_hit_die} + {number_of_dice}d{force_dmg_hit_die} force damage \"\n                      f\"+ 1 per skeleton bludgeoning damage: {damage_to_opponent}\")\n                print(f\"{self.vozzbozz.acumen}d{self.vozzbozz.hit_dice} Damage Bonus: {melee_bonus}\")\n                # print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n                print(f\"The great swarm of armor, axe, sword and spear inflicts \"\n                      f\"{total_damage_to_opponent} points of damage!\")\n                pause()\n                self.hud()\n                return total_damage_to_opponent\n            else:\n                print(f\"For all of its fear-inspiring appearance, the skeletal horde\"\n                      f\" fails to land any damage!\")  # 0 damage\n                sleep(1)\n                return 0\n        else:\n            number_of_dice = 15 * critical_bonus\n            quantum_hit_die = 12\n            damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)  # no force damage\n            melee_bonus = dice_roll(self.vozzbozz.acumen, self.vozzbozz.hit_dice)\n            total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n            # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n            print(f\"Vozzbozz forms a fist and then beckons the ground with his free hand..\")\n            sleep(1)\n            print(f\"Without warning, the ground swells with the thundering cacophony of countless skeletal\\n\"\n                  f\"warriors arising from an abysmal black chasm!!\")\n            sleep(1)\n            print(f\"The {monster.name} distracts the Master for a moment..\")\n            pause()\n            self.hud()\n            print(f\"The skeletal horde takes form but does not inflict damage to its fullest potential..\")\n            sleep(1)\n            print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per skeleton bludgeoning damage = {damage_to_opponent}\")\n            print(f\"{self.vozzbozz.acumen}d{self.vozzbozz.hit_dice} Damage Bonus: {melee_bonus}\")\n            print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n            pause()\n            self.hud()\n            return total_damage_to_opponent\n\n    def vozzbozz_negative_energy_plague(self, monster):\n        print(f\"Vozzbozz Base DC: {self.vozzbozz.base_dc}\")\n        print(f\"Wisdom modifier: {self.vozzbozz.wisdom_modifier}\")\n        print(f\"Acumen: {self.vozzbozz.acumen}\")\n        player_total = self.vozzbozz.base_dc + self.vozzbozz.wisdom_modifier + self.vozzbozz.acumen\n        print(f\"Total: {player_total}\")\n        sleep(1)\n        monster_roll = dice_roll(1, 20)\n        monster_mod = round((monster.intelligence - 10) / 2)\n        monster_total = monster_roll + monster_mod\n        print(f\"Monster Protection Roll: {monster_roll}\")\n        print(f\"Monster Intelligence Modifier: {monster_mod}\")\n\n        print(f\"Monster Total: {monster_total}\")\n        critical_bonus = 1\n        if dice_roll(1, 20) == 20:\n            critical_bonus = 2\n        if player_total >= monster_total:\n            #\n            number_of_dice = 15 * critical_bonus\n            quantum_hit_die = 12\n            crushing_die = 8\n            damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice) + \\\n                dice_roll(number_of_dice, crushing_die) + (1 * number_of_dice)  # 2nd attack = crushing damage\n            melee_bonus = dice_roll(self.vozzbozz.acumen, self.vozzbozz.hit_dice)\n            total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n            if damage_to_opponent > 0:\n                print(f\"Vozzbozz grasps at the air, until his entire shape fades to a mere black silhouette\\n\"\n                      f\"of stars and celestial bodies floating through!!\")\n                sleep(1)\n                print(f\"A harrowing and visceral vacuum of shear, black emptiness shoots forth \"\n                      f\"from his hands toward your enemy!!\")\n                sleep(1)\n                print(f\"With universal abhorrence, the negative energy plague entangles the {monster.name}!!\")\n                sleep(1)\n                print(f\"{number_of_dice}d{quantum_hit_die} necrotic damage + {number_of_dice}d{crushing_die} \"\n                      f\"crushing damage + 1 per die rolled mental anguish: {damage_to_opponent}\")\n                print(f\"{self.vozzbozz.acumen}d{self.vozzbozz.hit_dice} Damage Bonus: {melee_bonus}\")\n                print(f\"The great, empty darkness inflicts \"\n                      f\"{total_damage_to_opponent} points of damage!\")\n                pause()\n                self.hud()\n                return total_damage_to_opponent\n            else:\n                print(f\"For all of its fear-inspiring appearance, the plague\"\n                      f\" fails to land any damage!\")  # 0 damage\n                sleep(1)\n                return 0\n        else:\n            number_of_dice = 15 * critical_bonus\n            quantum_hit_die = 12\n            damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)  # no crushing damage\n            melee_bonus = dice_roll(self.vozzbozz.acumen, self.vozzbozz.hit_dice)\n            total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n            # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n            print(f\"Vozzbozz grasps at the air, until his entire shape fades to a mere silhouette of blackness, with\\n\"\n                  f\"stars and celestial bodies floating through!!\")\n            sleep(1)\n            print(f\"A harrowing and visceral vacuum of shear, black emptiness shoots forth \"\n                  f\"from his hands toward your enemy!!\")\n            sleep(1)\n            print(f\"The {monster.name} distracts Vozzbozz for just a moment..\")\n            pause()\n            self.hud()\n            print(f\"The plague takes form but does not inflict damage to its fullest potential..\")\n            sleep(1)\n            print(\n                f\"{number_of_dice}d{quantum_hit_die} necrotic damage + 1 per die rolled mental damage: \"\n                f\"{damage_to_opponent}\")\n            print(f\"{self.vozzbozz.acumen}d{self.vozzbozz.hit_dice} Damage Bonus: {melee_bonus}\")\n            print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n            pause()\n            self.hud()\n            return total_damage_to_opponent\n\n    def vozzbozz_attack(self, monster):\n        print(f\"Vozzbozz attacks with Quantum Energy!!\")\n        sleep(1)\n        if monster.hit_points < 100:\n            return self.vozzbozz_word_kill(monster)\n        else:\n            rndm_effect_lst = [self.vozzbozz_moon_crusher, self.vozzbozz_skeletal_remains,\n                               self.vozzbozz_negative_energy_plague]\n            rndm_effect = random.choice(rndm_effect_lst)\n            return rndm_effect(monster)\n\n    def quantum_spoken_word(self, monster):\n        # everything but a 1 roll will succeed\n        # if monster < 125 hp, it dies\n        quantum_unit_cost = 6\n        if self.in_proximity_to_monster:\n            if \"Spoken Word\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Spoken Word\" in monster.vulnerabilities:\n                    vulnerable = True\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Spoken Word.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                # player_total = (roll_d20 + self.wisdom_modifier + self.acumen)\n                print(f\"Clearing your mind, you attempt to harness the weird energies...\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                if roll_d20 == 1 and not vulnerable:\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                else:\n                    if monster.hit_points < 125:\n                        print(f\"SUPPLICIUM!!\")\n                        sleep(1.5)\n                        return monster.hit_points\n                    else:\n                        print(f\"The {monster.name} has too much life energy to succumb to the quantum effect!\")\n                        pause()\n                        return 0\n        else:\n            print(f\"Quantum Spoken Word is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def quantum_disentangle(self, monster):\n        # Quantum weirdness shoots to your enemy.\n        # A creature targeted by this spell must make a Dexterity protection roll.\n        # On a failed save, the target takes full effect damage.\n        # The target is disentangled if this damage leaves it with 0 hit points.\n\n        quantum_unit_cost = 5\n        if self.in_proximity_to_monster:\n            if \"Disentangle\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Disentangle\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Disentangle\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Quantum Disentangle.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + level_advantage)\n                print(\n                    f\"Clearing your mind, you attempt to harness the weird energies..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    sleep(1)\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.dexterity_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Dexterity Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + 40\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"Quantum Weirdness released from your hand shoots toward your enemy!\")\n                        sleep(1)\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll + 40 force damage: {damage_to_opponent}\")\n                        print(f\"The {monster.name} suffers {damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        monster.reduce_health(damage_to_opponent)\n                        if not monster.check_dead():\n                            return 0  # damage already returned to reduce_health function\n                        else:\n                            if monster.proper_name != \"None\":\n                                print(f\"{monster.proper_name} has been disentangled from all existence!!\")\n                            else:\n                                print(f\"The {monster.name} has been disentangled from all existence!!\")\n                            sleep(1.5)\n                            monster.gold = 0\n\n                            self.in_proximity_to_monster = False\n                            # pause()\n                            return 0\n                    else:\n                        print(f\"It fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    print(f\"Quantum Weirdness released from your hand shoots toward your enemy!\")\n                    sleep(1)\n                    print(f\"The {monster.name} dodges!\")\n                    sleep(1)\n                    pause()\n                    self.hud()\n                    return 0\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Quantum Disentangle!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Quantum Disentangle!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Disentangle is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def firewall(self, monster):\n        # everything but a 1 roll will succeed\n        # on a successful dexterity protection roll, monster takes 50% damage.\n        quantum_unit_cost = 4\n        if self.in_proximity_to_monster:\n            if \"Firewall\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Firewall\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Firewall\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Quantum Firewall.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen)\n                print(f\"Clearing your mind, you attempt to harness the weird energies \"\n                      f\"to create the Firewall..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(f\"A tiny burning cinder, no larger than a grain of sand \"\n                          f\"pops into existence and is snuffed out just as suddenly..\")\n                    sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.dexterity_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Dexterity Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 10\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    # print(f\"Attack roll: {roll_d20}\")\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"A red-hot wall of dreadful flames forms from your hand and speeds toward your enemy!\")\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per die: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"The flaming wall of fire envelopes the target and inflicts \"\n                              f\"{total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, it fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 10\n                    damage_to_opponent = math.ceil((dice_roll(number_of_dice,\n                                                              quantum_hit_die) + (1 * number_of_dice)))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The Firewall takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per die rolled = \"\n                          f\"{damage_to_opponent} (ROUNDED)\")\n                    # print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It inflicts {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Firewall!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Firewall!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Firewall is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def finger_of_death(self, monster):\n        # everything but a 1 roll will succeed\n        # on a successful constitution protection roll, monster takes 50% damage.\n        quantum_unit_cost = 4\n        if self.in_proximity_to_monster:\n            if \"Finger of Death\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Finger of Death\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Finger of Death\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Finger of Death.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen)\n                print(\n                    f\"Clearing your mind, you attempt to harness the weird energies...... \")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.constitution_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Constitution Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 10\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"Your hands throb with blinding Quantum Energy!\")\n                        sleep(1)\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll + number of dice: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"You extend a white-hot finger, merely touching your enemy, inflicting \"\n                              f\"{total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"Your effect fails to land any damage!\")  # 0\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 10\n                    damage_to_opponent = math.ceil((dice_roll(number_of_dice, quantum_hit_die) +\n                                                    (4 * number_of_dice)))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"Your hands throb with red-hot Quantum Energy..\")\n                    sleep(1)\n                    # print(f\"The effect takes form but does not to its fullest potential..\")\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 2 * number of dice rolled = \"\n                          f\"{damage_to_opponent} (ROUNDED)\")\n                    # print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    sleep(1)\n                    print(f\"You extend a glowing finger and touch your enemy, inflicting \"\n                          f\"{total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Finger of Death!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Finger of Death!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Finger of Death is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def moon_crusher(self, monster):\n        # everything but a 1 roll will succeed\n        # on a successful dexterity protection roll, monster takes 50% damage.\n        quantum_unit_cost = 6\n        if self.in_proximity_to_monster:\n            if \"Mooncrusher\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Mooncrusher\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Mooncrusher\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Quantum Mooncrusher.\")\n                sleep(1)\n                self.hud()\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + level_advantage)\n                print(\n                    f\"Clearing your mind, you attempt to harness the weird Quantum Energies \"\n                    f\"to rend the Mooncrusher..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(f\"A tiny burning cinder, no larger than a grain of sand \"\n                          f\"pops into existence and falls on your enemy..\")\n                    sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.dexterity_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Dexterity Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    crushing_dmg_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice) + \\\n                        dice_roll(number_of_dice, crushing_dmg_die) + (1 * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"With a world-shaking and awe-inspiring eruption, \"\n                              f\"a swarm of burning moon-matter appears above and falls upon your enemy!!\")\n                        print(f\"{number_of_dice}d{quantum_hit_die} + {number_of_dice}d{crushing_dmg_die} \"\n                              f\"crushing damage + 1 per die rolled: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"The great storm of fire and stone explodes directly on target in surreal \"\n                              f\"glory and inflicts {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, it fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)  # no crush\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The Mooncrusher takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per die rolled = {damage_to_opponent}\")\n                    print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Quantum Mooncrusher!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Quantum Mooncrusher!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Mooncrusher is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def skeletal_remains(self, monster):\n        # everything but a 1 roll will succeed.\n        # on a successful dexterity protection roll, monster takes 50% damage.\n        quantum_unit_cost = 6\n        if self.in_proximity_to_monster:\n            if \"Skeletal Remains\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Skeletal Remains\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Skeletal Remains\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Skeletal Remains.\")\n                sleep(1)\n                self.hud()\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + level_advantage)\n                print(f\"Clearing your mind, you attempt to harness the weird energies \"\n                      f\"to create the Skeletal Remains..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(f\"A tiny jawbone pops into existence and is hurled upon your enemy..\")\n                    sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.constitution_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Constitution Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    force_dmg_die = 8\n                    no_of_skeletons = dice_roll(number_of_dice, quantum_hit_die)\n                    damage_to_opponent = no_of_skeletons + (1 * number_of_dice) + \\\n                        dice_roll(number_of_dice, force_dmg_die) + (1 * number_of_dice)  # 3rd attack = bludgeoning\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"Before you or your enemy can see it, you both sense the ground swell with the\\n\"\n                              f\"thundering cacophony of {no_of_skeletons} skeletal warriors arising from a \"\n                              f\"black chasm!!\")\n                        sleep(1)\n                        print(f\"Some on horseback, others on foot, but with one mind and purpose, they swarm upon\\n\"\n                              f\"your enemy, thrusting ever forward in a voracious clashing of bone, steel and shield!!\")\n                        sleep(1)\n                        print(f\"{number_of_dice}d{quantum_hit_die} + {number_of_dice}d{force_dmg_die} \"\n                              f\"force damage + 1 per die rolled bludgeoning damage: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        # print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n                        print(f\"The great swarm of armor, axe, sword and spear inflicts \"\n                              f\"{total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, the skeletal horde\"\n                              f\" fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)  # no f dmg\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The skeletal horde takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per skeleton bludgeoning damage = \"\n                          f\"{damage_to_opponent}\")\n                    print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Skeletal Remains!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Skeletal Remains!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Skeletal Remains is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def negative_energy_plague(self, monster):\n        # everything but a 1 roll will succeed\n        # on a successful intelligence protection roll, monster takes 50% damage.\n        quantum_unit_cost = 6\n        if self.in_proximity_to_monster:\n            if \"Negative Energy Plague\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Negative Energy Plague\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Negative Energy Plague\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Negative Energy Plague.\")\n                sleep(1)\n                self.hud()\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + level_advantage)\n                print(f\"Clearing your mind, you attempt to harness the weird energies \"\n                      f\"to create the Negative Energy Plague..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    # print(f\"A tiny jawbone pops into existence and is hurled upon your enemy..\")\n                    # sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = round((monster.intelligence - 10) / 2)\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Intelligence Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    crushing_dmg_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice) + \\\n                        dice_roll(number_of_dice, crushing_dmg_die) + (1 * number_of_dice)  # 2nd attack = crushing dmg\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"A harrowing and visceral vacuum of shear, black emptiness shoots forth \"\n                              f\"from your hands toward your enemy!!\")\n                        sleep(1)\n                        print(f\"With universal abhorrence, the negative energy plague entangles the {monster.name}!!\")\n                        sleep(1)\n                        print(f\"{number_of_dice}d{quantum_hit_die} necrotic damage + \"\n                              f\"{number_of_dice}d{crushing_dmg_die} crushing damage + 1 per die \"\n                              f\"rolled mental anguish: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"The great, empty darkness inflicts \"\n                              f\"{total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, the plague\"\n                              f\" fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)  # no crush\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The plague takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(\n                        f\"{number_of_dice}d{quantum_hit_die} necrotic damage + 1 per die rolled mental damage: \"\n                        f\"{damage_to_opponent}\")\n                    print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It hits for {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Negative Energy Plague!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to the Plague!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Negative Energy Plague is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def ice_storm(self, monster):\n        # everything but a 1 roll will succeed\n        # on a successful constitution protection Roll, monster takes 50% damage.\n        quantum_unit_cost = 5\n        if self.in_proximity_to_monster:\n            if \"Ice Storm\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Ice Storm\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Ice Storm\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Ice Storm.\")\n                sleep(1)\n                self.hud()\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + level_advantage)\n                print(\n                    f\"Clearing your mind, you attempt to harness the weird energies \"\n                    f\"to create the Ice Storm..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(f\"A single snowflake pops into existence and falls on your enemy..\")\n                    sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.constitution_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Constitution Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (self.acumen * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"With a crackling rumble, a frigid storm of ice and hail thrusts forth from your hand!!\")\n                        print(\n                            f\"{number_of_dice}d{quantum_hit_die} roll + {number_of_dice} + \"\n                            f\"({self.acumen} * number of dice rolled): \"\n                            f\"{damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"The great freezing storm explodes on target and does \"\n                              f\"{total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, it fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = math.ceil(dice_roll(number_of_dice, quantum_hit_die) +\n                                                   (self.acumen * number_of_dice))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The storm does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(\n                        f\"{number_of_dice}d{quantum_hit_die} roll + ({self.acumen} * number of dice rolled): \"\n                        f\"{damage_to_opponent} (ROUNDED) \")\n                    # print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It inflicts {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Ice Storm!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Ice Storm!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Ice Storm is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def fire_storm(self, monster):\n        # everything but a 1 roll will succeed\n        # on a successful dexterity protection Roll, monster takes reduced damage.\n        quantum_unit_cost = 5\n        if self.in_proximity_to_monster:\n            if \"Fire Storm\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Fire Storm\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Fire Storm\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Fire Storm.\")\n                sleep(1)\n                self.hud()\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen + level_advantage)\n                print(\n                    f\"Clearing your mind, you attempt to harness the weird energies \"\n                    f\"to create the Fire Storm..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(f\"A single glowing ember pops into existence and falls on your enemy..\")\n                    sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = monster.dexterity_modifier\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Dexterity Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (self.acumen * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"With a deafening roar, a storm of searing hot flames thrusts forth from your hand!!\")\n                        print(\n                            f\"{number_of_dice}d{quantum_hit_die} roll + {number_of_dice} + \"\n                            f\"({self.acumen} * number of dice rolled): \"\n                            f\"{damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"The scorching storm explodes on target and does \"\n                              f\"{total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, it fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 12\n                    damage_to_opponent = math.ceil(dice_roll(number_of_dice, quantum_hit_die) +\n                                                   (self.acumen * number_of_dice))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    # damage_to_opponent = math.ceil((dice_roll(number_of_dice, 8) + (1 * number_of_dice)) / 2)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The storm does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + ({self.acumen} * number of dice rolled) = \"\n                          f\"{damage_to_opponent} (ROUNDED) \")\n                    # print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It inflicts {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Fire Storm!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Fire Storm!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Fire Storm is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def phantasm(self, monster):\n        # phantasm matches your wisdom vs monster intelligence\n        quantum_unit_cost = 3\n        vulnerability_modifier = 0\n        if self.in_proximity_to_monster:\n            if \"Phantasm\" not in monster.immunities and \"All\" not in monster.immunities and not monster.undead:\n                vulnerable = False\n                if \"Phantasm\" in monster.vulnerabilities:\n                    vulnerable = True\n                    vulnerability_modifier = self.acumen\n                resistance_modifier = 0\n                if \"Phantasm\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Phantasm.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                # player_total = (roll_d20 + self.wisdom_modifier + self.acumen)\n                print(f\"Focusing your innate understanding, you attempt to harness the weird energies \"\n                      f\"to create the illusion..\")\n                sleep(1)\n                print(f\"Quantum Check: {roll_d20}\")  # anything but a natural 1 is success\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(f\"The Phantasm pops into existence as a cloudy blur, and promptly vanishes..\")\n                    sleep(1)\n                    print(\"Your focus has failed..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC = {self.base_dc}\\n\"\n                      f\"Wisdom Modifier: {self.wisdom_modifier}\\n\"\n                      f\"Acumen: {self.acumen}\")\n                if vulnerable:\n                    print(f\"Monster Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                sleep(1)\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_mod = math.floor((monster.intelligence - 10) / 2)\n                monster_total = monster_roll + monster_mod + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Intelligence Modifier: {monster_mod}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if player_dc >= monster_total:  # > tie goes to defender >= tie goes to player\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (self.acumen * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"The Phantasmal illusion takes form through weird Quantum \"\n                              f\"tunneling and completely seizes the mind of your enemy!\")\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll + {self.acumen} per die: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"The terrible vision inflicts {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"For all of its fear-inspiring appearance, it fails to land any damage!\")  # 0 damage\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = math.ceil((dice_roll(number_of_dice, quantum_hit_die) +\n                                                    (1 * number_of_dice)))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The Phantasmal illusion takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per die rolled = \"\n                          f\"{damage_to_opponent} (ROUNDED)\")\n                    # print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                    print(f\"It does {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.undead:\n                    print(f\"Undead do not believe!!\")\n                    sleep(1)\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Phantasm!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Phantasmal Forces!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Phantasm is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def quantum_lightning(self, monster):\n        # lightning matches player wisdom against monster AC\n        quantum_unit_cost = 3\n        if self.in_proximity_to_monster:\n            if \"Lightning\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Lightning\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Lightning\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Quantum Lightning.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen)\n                print(f\"Focusing your innate understanding, you attempt to harness the weird energies..\")\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    sleep(1)\n                    print(f\"The Lightning crackles into existence \"\n                          f\"and spreads randomly, completely missing the {monster.name}..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL HIT!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                print(f\"Monster armor class: {monster.armor_class}\")\n                monster_total = monster.armor_class + resistance_modifier\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"{number_of_dice} bolts of Quantum Lightning materialize from nothingness and \"\n                              f\"hit their target!\")\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 burn damage per bolt: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Arcflash Damage: {melee_bonus}\")\n                        print(f\"They do {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"Through its own Weirdness, the {monster.name} manages to \"\n                              f\"avoid damage from the weird energy!\")  # 0 dmg\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = (dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice))\n\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The lightning takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per die rolled = \"\n                          f\"{damage_to_opponent} (ROUNDED)\")\n\n                    print(f\"It inflicts {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Quantum Lightning!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Quantum Lightning attacks!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Lightning is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def immolation(self, monster):\n        # immolation matches player wisdom against monster dexterity\n        quantum_unit_cost = 3\n        if self.in_proximity_to_monster:\n            if \"Immolation\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Immolation\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Immolation\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Immolation.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                # player_total = (roll_d20 + self.wisdom_modifier + self.acumen)\n                print(f\"Focusing your innate understanding, you attempt to harness the weird energies..\")\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    sleep(1)\n                    print(f\"The wreath of flame crackles into existence \"\n                          f\"and spreads wildly, completely missing your target..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL HIT!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                vulnerability_modifier = 0\n                if vulnerable:\n                    vulnerability_modifier = self.acumen\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier > 0:\n                    print(f\"Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_total = monster_roll + monster.dexterity_modifier + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Dexterity Modifier: {monster.dexterity_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if roll_d20 == 20 or player_dc >= monster_total:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"A serpentine trail of fire materializes from nothingness and \"\n                              f\"wreathes your target in scorching flame!\")\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage Bonus: {melee_bonus}\")\n                        print(f\"It inflicts {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"Through its own Weirdness, the {monster.name} manages to \"\n                              f\"avoid damage from the weird energy!\")  # 0 dmg\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die)\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = damage_to_opponent\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The trail of fire takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll: {damage_to_opponent} (ROUNDED)\")\n                    print(f\"It does {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Quantum Immolation Effects!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Quantum Immolation attacks!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Immolation is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def vortex(self, monster):\n        # vortex matches player wisdom against monster strength\n        quantum_unit_cost = 3\n        if self.in_proximity_to_monster:\n            if \"Vortex\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Vortex\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Vortex\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Vortex.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                # player_total = (roll_d20 + self.wisdom_modifier + self.acumen)\n                print(f\"Focusing your innate understanding, you attempt to harness the weird energies..\")\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    sleep(1)\n                    print(f\"The watery twister materializes and spreads wildly, completely missing your target..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL HIT!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                vulnerability_modifier = 0\n                if vulnerable:\n                    vulnerability_modifier = self.acumen\n                level_advantage = 0\n                if self.level > monster.level:\n                    level_advantage = self.level - monster.level\n                player_dc = self.base_dc + self.acumen + self.wisdom_modifier + \\\n                    vulnerability_modifier + level_advantage\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n                if vulnerability_modifier > 0:\n                    print(f\"Vulnerability Modifier: {vulnerability_modifier}\")\n                if level_advantage > 0:\n                    print(f\"Level Advantage: {level_advantage}\")\n                print(f\"Total: {player_dc}\")\n                sleep(1)\n                monster_roll = dice_roll(1, 20)\n                monster_total = monster_roll + monster.strength_modifier + resistance_modifier\n                print(f\"Monster Protection Roll: {monster_roll}\")\n                print(f\"Monster Strength Modifier: {monster.strength_modifier}\")\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                sleep(1)\n                if roll_d20 == 20 or player_dc >= monster_total:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"A twisting vortex of roaring water materializes from nothingness and \"\n                              f\"wraps your target with impossible crushing force!\")\n                        sleep(1)\n                        print(f\"{number_of_dice}d{quantum_hit_die} roll: {damage_to_opponent}\")\n                        print(f\"{self.acumen}d{self.hit_dice} Damage bonus: {melee_bonus}\")\n                        print(f\"It inflicts {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"Through its own Weirdness, the {monster.name} manages to \"\n                              f\"avoid damage from the weird energy!\")  # 0 dmg\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 8\n                    damage_to_opponent = math.ceil(dice_roll(number_of_dice, quantum_hit_die))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The twister takes form but does not inflict damage to its fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll: {damage_to_opponent} (ROUNDED)\")\n                    # print(f\"{self.acumen}d{self.hit_dice} Damage bonus: {melee_bonus}\")\n                    print(f\"It does {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Vortex Effects!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Vortex attacks!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Vortex is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def quantum_missile(self, monster):\n        # q_missile matches player wisdom vs monster AC\n        quantum_unit_cost = 1\n        if self.in_proximity_to_monster:\n            if \"Quantum Missile\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Quantum Missile\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Quantum Missile\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Quantum Missile.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen)\n                print(f\"Focusing your innate understanding, you attempt to aim the \"\n                      f\"Quantum Missile at the {monster.name}..\")\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    sleep(1)\n                    print(f\"The projectiles go awry..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = f\"Success!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                print(f\"Monster armor class: {monster.armor_class}\")\n                monster_total = monster.armor_class + resistance_modifier\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    # number_of_dice = (3 + (self.level - 1)) * critical_bonus  #consider changing to self.quantum_level\n                    number_of_dice = (1 + self.acumen) * critical_bonus\n                    quantum_die = 6\n                    damage_to_opponent = (dice_roll(number_of_dice, quantum_die) + (1 * number_of_dice))\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        print(f\"{number_of_dice} glowing projectiles materialize from nothingness and \"\n                              f\"hit their target!\")\n                        print(f\"{number_of_dice}d{quantum_die} roll + 1 force damage per projectile: \"\n                              f\"{damage_to_opponent}\\n\"\n                              f\"{self.acumen}d{self.hit_dice} Damage bonus: {melee_bonus}\\n\"\n                              f\"Total: {total_damage_to_opponent}\")\n                        print(f\"They do {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"It blocks the glowing projectiles!\")  # zero damage result\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (1 + self.acumen) * critical_bonus\n                    quantum_die = 6\n                    damage_to_opponent = math.ceil((dice_roll(number_of_dice, quantum_die) + (1 * number_of_dice)))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The glowing projectiles take form but do not inflict damage to their fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_die} roll + 1 per die rolled: {damage_to_opponent}\\n\"\n                          f\"Total: {total_damage_to_opponent} (ROUNDED)\")\n                    print(f\"They do {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to the Quantum Missile attack!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to the Quantum Missile attack!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Missile is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def quantum_blaze(self, monster):\n        # blaze is player's wisdom vs monster AC\n        quantum_unit_cost = 2\n        if self.in_proximity_to_monster:\n            if \"Blaze\" not in monster.immunities and \"All\" not in monster.immunities:\n                vulnerable = False\n                if \"Blaze\" in monster.vulnerabilities:\n                    vulnerable = True\n                resistance_modifier = 0\n                if \"Blaze\" in monster.resistances or \"All\" in monster.resistances:\n                    resistance_modifier = monster.evil_bonus\n                self.quantum_units -= quantum_unit_cost\n                print(f\"Quantum Blaze.\")\n                sleep(1)\n                self.hud()\n                roll_d20 = dice_roll(1, 20)  # attack roll\n                player_total = (self.base_dc + self.wisdom_modifier + self.acumen)\n                print(f\"Focusing your innate understanding, you attempt to grasp the weirdness..\")\n                print(f\"Quantum Check: {roll_d20}\")\n                sleep(1.5)\n                self.hud()\n                if roll_d20 == 1:\n                    print(\"Your focus has failed..\")\n                    sleep(1)\n                    print(f\"The rays of flame fly off chaotically..\")\n                    pause()\n                    self.hud()\n                    return 0\n                if roll_d20 == 20 or vulnerable:\n                    critical_bonus = 2\n                    hit_statement = \"CRITICAL!!\"\n                else:\n                    critical_bonus = 1\n                    hit_statement = \"Blazing rays of scorching flame are summoned by Quantum Weirdness and strike \" \\\n                                    \"your enemy!\"\n                print(f\"Player Base DC: {self.base_dc}\")\n                print(f\"Wisdom modifier: {self.wisdom_modifier}\")\n                print(f\"Acumen: {self.acumen}\")\n\n                print(f\"Total: {player_total}\")\n                sleep(1)\n                print(f\"Monster armor class: {monster.armor_class}\")\n                monster_total = monster.armor_class + resistance_modifier\n                if resistance_modifier != 0:\n                    print(f\"Monster Resistance Modifier: {resistance_modifier}\")\n                print(f\"Monster Total: {monster_total}\")\n                if roll_d20 == 20 or player_total >= monster_total:\n                    #\n                    # number_of_dice = (3 + (self.level - 1)) * critical_bonus\n                    number_of_dice = (self.level + self.acumen) * critical_bonus\n                    quantum_hit_die = 6\n                    damage_to_opponent = dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)\n                    melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent + melee_bonus)\n                    if damage_to_opponent > 0:\n                        print(hit_statement)\n                        sleep(1)\n                        # print(f\"Quantum Blaze = {number_of_dice}d{quantum_hit_die}(dice) + 1 * number of dice\")\n                        print(f\"{number_of_dice}d{quantum_hit_die} + \"\n                              f\"{number_of_dice} rays (1 force damage per ray): {damage_to_opponent}\\n\"\n                              f\"{self.acumen}d{self.hit_dice} Damage bonus: {melee_bonus}\\n\"\n                              f\"Total: {total_damage_to_opponent}\")\n                        print(f\"They inflict {total_damage_to_opponent} points of damage!\")\n                        pause()\n                        self.hud()\n                        return total_damage_to_opponent\n                    else:\n                        print(f\"{monster.he_she_it.capitalize()} dodges the blazing rays!\")  # zero damage result\n                        sleep(1)\n                        return 0\n                else:\n                    number_of_dice = (1 + self.acumen) * critical_bonus\n                    quantum_hit_die = 6\n                    damage_to_opponent = math.ceil((dice_roll(number_of_dice, quantum_hit_die) + (1 * number_of_dice)))\n                    # melee_bonus = dice_roll(self.acumen, self.hit_dice)\n                    total_damage_to_opponent = math.ceil(damage_to_opponent)\n                    print(\"Your attempt to harness the Quantum Weirdness lacks focus..\")\n                    sleep(1)\n                    print(f\"The blazing rays take form but do not inflict damage to their fullest potential..\")\n                    sleep(1)\n                    print(f\"{number_of_dice}d{quantum_hit_die} roll + 1 per die rolled: {damage_to_opponent}\\n\"\n                          f\"Total: {total_damage_to_opponent} (ROUNDED)\")\n                    print(f\"They inflict {total_damage_to_opponent} points of damage..\")\n                    pause()\n                    self.hud()\n                    return total_damage_to_opponent\n\n            else:\n                if monster.proper_name != \"None\":\n                    print(f\"{monster.proper_name} is immune to Quantum Blaze!!\")\n                    sleep(1)\n                else:\n                    print(f\"The {monster.name} is immune to Quantum Blaze!!\")\n                    sleep(1)\n                self.quantum_units -= quantum_unit_cost\n                print(f\"You have wasted Quantum Energy!\")\n                sleep(1)\n                pause()\n                return 0\n        else:\n            print(f\"Quantum Blaze is a Battle Effect only..\")\n            sleep(1)\n            return\n\n    def evade(self, monster):\n        # called from main loop, using return value from battle_menu_choices(), (if player has no allies)\n        if self.encounter < 21:\n            print(f\"You attempt a stealthy evasive maneuver..\")\n            sleep(1)\n            monster_roll = dice_roll(1, 20)\n            monster_total = monster_roll + monster.dexterity_modifier\n            player_roll = dice_roll(1, 20)\n            evade_success = player_roll + self.dexterity_modifier + self.stealth + self.acumen\n            if self.level > 3:\n                evade_success += self.acumen\n            print(f\"Stealth Check: {player_roll}\")\n            print(f\"Dexterity Modifier: {self.dexterity_modifier}\")\n            print(f\"Stealth bonus: {self.stealth}\")\n            if self.level > 3:\n                print(f\"Acumen: {self.acumen}\")\n\n            print(f\"Total: {evade_success}\")\n            sleep(1)\n            print(f\"Enemy Roll: {monster_roll}\")\n            print(f\"Enemy Dexterity Modifier: {monster.dexterity_modifier}\")\n            print(f\"Enemy Total: {monster_total}\")\n            if evade_success >= monster_total or evade_success == 20:\n                print(f\"You slip into the shadows..\")\n                sleep(1)\n                print(f\"Your stealth and dexterity have served you well!\")\n                sleep(1)\n                print(f\"The {monster.name} looks at {monster.his_her_its} surroundings, and departs,\"\n                      f\" obviously confused.\")\n                sleep(1)\n                print(f\"You have successfully evaded the {monster.name}!\")\n                pause()\n                self.hud()\n                return True\n\n            else:\n                print(f\"The {monster.name} swiftly blocks your escape!\")\n                sleep(.5)\n                print(f\"You are rooted to the spot. You must stand your ground!\")\n                pause()\n                self.hud()\n                return False\n\n        else:\n            # bosses cannot be evaded.\n            if monster.proper_name != \"None\":\n                print(f\"{monster.proper_name} is far too adept to be evaded!\")\n            else:\n                print(f\"The {monster.name} is far too adept to be evaded!!\")\n            sleep(.5)\n            print(f\"You are rooted to the spot. You must stand your ground!\")\n            pause()\n            self.hud()\n            return False\n\n    # INVENTORY AND ITEMS\n\n    def chemist_main(self):\n        rndm_aroma_lst = ['agarwood', 'angelica root', 'anise', 'basil', 'bergamot', 'calamodin', 'calamus', 'camphor',\n                          'cardamom', 'cedar', 'camomile', 'cinnamon', 'citron', 'clary sage', 'clove', 'davana',\n                          'eucalyptus',\n                          'frankincense', 'galbanum', 'hemlock', 'jasmine', 'lavender', 'lemongrass', 'mugwort oil',\n                          'pennyroyal', 'peppermint', 'sage', 'sandalwood', 'sassafras', 'garden mint', 'spikenard',\n                          'spruce oil', 'star anise oil', 'tea tree oil', 'tarragon oil', 'tsuga oil', 'valerian',\n                          'vanilla sweet grass', 'warionia', 'vetiver', 'wintergreen', 'yarrow oil']\n\n        while True:\n            self.hud()\n            rndm_aroma = random.choice(rndm_aroma_lst)\n            print(f\"(In Town, Quantum Chemist Shop)\")\n            print(f\"Jahns, the Fieldenberg Quantum Chemist is here, busying himself at the crucible.\\n\"\n                  f\"Mortars and pestles litter the counter and the smell of {rndm_aroma} fills the air...\")\n\n            '''if self.hit_points < self.maximum_hit_points:\n                print(\"The aura fills your nostrils and lungs...healing you to full strength!\")\n                self.hit_points = self.maximum_hit_points\n                pause()\n                self.hud()'''\n\n            print(f\"Your gold: {self.gold} GP\")\n            chemist_choice = input(\n                \"(P)urchase quantum items, (S)ell quantum items, Display your (I)nventory, or \"\n                \"(E)xit the chemist: \").lower()\n\n            if chemist_choice == 'p':\n                self.buy_chemist_items()\n                continue\n\n            elif chemist_choice == 's':\n                self.sell_chemist_items()\n                continue\n\n            elif chemist_choice == 'i':\n                self.inventory()\n                continue\n\n            elif chemist_choice == 'e':\n                return\n\n            else:\n                continue\n\n    def sell_chemist_items(self):\n        # this code for belt item inventory works, but was written very early on and is extremely amateurish.\n        # it handles belt inventory in a clunky way, e.g. self.elixirs is simply an integer, and there is no\n        # belt dictionary like self.pack\n\n        # create new instances of all objects:\n        healing_potion = HealingPotion()\n        strength_potion = StrengthPotion()\n        scroll_of_town_portal = TownPortalImplements()\n        elixir = Elixir()\n        antidote = Antidote()\n\n        while True:\n            self.hud()\n            belt = [self.potions_of_healing, self.town_portals, self.potions_of_strength, self.elixirs, self.antidotes]\n            if sum(belt) == 0:\n                print(f\"You have no quantum items to sell..\")\n                pause()\n                return\n\n            print(f\"Your gold: {self.gold} GP\")\n            print(f\"You currently carry the following quantum items:\")\n            print(f\"1: Potions of Strength - Quantity: {self.potions_of_strength}\")\n            print(f\"2: Potions of Healing - Quantity: {self.potions_of_healing}\")\n            print(f\"3: Scrolls of Town Portal - Quantity: {self.town_portals}\")\n\n            print(f\"4: Clarifying Elixirs - Quantity: {self.elixirs}\")\n            print(f\"5: Poison Antidote Vials - Quantity: {self.antidotes}\")\n            print(f\"Your gold: {self.gold} GP\")\n            type_to_sell = input(f\"Pick item to sell by number, or go (B)ack: \").lower()\n\n            if type_to_sell == 'b':\n                return\n\n            elif type_to_sell == '1':\n                your_item = \"potions of strength\"\n\n                if self.potions_of_strength < 1:\n                    print(f\"You do not have any {your_item}..\")\n                    sleep(1)\n                    continue\n\n            elif type_to_sell == '2':\n                your_item = \"potions\"\n\n                if self.potions_of_healing < 1:\n                    print(f\"You do not have any {your_item}..\")\n                    sleep(1)\n                    continue\n\n            elif type_to_sell == '3':\n                your_item = \"scrolls of town portal\"\n\n                if self.town_portals < 1:\n                    print(f\"You do not have any {your_item}..\")\n                    sleep(1)\n                    continue\n\n            elif type_to_sell == '4':\n                your_item = \"clarifying elixirs\"\n\n                if self.elixirs < 1:\n                    print(f\"You do not have any {your_item}..\")\n                    sleep(1)\n                    continue\n\n            elif type_to_sell == '5':\n                your_item = \"vials of antidote\"\n\n                if self.antidotes < 1:\n                    print(f\"You do not have any {your_item}..\")\n                    sleep(1)\n                    continue\n\n            else:\n                print(f\"Invalid..\")\n                continue\n\n            try:\n                number_of_items_to_sell = int(input(f\"Enter number of {your_item} to sell: \"))\n\n                if type_to_sell == '1' and number_of_items_to_sell > 0:\n\n                    if self.potions_of_strength >= number_of_items_to_sell:\n                        self.potions_of_strength -= number_of_items_to_sell\n                        gold_received = (strength_potion.sell_price * number_of_items_to_sell)\n                        self.gold += gold_received\n                        print(f\"You sell {number_of_items_to_sell} {your_item} for {gold_received} GP.\")\n                        pause()\n                        continue\n\n                    else:\n                        print(f\"Invalid.\")\n                        sleep(1)\n                        continue\n\n                elif type_to_sell == '2' and number_of_items_to_sell > 0:\n\n                    if self.potions_of_healing >= number_of_items_to_sell:\n                        self.potions_of_healing -= number_of_items_to_sell\n                        gold_received = (healing_potion.sell_price * number_of_items_to_sell)\n                        self.gold += gold_received\n                        print(f\"You sell {number_of_items_to_sell} {your_item} for {gold_received} GP.\")\n                        pause()\n                        continue\n\n                    else:\n                        print(f\"Invalid.\")\n                        sleep(1)\n                        continue\n\n                elif type_to_sell == '3' and number_of_items_to_sell > 0:\n\n                    if self.town_portals >= number_of_items_to_sell:\n                        self.town_portals -= number_of_items_to_sell\n                        gold_received = (scroll_of_town_portal.sell_price * number_of_items_to_sell)\n                        self.gold += gold_received\n                        print(f\"You sell {number_of_items_to_sell} {your_item} for {gold_received} GP.\")\n                        pause()\n                        continue\n\n                    else:\n                        print(f\"Invalid.\")\n                        sleep(1)\n                        continue\n\n                elif type_to_sell == '4' and number_of_items_to_sell > 0:\n\n                    if self.elixirs >= number_of_items_to_sell:\n                        self.elixirs -= number_of_items_to_sell\n                        gold_received = (elixir.sell_price * number_of_items_to_sell)\n                        self.gold += gold_received\n                        print(f\"You sell {number_of_items_to_sell} {your_item} for {gold_received} GP.\")\n                        pause()\n                        continue\n\n                    else:\n                        print(f\"Invalid.\")\n                        sleep(1)\n                        continue\n\n                elif type_to_sell == '5' and number_of_items_to_sell > 0:\n\n                    if self.antidotes >= number_of_items_to_sell:\n                        self.antidotes -= number_of_items_to_sell\n                        gold_received = (antidote.sell_price * number_of_items_to_sell)\n                        self.gold += gold_received\n                        print(f\"You sell {number_of_items_to_sell} {your_item} for {gold_received} GP.\")\n                        pause()\n                        continue\n\n                    else:\n                        print(f\"Invalid.\")\n                        sleep(1)\n                        continue\n\n                else:\n                    print(f\"Invalid entry..\")\n\n            except ValueError:\n                print(\"Invalid input\")\n                continue\n\n    def buy_chemist_items(self):\n        # create new instances of all objects:\n        healing_potion = HealingPotion()\n        strength_potion = StrengthPotion()\n        scroll_of_town_portal = TownPortalImplements()\n        elixir = Elixir()\n        antidote = Antidote()\n\n        chemist_dict = {\n            'Potions of Giant Strength': [strength_potion],\n            'Potions of Healing': [healing_potion],\n            'Town Portal Scrolls': [scroll_of_town_portal],\n            'Elixirs': [elixir],\n            'Antidotes': [antidote]\n        }\n        while True:\n            self.hud()\n            print(f\"Jahns has items for sale in the following categories:\")\n            # create a list of item types:\n            item_type_lst = list(chemist_dict.keys())\n            # create a dictionary from list of item types, print out, add 1 to indexing\n            item_type_dict = {}\n            for item_type in item_type_lst:\n                item_type_dict[item_type] = item_type_lst.index(item_type)\n            for key, value in item_type_dict.items():\n                print(value + 1, ':', key)\n            print(f\"Your gold: {self.gold} GP\")\n            buy_or_exit = input(\"Pick item type by number, Display your (I)nventory, or go (B)ack: \").lower()\n\n            if buy_or_exit == 'i':\n                self.inventory()\n                continue\n\n            elif buy_or_exit == 'b':\n                return\n                # break\n\n            elif buy_or_exit not in ('i', 'b'):\n                try:\n                    item_type_index_to_buy = int(buy_or_exit)\n                    # item_type_index_to_buy = int(input(f\"Enter the category of the item to buy by number: \"))\n                    item_type_to_buy = item_type_lst[item_type_index_to_buy - 1]\n                except (IndexError, ValueError):\n                    print(\"Invalid entry..\")\n                    sleep(1)\n                    continue\n\n                while True:\n                    self.hud()\n                    print(f\"{item_type_to_buy} for sale:\")\n                    item_dict = {}\n                    chemist_dict[item_type_to_buy].sort(key=lambda x: x.buy_price)\n                    for item in (chemist_dict[item_type_to_buy]):\n                        item_dict[item] = (chemist_dict[item_type_to_buy]).index(item)\n                    for key, value in item_dict.items():\n                        print(value + 1, ':', key)\n                    print(f\"Your gold: {self.gold} GP\")\n                    buy_or_exit = input(\"Pick item by number, Display your (I)nventory, or go (B)ack: \").lower()\n\n                    if buy_or_exit == 'i':\n                        self.inventory()\n                        continue\n\n                    elif buy_or_exit == 'b':\n                        break\n\n                    elif buy_or_exit not in ('i', 'b'):\n                        try:\n                            item_index_to_buy = int(buy_or_exit)\n                            item_index_to_buy -= 1  # again, indexing starts at 0 and is awkward\n                            sale_item = (chemist_dict[item_type_to_buy])[item_index_to_buy]\n\n                        except (IndexError, ValueError):\n                            print(\"Invalid entry..\")\n                            sleep(1)\n                            continue\n\n                        try:\n                            number_of_items = int(input(f\"How many would you like to buy: \"))\n\n                        except ValueError:\n                            print(\"Invalid entry..\")\n                            sleep(1)\n                            continue\n\n                        if number_of_items > 0:\n                            purchase_price = sale_item.buy_price * number_of_items\n\n                            if self.gold >= purchase_price:\n\n                                if self.level >= sale_item.minimum_level:\n                                    self.gold -= purchase_price\n                                    # replace these if statements with dictionary in future\n\n                                    if sale_item.name == 'Scroll of Town Portal':\n                                        self.town_portals += number_of_items\n\n                                    elif sale_item.name == 'Potion of Strength':\n                                        self.potions_of_strength += number_of_items\n\n                                    elif sale_item.name == 'Potion of Healing':\n                                        self.potions_of_healing += number_of_items\n\n                                    elif sale_item.name == 'Clarifying Elixir':\n                                        self.elixirs += number_of_items\n\n                                    elif sale_item.name == 'Vial of Antidote':\n                                        self.antidotes += number_of_items\n                                    self.hud()\n                                    print(f\"You buy {number_of_items} {sale_item.name}s\")\n                                    # (self.pack[sale_item.item_type]).append(sale_item)\n                                    self.item_type_inventory(sale_item.item_type)\n                                    pause()\n                                    break\n\n                                else:\n                                    print(f\"Minimum requirements not met.\")\n                                    pause()\n                                    continue\n                            else:\n                                print(\"You do not have enough gold.\")\n                                pause()\n                                continue\n                        else:\n                            print(f\"Zero..\")\n                            continue\n\n    def item_management_sub_menu(self):\n        while True:\n            self.hud()\n            item_to_manage = input(\n                f\"Manage (W)eapons, (A)rmor, (S)hields, (B)oots, (C)loaks, View your (I)nventory, or \"\n                f\"(E)xit Item Management: \").lower()\n\n            if item_to_manage == 'w':\n                self.item_management('Weapons', self.wielded_weapon)\n                continue\n\n            elif item_to_manage == 'a':\n                self.item_management('Armor', self.armor)\n                continue\n\n            elif item_to_manage == 's':\n                self.item_management('Shields', self.shield)\n                continue\n\n            elif item_to_manage == 'b':\n                self.item_management('Boots', self.boots)\n                continue\n\n            elif item_to_manage == 'c':\n                self.item_management('Cloaks', self.cloak)\n                continue\n\n            elif item_to_manage == 'i':\n                self.inventory()\n                continue\n\n            elif item_to_manage == 'e':\n                return\n\n            else:\n                continue\n\n    def blacksmith_main(self):\n        while True:\n            # you can make this into a dictionary, with each value being a function\n            # something like\n            # if blacksmith_choice in blacksmith_main_dict:\n            #   blacksmith_function = (blacksmith_main_dict[blacksmith_choice])\n            #   blacksmith_function()\n            # elif blacksmith_choice == 'e':\n            #   return\n            self.hud()\n            print(f\"(In Town, Blacksmith Shop)\")\n            print(f\"Lucino, the Fieldenberg blacksmith is here, hammering at his anvil.\\n\"\n                  f\"He notices you, grumbles, and continues hammering...\")\n            print(f\"Your gold: {self.gold} GP\")\n            blacksmith_choice = input(\n                \"(P)urchase items, (L)iquidate items, (M)anage your inventory items, \"\n                \"View (I)nventory, or (E)xit the blacksmith: \").lower()\n\n            if blacksmith_choice == 'p':\n                self.buy_blacksmith_items()\n                continue\n\n            elif blacksmith_choice == 'l':\n                self.sell_blacksmith_items()\n                continue\n\n            elif blacksmith_choice == 'm':\n                self.item_management_sub_menu()\n\n            elif blacksmith_choice == 'i':\n                self.inventory()\n                continue\n\n            elif blacksmith_choice == 'e':\n                return\n\n            else:\n                continue\n\n    def buy_blacksmith_items(self):\n        # create new instances of all objects:\n        short_axe = ShortAxe()\n        broad_sword = BroadSword()\n        great_sword = GreatSword()\n        elvish_great_sword = ElvishGreatSword()\n        quantum_sword = QuantumSword()\n        battle_axe = BattleAxe()\n        great_axe = GreatAxe()\n        elvish_great_axe = ElvishGreatAxe()\n        quantum_axe = QuantumAxe()\n        leather_armor = LeatherArmor()\n        studded_leather_armor = StuddedLeatherArmor()\n        scale_mail = ScaleMail()\n        half_plate = HalfPlate()\n        full_plate = FullPlate()\n        buckler = Buckler()\n        kite_shield = KiteShield()\n        quantum_tower_shield = QuantumTowerShield()\n        elven_boots = ElvenBoots()\n        ancestral_footsteps = AncestralFootsteps()\n        elven_cloak = ElvenCloak()\n\n        blacksmith_dict = {\n            'Weapons': [short_axe, broad_sword, great_sword, elvish_great_sword,\n                        quantum_sword, battle_axe, great_axe, elvish_great_axe, quantum_axe],\n            'Armor': [leather_armor, studded_leather_armor, scale_mail, half_plate, full_plate],\n            'Shields': [buckler, kite_shield, quantum_tower_shield],\n            'Boots': [elven_boots, ancestral_footsteps],\n            'Cloaks': [elven_cloak]\n        }\n        while True:\n            self.hud()\n            print(f\"Armory for sale:\")\n            # create a list of blacksmith item types:\n            item_type_lst = list(blacksmith_dict.keys())\n            # create a dictionary from list of blacksmith items types, print out, add 1 to indexing\n            item_type_dict = {}\n            for item_type in item_type_lst:\n                item_type_dict[item_type] = item_type_lst.index(item_type)\n            for key, value in item_type_dict.items():\n                print(value + 1, ':', key)\n            print(f\"Your gold: {self.gold} GP\")\n            buy_or_exit = input(\"Pick item type by number, Display your (I)nventory, or go (B)ack: \").lower()\n            # if buy_or_exit not in ('i', 'p', 'b'):\n            #    self.hud()\n            #    continue\n            if buy_or_exit == 'i':\n                self.inventory()\n                continue\n            elif buy_or_exit == 'b':\n                return\n            elif buy_or_exit not in ('i', 'b'):\n                try:\n                    item_type_index_to_buy = int(buy_or_exit)\n                    # item_type_index_to_buy = int(input(f\"Enter the number of the category of the item to buy: \"))\n                    item_type_to_buy = item_type_lst[item_type_index_to_buy - 1]\n                except (IndexError, ValueError):\n                    print(\"Invalid entry..\")\n                    sleep(1)\n                    continue\n                while True:\n                    self.hud()\n                    print(f\"{item_type_to_buy} for sale:\")\n                    item_dict = {}\n                    blacksmith_dict[item_type_to_buy].sort(key=lambda x: x.buy_price)\n                    for item in (blacksmith_dict[item_type_to_buy]):\n                        item_dict[item] = (blacksmith_dict[item_type_to_buy]).index(item)\n                    for key, value in item_dict.items():\n                        print(value + 1, ':', key)\n                    print(f\"Your gold: {self.gold} GP\")\n                    buy_or_exit = input(\"Pick item by number, Display your (I)nventory, or go (B)ack: \").lower()\n                    if buy_or_exit == 'i':\n                        self.inventory()\n                        continue\n                    elif buy_or_exit == 'b':\n                        break\n                    elif buy_or_exit not in ('i', 'b'):\n                        try:\n                            item_index_to_buy = int(buy_or_exit)\n                            item_index_to_buy -= 1  # again, indexing starts at 0 and is awkward\n                            sale_item = (blacksmith_dict[item_type_to_buy])[item_index_to_buy]\n                        except (IndexError, ValueError):\n                            print(\"Invalid entry..\")\n                            sleep(1)\n                            continue\n                        confirm_purchase = input(\n                            f\"Purchase {sale_item.name} for {sale_item.buy_price} GP (y/n)? \").lower()\n                        if confirm_purchase == 'y':\n                            if self.gold >= sale_item.buy_price:\n                                if self.level >= sale_item.minimum_level:\n                                    if not self.duplicate_item(sale_item.item_type, sale_item):\n                                        self.hud()\n                                        print(f\"You buy the {sale_item.name}\")\n                                        self.gold -= sale_item.buy_price\n                                        (self.pack[sale_item.item_type]).append(sale_item)\n                                        self.item_type_inventory(sale_item.item_type)\n                                        pause()\n                                        continue\n                                    else:\n                                        print(f\"You already have a {sale_item.name}\")\n                                        pause()\n                                        continue\n                                else:\n                                    print(f\"Minimum requirements not met.\")\n                                    pause()\n                                    continue\n                            else:\n                                print(\"You do not have enough gold.\")\n                                pause()\n                                continue\n                        else:\n                            continue\n\n    def item_management(self, item_type, current_item):\n        self.hud()\n        if len(self.pack[item_type]) > 0:\n            print(f\"Your current {item_type} inventory:\")\n            (self.pack[item_type]).sort(key=lambda x: x.buy_price)\n            item_mgmt_dict = {}\n            for item in (self.pack[item_type]):\n                item_mgmt_dict[item] = (self.pack[item_type]).index(item)\n            for key, value in item_mgmt_dict.items():\n                print(value + 1, ':', key)  # value is index. indexing starts at zero, so add 1\n            print()\n        else:\n            print(f\"You have nothing in your {item_type} inventory..\")\n            pause()\n            return\n        old_item = current_item\n        print(f\"You are currently using: \")\n        if item_type == 'Weapons':\n            print(f\"{self.wielded_weapon}, Sell Price: {self.wielded_weapon.sell_price} GP\")\n\n        elif item_type == 'Armor':\n            print(f\"{self.armor}, Sell Price: {self.armor.sell_price} GP\")\n\n        elif item_type == 'Shields':\n            if self.shield.name != 'No Shield':\n                print(f\"{self.shield}, Sell Price: {self.shield.sell_price} GP\")\n            else:\n                print(f\"{self.shield.name}\")\n        elif item_type == 'Boots':\n            print(f\"{self.boots}, Sell Price: {self.boots.sell_price} GP\")\n\n        elif item_type == 'Cloaks':\n            print(f\"{self.cloak}, Sell Price: {self.cloak.sell_price} GP\")\n        swap_or_exit = input(f\"(S)wap item, or go (B)ack: \").lower()\n        if swap_or_exit == \"b\":\n            return\n        elif swap_or_exit == \"s\":\n\n            try:\n                new_item_index = int(input(f\"Enter the number of the item from your inventory that you wish to use: \"))\n                new_item_index -= 1  # again, indexing starts at 0 so add 1\n                if item_type == 'Weapons':\n                    new_weapon = (self.pack[item_type])[new_item_index]  # SYNTAX FOR INDEX\n                    print(f\"{new_weapon}\")\n                    self.wielded_weapon = new_weapon\n                elif item_type == 'Armor':\n                    new_armor = (self.pack[item_type])[new_item_index]\n                    print(f\"{new_armor}\")\n                    self.armor = new_armor\n                elif item_type == 'Shields':\n                    new_shield = (self.pack[item_type])[new_item_index]\n                    print(f\"{new_shield}\")\n                    self.shield = new_shield\n                elif item_type == 'Boots':\n                    new_boots = (self.pack[item_type])[new_item_index]\n                    print(f\"{new_boots}\")\n                    self.boots = new_boots\n                elif item_type == 'Cloaks':\n                    new_cloak = (self.pack[item_type])[new_item_index]\n                    print(f\"{new_cloak}\")\n                    self.cloak = new_cloak\n                # CALCULATE STEALTH AND ARMOR CLASS. NOTICE INDENT\n                self.calculate_stealth()\n                self.calculate_armor_class()\n            except (IndexError, ValueError):\n                print(\"Invalid entry..\")\n                sleep(1)\n                return\n            print(f\"You are now using the {(self.pack[item_type])[new_item_index]}.\")\n            if old_item.name != 'No Shield':\n                print(f\"You place the {old_item.name} in your inventory.\")\n                (self.pack[item_type]).pop(new_item_index)  # INDEX SYNTAX\n                (self.pack[item_type]).append(old_item)  # old_weapon represents an object, not an index\n                # (self.pack[item_type]).sort(key=lambda x: x.buy_price)\n                pause()\n            else:\n                print(f\"You are well equipped.\")\n                pause()\n\n    def check_if_pack_empty(self):\n        non_empty_item_type_lst = []\n        for key in self.pack:\n            if len(self.pack[key]) > 0:\n                non_empty_item_type_lst.append(key)\n        number_of_items_in_pack = len(non_empty_item_type_lst)\n        if number_of_items_in_pack < 1:\n            return True\n        else:\n            return False\n\n    def sell_blacksmith_items(self):\n        # sell_blacksmith_items() allows you to sell items from self.pack\n        while True:\n            cls()\n            # self.hud()\n            # print(f\"You have items eligible to sell in the following categories:\")\n            non_empty_item_type_lst = []\n            # make a list of non-empty inventory item keys from player's pack inventory\n            for key in self.pack:\n                if len(self.pack[key]) > 0:\n                    non_empty_item_type_lst.append(key)\n            number_of_items_in_pack = len(non_empty_item_type_lst)\n            if number_of_items_in_pack < 1:\n                print(f\"Your pack is empty.\")\n                pause()\n                return\n\n            else:\n                # print(non_empty_item_type_lst)  # remove after testing\n                # make a dictionary from the non_empty item type list. index, and print\n                print(f\"You have items eligible to sell in the following categories:\")\n                item_type_dict = {}\n                for item_type in self.pack:\n                    if len(self.pack[item_type]) and item_type != 'Rings of Protection' and \\\n                            item_type != 'Rings of Regeneration':\n                        item_type_dict[item_type] = non_empty_item_type_lst.index(item_type)\n                for key, value in item_type_dict.items():\n                    print(value + 1, ':', key)\n\n                try:\n                    print(f\"Your gold: {self.gold} GP\")\n                    sell_or_exit = input(\"(S)ell items, (L)iquidate entire contents of pack, or go (B)ack: \").lower()\n                    if sell_or_exit not in ('s', 'l', 'b'):\n                        cls()\n                        # self.hud()\n                        continue\n                    if sell_or_exit == 'l':\n                        self.sell_everything()\n                        return\n                    if sell_or_exit == 'b':\n                        break\n                    item_type_index_to_sell = int(input(f\"Enter the number of the category of the item to sell: \"))\n                    item_type_to_sell = non_empty_item_type_lst[item_type_index_to_sell - 1]\n                except (IndexError, ValueError):\n                    print(\"Invalid entry..\")\n                    sleep(1)\n                    continue\n\n            while True:\n                cls()\n                # self.hud()\n                persistent_item_type = item_type_to_sell\n                print(f\"Your {item_type_to_sell} inventory eligible for sale:\")\n                # self.item_type_inventory(item_type_to_sell)\n                sell_all = []\n                mgmt_dict = {}\n                for item in (self.pack[item_type_to_sell]):\n                    mgmt_dict[item] = (self.pack[item_type_to_sell]).index(item)\n                for key, value in mgmt_dict.items():\n                    print(value + 1, ':', key.name, '- Sell price:', key.sell_price, 'GP')\n                    sell_all.append(key.sell_price)\n                gold_for_all_items = sum(sell_all)\n                if not len(sell_all):\n                    # if gold_for_all_items == 0:\n                    print(f\"You have no {item_type_to_sell} to sell.\")\n                    pause()\n                    break\n                else:\n                    print(f\"Total sell price for all {item_type_to_sell}: {gold_for_all_items} GP\")\n                print(f\"Your gold: {self.gold} GP\")\n                sell_or_exit = input(\n                    f\"Show entire (I)nventory, (S)ell an item, Sell (A)ll {item_type_to_sell} or go (B)ack: \").lower()\n                if sell_or_exit not in ('i', 's', 'a', 'b'):\n                    cls()\n                    # self.hud()\n                    continue\n                elif sell_or_exit == 'a':\n\n                    while True:\n                        yes_or_no = input(f\"Sell all {item_type_to_sell} for {gold_for_all_items} GP? (y/n)? \").lower()\n                        if yes_or_no not in ('y', 'n'):\n                            continue\n                        elif yes_or_no == 'y':\n                            print(f\"You sell all of your {item_type_to_sell} for {gold_for_all_items} GP.\")\n                            self.gold += gold_for_all_items\n                            (self.pack[item_type_to_sell]).clear()\n\n                            if self.check_if_pack_empty():\n                                print(f\"You have no more {persistent_item_type.lower()} to sell, and your pack is \"\n                                      f\"now completely empty.\")\n                                pause()\n                                return\n\n                            else:\n                                pause()\n                                break\n\n                        elif yes_or_no == 'n':\n                            break\n\n                elif sell_or_exit == 'i':\n                    self.inventory()\n                    continue\n\n                elif sell_or_exit == 'b':\n                    break\n\n                elif sell_or_exit == 's':\n\n                    try:\n\n                        item_index_to_sell = int(input(f\"Enter the number of the item you wish to sell: \"))\n                        item_index_to_sell -= 1  # again, indexing starts at 0 and is awkward\n                        sold_item = (self.pack[item_type_to_sell])[item_index_to_sell]\n                    except (IndexError, ValueError):\n                        print(\"Invalid entry..\")\n                        sleep(1)\n                        continue\n\n                    confirm_sale = input(f\"Sell the {sold_item.name} for {sold_item.sell_price} GP (y/n)? \").lower()\n                    if confirm_sale == 'y':\n                        print(f\"You sell the {sold_item.name} for {sold_item.sell_price} GP\")\n                        self.gold += sold_item.sell_price\n                        (self.pack[item_type_to_sell]).pop(item_index_to_sell)\n                        print(f\"Your gold: {self.gold} GP\")\n                        pause()\n                        cls()\n                        # self.hud()\n\n                        if len(self.pack[item_type_to_sell]) > 0:\n                            self.item_type_inventory(item_type_to_sell)\n                            print(f\"Your gold: {self.gold} GP\")\n                            sell_again = input(\n                                f\"(S)ell more {persistent_item_type} (B)ack to main market menu or \"\n                                f\"(E)xit to town: \").lower()\n\n                            if sell_again == 's':\n                                continue\n\n                            elif sell_again == 'b':\n                                break\n\n                            else:\n                                # if sell_again not in ('y', 'n'):\n                                return\n                        else:\n                            # print(f\"Your gold: {self.gold} GP\")\n                            if self.check_if_pack_empty():\n                                print(f\"You have no more {persistent_item_type.lower()} to sell, and your pack is \"\n                                      f\"now completely empty.\")\n                                pause()\n                                return\n                            else:\n                                print(f\"You have no more {persistent_item_type.lower()} to sell...\")\n                                pause()\n                                break\n                    else:\n                        continue\n\n    def sell_everything(self):\n        # this code took me many hours to come up with.\n        # allows for liquidation of self.pack\n        liquidate_lst = []\n        item_type_lst = ['Weapons', 'Armor', 'Shields', 'Boots', 'Cloaks']\n        mgmt_dict = {}\n        for each_category in item_type_lst:\n            if len(self.pack[each_category]):\n                for item in (self.pack[each_category]):\n                    mgmt_dict[item] = (self.pack[each_category]).index(item)\n        for key, value in mgmt_dict.items():\n            print(key.name, '- Sell price:', key.sell_price, 'GP')\n            liquidate_lst.append(key.sell_price)\n        total = sum(liquidate_lst)\n        print(f\"Total: {total}\")\n        confirm_liquidate = input(f\"Sell everything in your pack for {total} GP? \").lower()  # dungeoneer's pack\n        if confirm_liquidate == 'y':\n            for each_category in item_type_lst:\n                (self.pack[each_category]).clear()\n            print(f\"You sell your entire armory inventory for {total} GP.\")\n            self.gold += total\n            pause()\n            return\n        else:\n            return\n\n    def use_scroll_of_town_portal(self):\n        # called from main loop\n        if self.town_portals < 1:\n            self.hud()\n            print(f\"You have no scrolls of town portal!\")\n            sleep(1.25)\n            self.hud()\n            return False\n        else:\n            self.hud()\n            self.town_portals -= 1\n            random_floppy_rw_sound()\n            same_line_print(f\"The quantum portal appears before you; an impossible tunneling between distant \"\n                            f\"places..\")\n            dot_dot_dot(15)\n            sleep(1.5)\n            return True\n\n    def poison_ingestion(self):\n        # called from fountain_event(),\n        self.hud()\n        self.dot_multiplier = self.dungeon.level\n        self.dot_turns = dice_roll(1, 5)\n        rndm_poisoned_phrases = [\"You feel a disturbing weakness overcoming you..\",\n                                 \"An unnerving frailty spreads throughout your body...\",\n                                 \"Pain and tenderness courses through your body..\"\n                                 ]\n        poisoned_phrase = random.choice(rndm_poisoned_phrases)\n        print(f\"{poisoned_phrase}\")\n        sleep(1.5)\n        print(f\"You have been poisoned!\")\n        self.poisoned = True\n        self.poisoned_turns = 0\n        pause()\n        self.hud()\n        return self.poisoned\n\n    def drink_potion_of_strength(self):\n        self.hud()\n        rndm_drinking_phrases = [\n            \"Tilting it to your lips, you drain the tiny blue vial and the strength of giants surges through you!\",\n            \"Retrieving the vial from your belt, you pop the cork and down the sweet liquid...\\n\"\n            \"Great power and vitality  courses through your body!\",\n            \"No sooner is the tincture running down your throat, than does the great\\n\"\n            \"and overwhelming strength and vitality fill your body! You feel invincible!\"\n        ]\n        drink_phrase = random.choice(rndm_drinking_phrases)\n        if self.potions_of_strength > 0:\n            print(f\"{drink_phrase}\")\n            self.potion_of_strength_effect = True\n            self.potions_of_strength -= 1\n            self.potion_of_strength_uses = -1  # to compensate for end of turn calculation\n            if self.hit_points < self.maximum_hit_points:  # in the rare case player has hit point overage,\n                self.hit_points = self.maximum_hit_points  # this will not disrupt that advantage\n            pause()\n            return self.potion_of_strength_effect\n        else:\n            print(f\"You have no potions of giant strength!\")\n            sleep(1)\n            self.hud()\n            return False\n\n    def hint_event_1(self):\n        # hint_events move the story along by subtle hints to the player, revealed over time in the game, as\n        # they progress.\n        # hint_events take place in the tavern (so far). they correspond to boss_clues:\n        # hint_event_1 occurs after boss_clue_1, (which occurs after victory over dungeon exit boss lvl 1)\n        # hint_event_2 after boss_clue_2, etc. the boss_clues occur after defeating the dungeon_exit boss\n        # hint_event_1 is a meeting with vozzbozz, introduction to tor'bron the barbarian, and another hint\n        # about the symbol of the wicked queen, which the player finds during boss_clue_1\n        cls()\n        print(f\"As soon as she sees you, Jenna motions discreetly toward the hallway leading away from the bar.\")\n        sleep(1)\n        print(f\"You direct your eyes that way and casually make your way down the hall...\")\n        sleep(1)\n        pause()\n        cls()\n        print(f\"Jenna catches up to you at end of the hallway. Ye are {self.name}, are ye not?'\\n\"\n              f\"Nodding and instinctively looking about for eavesdroppers, you re-focus on her concerned look.\")\n        if len(self.vanquished_foes):\n            vanquished_foes = convert_list_to_string_with_commas_only(self.vanquished_foes)\n            print(f\"'I know of ye.' Your puzzled look speaks for you, as she continues,\\n\"\n                  f\"'We 'ave 'eard of it.. how ye' 'ave defeated {vanquished_foes}...and others!'\")\n        pause()\n        cls()\n        teletype(f\"'There is somethin' ye should know!' Her level of anxiety gives you pause; it seems out of\\n\"\n                 f\"character for her.\\n'Ye should seek out Vozzbozz!' Pausing with a far away look, she nods.\\n\"\n                 f\"'I'm headin' back to the bar, and we'll make like we never spoke o' this..'\\n\"\n                 f\"'Vozzbozz is in the barroom. He's the one with the raven on 'is shoulder!'\\n\"\n                 f\"The meeting ends as abruptly as it began. Jenna disappears toward the bar as you slowly\\n\"\n                 f\"start to follow a good distance behind, impatient and confused.\\n\")\n        pause()\n        cls()\n        # meeting with vozzbozz and introduction to tor'bron\n        teletype_txt_file('hint_event_1.txt')\n        pause()\n        cls()\n\n        # print picture of vozzbozz\n        print_txt_file('vozzbozz.text')\n        pause()\n        cls()\n\n        teletype_txt_file('hint_event_1b.txt')\n        pause()\n        cls()\n        teletype(f\"{self.name},\\nThe guardian of {self.dungeon.name} has, in its possession, an ornate dagger \"\n                 f\"of very fine craftsmanship.\\nIt is imperative you retrieve it. Return here with it so that \"\n                 f\"matters may progress.\\n\"\n                 f\"\\n                                                     -V\\n\")\n        self.boss_hint_1_event = True\n        pause()\n        return\n\n    def hint_event_2(self):\n        print(f\"As soon as she sees you, Jenna directs your attention to the opposite side of the room by raising\\n\"\n              f\"her chin in that general direction.\\nAt the very same booth as last time, sits the hulking barbarian, \"\n              f\"Tor'bron.\")\n        sleep(2)\n        pause()\n        cls()\n        print_txt_file('torbron.txt')\n        pause()\n        cls()\n\n        if self.sikira_ally:\n            print(f\"Both you and Si'Kira turn to behold him. With a curt slap on the back, Si'Kira says, 'Good \"\n                  f\"luck, {self.name}! From the looks of him, you'll need it!'\\nShe leaves your side and makes for \"\n                  f\"the bar.\")\n            pause()\n            cls()\n        print(f\"You cautiously approach him...\")\n        sleep(1)\n        pause()\n        cls()\n        teletype(f\"'Well! {self.name}!', he bellows in his booming voice. 'Sit!' Something in his dour demeanor\\n\"\n                 f\"tells you it is not an invitation, but an order. You marvel at the size and strength of the man.\\n\"\n                 f\"His jet black hair is slicked back on his head, and covers his body in a wiry patchwork.\\n\"\n                 f\"His long beard a strong jawbone, and his deep-set amber eyes burn with gripping intensity.\\n\"\n                 f\"'And where is it? Do you have it?', he asks, his tone tense and distrustful.\\n\"\n                 f\"You carefully retrieve the dagger and pass it to him across the table. Roughly and without \"\n                 f\"regard,\\n\"\n                 f\"he swipes it from you, yanks it from its sheath and launches it across the room, over the heads\\n\"\n                 f\"of all the patrons on this side of the bar, until it abruptly lodges in the wall with a bang.\")\n        pause()\n        cls()\n\n\n        if len(self.vanquished_foes):\n            vanquished_foes = convert_list_to_string_with_commas_only(self.vanquished_foes)\n            teletype(f\"'The slayer of {vanquished_foes}...\\n...and others besides!'\\n\")\n        teletype(f\"'When first I saw you, I was...', he searches for the word. '..skeptical!'\\n\"\n                 f\"But now, things are different! Now I know you are able-bodied and strong! Good! Very good, this!' \"\n                 f\"He nods.\\n\"\n                 f\"A sting of disrespect hits you. After the toil and struggle to retrieve the prized dagger, \"\n                 f\"you are\\n\"\n                 f\"now realizing it was nothing more than a test to prove your mettle to this stranger!\\n\"\n                 f\"'You must be Tor'bron!', you say as you slide into the booth. His eyes\\n\"\n                 f\"narrow slightly and he takes a sip of ale. Continuing, you say, 'I heard Vozzbozz address you\\n\"\n                 f\"the last time we saw each other. And may I add, I never doubted *your* abilities!'\\n\"\n                 f\"Still alert, he thinks about your words. His glowering slowly turns to what must be a smile.\\n\"\n                 f\"Then, he laughs, a deep and hearty laugh. Instantly, he fiercely slams the table with his fist,\\n\"\n                 f\"so that the entire room shakes and becomes silent. He raises his huge hand, pointing\\n\"\n                 f\"straight at you. 'Good! Don't ever doubt them!' And again he smiles and laughs as the tavern \"\n                 f\"ambience\"\n                 f\"\\ngradually returns. Reaching his tree-trunk arm toward you, he slams you on the shoulder with a\"\n                 f\" heavy hand.\\n\"\n                 f\"You are thankful for the {self.armor.name.lower()} you wear; without it, the blow would \"\n                 f\"undoubtedly \"\n                 f\"have been an injury!\\nInstinctively reaching for the aching shoulder, you reply plainly, \"\n                 f\"'I certainly will not..'\\n\")\n        pause()\n        cls()\n        # meet Tor'bron, get hints\n        teletype_txt_file('hint_event_2.txt')\n        pause()\n        cls()\n\n        self.boss_hint_2_event = True\n        return\n\n    def hint_event_3(self):\n        # another meeting with vozzbozz. meet Magnus the dwarf\n        print(f\"Upon entering, you are met with the familiar sites, sounds and smells of the inn. Scanning the bar\\n\"\n              f\"area, you immediately notice the nasty-looking knife, still lodged in the wall. Before you even have\\n\"\n              f\"time to react, Lazarus swiftly lands on your shoulder. 'The master awaits you!', he says plainly,\\n\"\n              f\"in his smooth tone. Off to your left, Vozzbozz sits in his regular booth, across from a proud-looking\\n\"\n              f\"and rather stout dwarf.\")\n        sleep(1)\n        if self.sikira_ally:  # this conditional is actually unnecessary, since Sikira is encountered before this point\n            print(f\"'Your friends await you.', says Si'Kira with disinterest.\\n\"  # disinterested means neutral \n                  f\"'Join us, will you?', you ask, invitingly, as you gesture to the booth.\\n\"\n                  f\"Shaking her head and striding toward the bar she says, 'I choose my own friends.'\")\n            pause()\n            cls()\n\n        print(f\"You approach the booth, and as you arrive, Lazarus deftly glides to Vozzbozz' shoulder.\")\n        pause()\n        cls()\n        if self.armor.ac > 11:\n            print(f\"The heavily-armored dwarf looks at you seemingly uninterested and simply says,\\n\"\n                  f\"That be some decent {self.armor.name.lower()} ye got there, lad'. He takes a sip of his ale.\")\n        print(f\"The dwarf slides out of the booth and motions that you should take his place. He then slides in next\\n\"\n              f\"to Vozzbozz and across from you.\\n\")\n        print(f\"'Ah, {self.name}! Meet my good friend, Magnus Stormbringer.', says Vozzbozz curtly. \"\n              f\"The dwarf promptly reaches his\\n\"\n              f\"hand across the table and takes yours with a firm, brief grip and a nod.\\n\"\n              f\"'Well met', he says, sincerely, in an alarmingly deep voice.\")\n        pause()\n        cls()\n        print_txt_file('magnus.txt')\n        pause()\n        cls()\n        # another meeting, get hints\n        teletype_txt_file('hint_event_3.txt')\n        pause()\n        cls()\n        if self.sikira_ally:  # this conditional is actually unnecessary, since Sikira is encountered before this point\n            # it just feels right to include it\n            teletype(f\"'The Dark She-Elf makes five..', interjects the bird.\\n\"\n                     f\"Magnus briefly looks at Lazarus, and you suddenly deduce it has been the raven who has been \"\n                     f\"eavesdropping in the dungeon\\ndepths below and reporting on your victories all this time.\\n\"\n                     f\"Motioning to Si'Kira, he says, 'Ye think yer friend there will lend her sword?'\\n\" \n                     f\"With a smirk, you respond immediately, 'Without a doubt.'\\n\")\n\n        teletype(f\"Magnus looks at you gravely. 'We will be meeting with Tor'Bron outside, and then joining \"\n                 f\"you in the depths presently!'\\n\"\n                 f\"'Well then, until we meet again..', you say, draining your mug.\\n\"\n                 f\"'Until then!', your companions say in unison as they drink. You rise to your feet and \"\n                 f\"approach the bar.\\n\")\n        pause()\n        cls()\n        if self.sikira_ally:  # same as above\n            print(f\"With a tall mug in a smooth, slender hand, Si'Kira remarks, 'That was quick. I have not yet \"\n                  f\"finished my ale!'\\nYou ignore the pressing urgency which weighs on you and respond, 'Please, \"\n                  f\"take your time. In fact, I will join you.'\\nJenna glides over and slams a mug on the bar. \"\n                  f\"You regard your beautiful companion for a moment,\\nand try to ignore the hint of suspicion \"\n                  f\"surrounding her. Thus far she has been a worthy ally,\\nbut you remain unsure about completely \"\n                  f\"trusting her.\\n\"\n                  f\"She notices you staring, and her prepossessing red eyes light up. You share a drink, and a smile,\\n\"\n                  f\"and forget, for a little while..\\n\")\n            pause()\n            cls()\n        self.boss_hint_3_event = True\n        return\n\n    def hint_event_logic(self):\n        # called from tavern()\n        if self.boss_hint_1 and not self.boss_hint_1_event:\n            self.hint_event_1()\n            return\n        if self.boss_hint_2 and not self.boss_hint_2_event:\n            self.hint_event_2()\n            return\n        if self.boss_hint_3 and not self.boss_hint_3_event:\n            self.hint_event_3()\n            return\n\n    def jennas_level_1_gab(self, opening_phrase):\n        if self.town_portal_exists:\n            opening_phrase = f\"'Feelin' chatty, love?', queries Jenna in a coy tone.\\nI've 'eard ye entered\" \\\n                             f\" town through a portal. 'Tis good, sir. 'Cept a word o' caution:\\n\" \\\n                             f\"Make good use of yer time here while it's open. Ye don't want ta be wastin' yer\\n\" \\\n                             f\"portals, seein' as scrolls can be rare!\"\n        teletype(f\"{opening_phrase}\\n\")\n        treasure_chest_discovery = f\"level {self.dungeon.level} treasure chest\"\n        if treasure_chest_discovery not in self.discovered_interactives:\n            teletype(f\"She continues, '{self.dungeon.name} is full of dangers for the \"\n                     f\"unwary,\\n\"\n                     f\"but there are treasures to be had as well. 'Tis said that there be a pit below the \"\n                     f\"dungeon\\n\"\n                     f\"where ye may find gold, but it be full of monsters, traps, and fiends. Search carefully\\n\"\n                     f\"and thoroughly if ye venture there!'\\n\")\n        else:\n            teletype(f\"With a big, welcoming smile, she says, 'I 'eard it said ye 'ave found treasure in the \"\n                     f\"pit below {self.dungeon.name}!'\\n\"\n                     f\"'Care to spend some o' that loot?', she adds with a wink.\")\n\n        \"\"\"micro_boss_discovery = f\"level {self.dungeon.level} micro boss\"\n        if micro_boss_discovery not in self.discovered_interactives:\n            teletype(f\"Lowering her tone, she goes on, 'I've also 'eard it said that there's an elite enemy\\n\"\n                     f\"down there, just waitin' for unsuspectin' adventurers in a dead ended corridor!'\\n\"\n                     f\"'Take good care, now, and be wise!'\\n\")\"\"\"\n        pause()\n\n    def talk_to_jenna(self):  # expand these statements for immersive realism\n        cls()\n        opening_phrase = f\"'Feelin' chatty, love?', queries Jenna in a coy tone.\"\n        random_jenna_business = [f\"'I'm a bit busy, here, love..'\\n\", f\"'There's always loot to be found in the \"\n                                 \"dungeons. Ye can sell what ye don't need, here in town!'\\n\",\n                                 f\"'The Sauengard dungeons \"\n                                 \"were once part of a magnificent kingdom many years ago; Before it became overrun \"\n                                 \"by fiends, brigands and the undead.'\\n\", f\"'Working on yer Charisma will give ye a \"\n                                 \"better chance for positive outcomes with monsters!'\\n\", f\"'Gaining Constitution \"\n                                 f\"will help ye resist poison and necrosis.\\nIt also will gain ye hit points and \"\n                                 f\"resist paralyzing effects!'\\n\",\n                                 f\"'Wisdom is important for procuring the Weirdness fer Quantum effects, and will \"\n                                 f\"become more important as you progress.'\\n\", f\"'Protection from Evil helps ye \"\n                                 f\"resist the Quantum Attacks and Paralyzing effects of monsters.'\\n\",\n                                 f\"'Acumen enhances many things, including initiative, melee\"\n                                 f\" attacks, and Quantum Effects.\\nAcumen will increase with your experience \"\n                                 f\"level.'\\n\", f\"'I heard about ancient religious altars in the dungeons.\\nThey say \"\n                                 f\"ye must be strong if ye plan on demolishing them!'\\n\"]\n        if self.dungeon.level == 1:\n            self.jennas_level_1_gab(opening_phrase)\n        else:\n            teletype(random.choice(random_jenna_business))\n            pause()\n\n    def tavern(self):\n        # called from town_navigation()\n        self.hud()\n        print(f\"You have come upon the Slumbering Bear Inn- a handsome building with all the trimmings and character\\n\"\n              f\"one would expect of a tavern in a town such as this. Above the door hangs an angled sign\\n\"\n              f\"with *THE SLUMBERING BEAR* printed above an angry, roaring bear that appears to be \"\n              f\"anything but sleepy...\")\n        pause()\n        # tavern_theme()\n        self.hint_event_logic()\n        while True:\n            self.hud()\n\n            if self.boss_hint_1:\n                print(f\"(In Town, The Slumbering Bear Inn)\")\n                print(f\"Jenna catches your gaze and nods discreetly. 'Let me know if ye be needin' anything, love.'\")\n\n            else:\n                print(f\"The barroom is bustling as always, but Jenna, the barkeep, notices you and calls over,\\n\"\n                      f\"very matter-of-factly, \\\"What do ye be needin' love?\\\"\")\n\n            inn_choice = input(f\"(R)oom for the evening - 10 GP\\n(T)alk to Jenna\\n(S)ave Character to disk\\n\"\n                               f\"(E)xit the inn\\n\"\n                               f\"--> \").lower()\n\n            if inn_choice == 'r':\n\n                if self.hit_points < self.maximum_hit_points or self.quantum_units < self.maximum_quantum_units \\\n                        or self.necrotic or self.poisoned:\n                    self.hud()\n\n                    if self.gold >= 10:\n                        self.gold -= 10\n                        print(f\"You find your way to your room, which is upstairs. \"\n                              f\"The accommodations are clean, tidy and welcoming.\")\n                        sleep(1)\n                        print(\n                            f\"Removing your armor and accoutrements, you wash up and fall into a deep, restful sleep.\")\n                        sleep(1)\n                        print(f\"Your body and mind feel better.\")\n                        sleep(1)\n\n                        if self.hit_points < self.maximum_hit_points:\n                            self.hit_points = self.maximum_hit_points\n                        self.recover_quantum_energy()\n                        self.poisoned = False\n                        self.poisoned_turns = 0\n                        self.necrotic = False\n                        self.necrotic_turns = 0\n                        self.potion_of_strength_effect = False\n                        self.potion_of_strength_uses = 0\n                        self.quantum_strength_effect = False\n                        self.quantum_strength_uses = 0\n                        self.protection_effect = False\n                        self.protection_effect_uses = 0\n                        self.end_of_turn_calculation()\n                        continue\n\n                    else:\n                        print(f\"You do not have enough gold!\")\n                        pause()\n                        continue\n\n                else:\n                    self.hud()\n                    print(f\"Jenna chuckles as she shakes her head at you. \\\"Ye are in the pink, love!\\\"\\n\"\n                          f\"\\\"What ye be needin' a room fer?\\\" She hurries off to her busy routines...\")\n                    sleep(1.5)\n                    print(f\"You realize she's right! You are in perfect condition!\")\n                    pause()\n                    continue\n\n            elif inn_choice == 't':\n                self.hud()\n                self.talk_to_jenna()\n                continue\n\n            elif inn_choice == 's':\n                self.save_character()\n                continue\n\n            elif inn_choice == 'e':\n                self.hud()\n                print(f\"You walk out the door, but not before turning to see Jenna's wink and bright smile.\\n\"\n                      f\"'Don't be a stranger, now, love! Ye are always welcome!'\")\n                sleep(1.25)\n                pause()\n                return\n\n            else:\n                continue\n\n    def recover_quantum_energy(self):\n        # called from fountain_event() and tavern()\n        if self.quantum_units < self.maximum_quantum_units:\n            self.quantum_units = self.maximum_quantum_units\n            print(f\"Your Quantum Energy is restored!\")\n        else:\n            print(f\"You are refreshed.\")\n        pause()\n        return\n\n    def drink_antidote(self):\n        # called from main loop\n        if self.antidotes > 0:\n            self.hud()\n            if not self.poisoned:\n                print(f\"You are not poisoned!\")\n                sleep(1)\n                self.hud()\n                return False  # false means you do NOT use a turn\n            else:\n                print(f\"You retrieve the amber vial from your belt and eagerly drain its contents into your mouth...\")\n                sleep(2)\n                self.antidotes -= 1\n                self.hud()\n                print(f\"You feel a vibrant sensation..\")\n                sleep(1)\n                self.poisoned = False\n                self.poisoned_turns = 0\n                print(f\"The poison has left your body..\")\n                sleep(1)\n\n                pause()\n                return True  # True means you DO use a turn\n        else:\n            print(f\"You have no vials of antidote!\")\n            sleep(1)\n            self.hud()\n            return False  # False means you do NOT use a turn\n\n    def drink_elixir(self):\n        # called from main loop\n        if self.elixirs > 0:\n            self.hud()\n            if not self.necrotic:\n                print(f\"Your flesh is not corrupted!\")\n                sleep(1)\n                self.hud()\n                return False  # false means you do NOT use a turn\n            else:\n                print(f\"You retrieve the emerald vial from your belt and eagerly drain its contents into your mouth...\")\n                sleep(2)\n                self.elixirs -= 1\n                self.hud()\n                print(f\"You feel a cleansing of the flesh..\")\n                sleep(1)\n                self.necrotic = False\n                self.necrotic_turns = 0\n                print(f\"The foul corruption leaves your body..\")\n                sleep(1)\n                pause()\n                return True  # True means you DO use a turn\n        else:\n            print(f\"You have no elixirs!\")\n            sleep(1)\n            self.hud()\n            # pause()\n            return False  # False means you do NOT use a turn\n\n    def drink_healing_potion(self):\n        # called from main loop\n        self.hud()\n        if self.potions_of_healing > 0:\n\n            if self.hit_points >= self.maximum_hit_points:\n                print(f\"You are already at maximum health!\")\n                sleep(1)\n                self.hud()\n                return False  # False means you don't waste a turn\n            else:\n                print(f\"You retrieve the vial from your belt and eagerly drain its contents into your mouth...\")\n                sleep(2)\n                self.potions_of_healing -= 1\n                # number_of_dice = (1 + self.level)\n                # heal = dice_roll(number_of_dice, 4) + number_of_dice\n                heal = math.ceil(self.maximum_hit_points * .66)\n                print(f\"You heal {heal} hit points\")  # remove after testing\n                self.hit_points += heal\n                if self.hit_points > self.maximum_hit_points:\n                    self.hit_points = self.maximum_hit_points\n                self.hud()\n                print(f\"Your vitality increases.\")\n                sleep(1)\n                pause()\n                return True  # True means you use up a turn\n        else:\n            print(\"You have no potions of healing!\")\n            sleep(1)\n            self.hud()\n            return False  # False means you don't waste a turn\n\n    def duplicate_item(self, item_type, possible_duplicate):\n        # check if an item is a duplicate of an item in player's pack:\n        duplicate_item_name_lst = []\n        inv_dict = Counter(item for item in self.pack[item_type])\n        # print(inv_dict)  # for testing\n        for key, value in inv_dict.items():\n            duplicate_item_name_lst.append(key.name)\n        # print(duplicate_item_name_lst)  # for testing\n        if possible_duplicate.name in duplicate_item_name_lst or \\\n                possible_duplicate.name == self.wielded_weapon.name or \\\n                possible_duplicate.name == self.armor.name or \\\n                possible_duplicate.name == self.shield.name or \\\n                possible_duplicate.name == self.boots.name:\n            return True\n        else:\n            return False\n\n    def item_type_inventory(self, item_type):  # list items in inventory by type\n\n        if item_type != 'Town Portal Implements' and item_type != 'Elixirs' \\\n                and item_type != 'Potions of Strength' and item_type != 'Healing' \\\n                and item_type != 'Antidotes':  # if item not in belt inventory\n            print(f\"Your {item_type}:\")\n            self.pack[item_type].sort(key=lambda x: x.name)\n            stuff_dict = Counter(item.name for item in self.pack[item_type])\n            for key, value in stuff_dict.items():\n                # print(key, ':    ', value, sep='')\n                if value > 1:\n                    print(value, ' ', key, 's', sep='')\n                    # print(key, 's', ':    ', value, sep='')\n                else:\n                    print(value, ' ', key, sep='')\n            number_of_items = len(self.pack[item_type])\n            # print(f\"You now have {number_of_items} items in your {item_type} inventory.\")\n            if number_of_items:\n                return True\n            else:\n                # print(f\"You currently have no {item_type} in your inventory.\")\n                return False\n        elif item_type == 'Town Portal Implements':\n            if self.town_portals > 0:\n                print(f\"You have {self.town_portals} Scrolls of Town Portal\")\n                return True\n            else:\n                print(f\"You have no scrolls of town portal.\")\n                return False\n        elif item_type == 'Potions of Strength':\n            if self.potions_of_strength > 0:\n                print(f\"You have {self.potions_of_strength} Potions of Strength\")\n                return True\n            else:\n                print(f\"You have no Potions of Strength.\")\n                return False\n        elif item_type == 'Healing':\n            if self.potions_of_healing > 0:\n                print(f\"You have {self.potions_of_healing} Potions of Healing\")\n                return True\n            else:\n                print(f\"You have no potions of healing.\")\n                return False\n        elif item_type == 'Elixirs':\n            if self.elixirs > 0:\n                print(f\"You have {self.elixirs} Clarifying Quantum Elixirs\")\n                return True\n            else:\n                print(f\"You have no Elixirs.\")\n                return False\n        elif item_type == 'Antidotes':\n            if self.antidotes > 0:\n                print(f\"You have {self.antidotes} Vials of Antidote\")\n                return True\n            else:\n                print(f\"You have no Vials of Antidote.\")\n                return False\n\n    def inventory(self):\n        self.hud()\n        print(\n            f\"You are wielding: \\nA {self.wielded_weapon.name}. Damage bonus: {self.wielded_weapon.damage_bonus}, \"\n            f\"To-hit bonus: {self.wielded_weapon.to_hit_bonus}\")\n        if self.shield.name != 'No Shield':\n            print(f\"A {self.shield.name}. Armor class: {self.shield.ac}\")\n        print(\n            f\"You are wearing:\\n{self.armor.name}. Armor class: {self.armor.ac}, Armor bonus: {self.armor.armor_bonus}\")\n        print(f\"{self.cloak.name}. Stealth: {self.cloak.stealth}\")\n        if self.ring_of_reg.name != \"No Ring of Regeneration\":\n            print(f\"A Ring of Regeneration + {self.ring_of_reg.regenerate}\")\n        if self.ring_of_prot.name != \"No Ring of Protection\":\n            print(f\"A Ring of Protection + {self.ring_of_prot.protect} \")\n        print(f\"On your belt, you are carrying:\")\n        print(f\"A coil of rope\")  # like indiana jones and his whip.\n        belt = [self.town_portals, self.potions_of_healing, self.potions_of_strength, self.elixirs, self.antidotes]\n        if sum(belt) > 0:\n            if self.potions_of_strength > 0:\n                print(f\"{self.potions_of_strength} Potions of Strength\")\n            if self.potions_of_healing > 0:\n                print(f\"{self.potions_of_healing} Potions of Healing\")\n            if self.town_portals > 0:\n                print(f\"{self.town_portals} Town Portal Scrolls\")\n            if self.elixirs > 0:\n                print(f\"{self.elixirs} Clarifying Elixirs\")\n            if self.antidotes > 0:\n                print(f\"{self.antidotes} Vials of Antidote\")\n\n        item_type_lst = ['Weapons', 'Armor', 'Shields', 'Boots', 'Cloaks']\n        print(f\"Your pack contains:\")  # dungeoneer's pack\n\n        current_items = []\n        for each_item in item_type_lst:\n            if len(self.pack[each_item]) > 0:\n                current_items.append(each_item)\n                self.item_type_inventory(each_item)  # call item_type_inventory() for each item in inv.\n                # print(current_items)  # for testing\n        if not len(current_items):\n            print(f\"Nothing but cobwebs..\")\n            pause()\n            return\n        else:\n            pause()\n            return\n\n    def found_weapon_substitution(self, found_item):\n        if self.wielded_weapon.damage_bonus < (self.level * 2) or self.wielded_weapon.to_hit_bonus < 3:\n            # found_item.damage_bonus = self.level\n            if found_item.name == self.wielded_weapon.name:\n                if self.wielded_weapon.damage_bonus < (self.level * 2):\n                    self.wielded_weapon.damage_bonus += 1  # = found_item.damage_bonus + 1\n                    print(f\"Quantum Weirdness fills the air...\\nYour {self.wielded_weapon.name} \"\n                          f\"damage bonus is enhanced to + {self.wielded_weapon.damage_bonus}!\")\n                    pause()\n                    return\n                elif self.wielded_weapon.to_hit_bonus < 3:\n                    self.wielded_weapon.to_hit_bonus += 1  # = found_item.damage_bonus + 1\n                    print(f\"Quantum Weirdness fills the air...\\nYour {self.wielded_weapon.name} \"\n                          f\"to-hit bonus is enhanced to + {self.wielded_weapon.to_hit_bonus}!\")\n                    pause()\n                    return\n            else:\n                print(f\"You have found {found_item.a_an} {found_item.name}. Damage bonus: {found_item.damage_bonus}. \"\n                      f\"To-hit bonus: {found_item.to_hit_bonus}.\")\n                print(f\"You are currently wielding a {self.wielded_weapon.name}. \"\n                      f\"Damage bonus: {self.wielded_weapon.damage_bonus}. \"\n                      f\"To-hit bonus: {self.wielded_weapon.to_hit_bonus}.\")\n            while True:\n                replace_weapon = input(f\"Do you wish to wield the {found_item.name} instead? y/n: \").lower()\n                if replace_weapon == 'y':\n                    old_weapon = self.wielded_weapon\n                    self.wielded_weapon = found_item\n                    print(f\"You are now wielding the {found_item.name}\")\n                    print(f\"Damage bonus: {self.wielded_weapon.damage_bonus}. \"\n                          f\"To-hit bonus: {self.wielded_weapon.to_hit_bonus}\")\n                    if not self.duplicate_item(old_weapon.item_type,\n                                               old_weapon):  # old_weapon not in self.pack['Weapons']:\n                        (self.pack[found_item.item_type]).append(old_weapon)\n                        print(f\"You place the {old_weapon.name} upon your back..\")\n\n                    else:\n                        print(f\"You drop the {old_weapon.name}.\")\n                    pause()\n                    return\n                elif replace_weapon == 'n':\n                    if not self.duplicate_item(found_item.item_type,\n                                               found_item):\n                        (self.pack[found_item.item_type]).append(found_item)\n                        print(f\"You place the {found_item.name} on your back.\")\n                    else:\n                        print(f\"You choose not to wield the {found_item.name}, but you cannot carry any more weapons \"\n                              f\"of this type. You leave it.\")\n                    pause()\n                    return False\n                elif replace_weapon not in (\"y\", \"n\"):\n                    continue\n        else:\n            # print(f\"Wielded_weapon.damage_bonus already >= self.level * 2 and/or, to-hit == 3!!!\")  # rm after testing\n            # pause()  # remove after testing\n            return\n\n    def found_armor_substitution(self, found_item):\n        # ADD armor_bonus FOR FOUND PLATE ARMOR AFTER PLAYER REACHES CERTAIN LEVEL?\n        if (self.armor.ac + self.armor.armor_bonus) < (found_item.ac + found_item.armor_bonus):\n            print(f\"You have found {found_item.name}!! Armor Class: {found_item.ac}\")\n            if self.armor.armor_bonus > 0:\n                print(f\"Your current {self.armor.name} Armor Class: {self.armor.ac}, Bonus: +{self.armor.armor_bonus}\")\n            else:\n                print(f\"Your current {self.armor.name} Armor Class: {self.armor.ac}\")\n\n            while True:\n                replace_armor = input(f\"Do you wish to wear the {found_item.name} instead? y/n: \").lower()\n                if replace_armor == 'y':\n                    old_armor = self.armor\n                    self.armor = found_item\n                    print(f\"You are now wearing the {found_item.name}\")\n                    self.calculate_armor_class()\n                    if not self.duplicate_item(found_item.item_type, old_armor):\n                        (self.pack[found_item.item_type]).append(old_armor)\n                        print(f\"You place the {old_armor.name} in your pack..\")\n                    else:\n                        print(f\"You drop your {old_armor.name}.\")\n                    pause()\n                    return\n                elif replace_armor == 'n':\n                    print(f\"You choose not to wear the {found_item.name}.\")  # remove after testing\n                    if not self.duplicate_item(found_item.item_type, found_item):\n                        (self.pack[found_item.item_type]).append(found_item)\n                        print(f\"You place the {found_item.name} in your pack.\")\n\n                    else:\n                        print(f\"However, you cannot carry any more armor of this type. You leave it.\")\n                    pause()\n                    return\n\n                elif replace_armor not in (\"y\", \"n\"):\n                    continue\n        else:\n            # print(f\"Worn armor ac + armor_bonus >= found item...\")  # remove after testing\n            # pause()  # remove after testing\n            return\n\n    def found_shield_substitution(self, sub_item):\n        if self.shield.ac < sub_item.ac:\n            print(f\"You have found {sub_item.a_an} {sub_item.name}!! Armor Class: {sub_item.ac}\")\n            if self.shield.name == 'No Shield':\n                print(f\"You currently hold no shield in your off hand.\")\n            else:\n                print(f\"Your current {self.shield.name} Armor Class: {self.shield.ac}\")\n            while True:\n                replace_shield = input(f\"Do you wish to wield the {sub_item.name} instead? y/n: \").lower()\n                if replace_shield == 'y':\n                    old_shield = self.shield\n                    self.shield = sub_item\n                    print(f\"You are now wielding the {sub_item.name}\")\n                    self.calculate_armor_class()\n                    if old_shield.name == 'No Shield':\n                        pause()\n                        return\n                    elif not self.duplicate_item(old_shield.item_type,\n                                                 old_shield):  # old_shield not in self.pack[found_item.item_type]:\n                        (self.pack[sub_item.item_type]).append(old_shield)\n                        print(f\"You place the {old_shield.name} on your back..\")\n                    else:\n                        print(f\"You drop the old {old_shield.name}.\")\n                    pause()\n                    return\n                elif replace_shield == 'n':\n                    print(f\"You choose not to wield the {sub_item.name}.\")\n                    if not self.duplicate_item(sub_item.item_type,\n                                               sub_item):  # found_item not in self.pack[found_item.item_type]:\n                        (self.pack[sub_item.item_type]).append(sub_item)\n                        print(f\"You place the {sub_item.name} on your back.\")\n\n                    else:\n                        print(f\"However, you cannot carry any more shields of this type. You leave it.\")\n                    pause()\n                    return\n                elif replace_shield not in (\"y\", \"n\"):\n                    continue\n        else:\n            # print(f\"Wielded shield >= found item...\")  # remove after testing\n            # pause()  # remove after testing\n            return\n\n    def found_boots_substitution(self, found_item):\n        # ADD armor_bonus FOR FOUND PLATE ARMOR AFTER PLAYER REACHES CERTAIN LEVEL?\n        if self.boots.ac < found_item.ac:\n            print(f\"You have found a pair of {found_item.name}!! Armor Class: {found_item.ac}\")\n            print(f\"Your current {self.boots.name} Armor Class: {self.boots.ac}\")\n            while True:\n                replace_boots = input(f\"Do you wish to wear the {found_item.name} instead? y/n: \").lower()\n                if replace_boots == 'y':\n                    old_boots = self.boots\n                    self.boots = found_item\n                    print(f\"You are now wearing the {found_item.name}\")\n                    self.calculate_armor_class()\n                    if not self.duplicate_item(old_boots.item_type,\n                                               old_boots):  # old_boots not in self.pack[found_item.item_type]:\n                        (self.pack[found_item.item_type]).append(old_boots)\n                        print(f\"You place the {old_boots.name} in your pack..\")  # dungeoneer's pack\n\n                    else:\n                        print(f\"You drop your {old_boots.name}.\")\n                    pause()\n                    return\n                elif replace_boots == 'n':\n                    print(f\"You choose not to wear the {found_item.name}.\")  # remove after testing\n                    if not self.duplicate_item(found_item.item_type,\n                                               found_item):  # found_item not in self.pack[found_item.item_type]:\n                        (self.pack[found_item.item_type]).append(found_item)\n                        print(f\"You place them in your pack.\")  # dungeoneer's pack\n\n                    else:\n                        print(f\"However, you cannot carry any more boots like this. You leave them.\")\n                    pause()\n                    return\n                elif replace_boots not in (\"y\", \"n\"):\n                    continue\n        else:\n            # print(f\"Worn boots >= found item...\")  # remove after testing\n            # pause()  # remove after testing\n            return\n\n    def found_cloak_substitution(self, found_item):\n\n        if self.cloak.stealth < math.ceil(self.dexterity * .25):\n            if found_item.name == self.cloak.name:\n                # found_item.stealth += 1\n                self.cloak.stealth += 1\n                self.calculate_stealth()\n                print(f\"Quantum Weirdness fills the air...\\nYour {self.cloak.name} is enhanced to stealth +\"\n                      f\" {self.cloak.stealth}!\")\n\n                pause()\n                return\n            else:\n                print(f\"You have found {found_item.a_an} {found_item.name}!! Stealth: {found_item.stealth}\")\n                print(f\"Your current {self.cloak.name} Stealth: {self.cloak.stealth}\")\n            while True:\n                replace_cloak = input(f\"Do you wish to wear the {found_item.name} instead? y/n: \").lower()\n                if replace_cloak == 'y':\n                    old_cloak = self.cloak\n                    self.cloak = found_item\n                    print(f\"You are now wearing the {found_item.name}\")\n                    self.calculate_stealth()\n                    if not self.duplicate_item(old_cloak.item_type,\n                                               old_cloak):  # old_cloak not in self.pack[found_item.item_type]:\n                        (self.pack[found_item.item_type]).append(old_cloak)\n                        print(f\"You roll up the {old_cloak.name} and place it in your pack..\")  # dungeoneer's pack\n                    else:\n                        print(f\"You drop your {old_cloak.name}.\")\n                    pause()\n                    return\n                elif replace_cloak == 'n':\n                    print(f\"You choose not to wear the {found_item.name}.\")  # remove after testing\n                    if not self.duplicate_item(found_item.item_type,\n                                               found_item):  # found_item not in self.pack[found_item.item_type]:\n                        (self.pack[found_item.item_type]).append(found_item)\n                        print(f\"You place the {found_item.name} in your pack.\")  # dungeoneer's pack\n                    else:\n                        print(f\"You cannot carry any more cloaks like this. You leave it.\")  # can't carry any more\n                    pause()\n                    return\n                elif replace_cloak not in (\"y\", \"n\"):\n                    continue\n        else:\n            # print(f\"Stealth already >= .25 * dex...\")  # remove after testing\n            # pause()  # remove after testing\n            return\n\n    def found_ring_of_reg_substitution(self, found_item):\n\n        if self.ring_of_reg.name == \"No Ring of Regeneration\":\n            # self.ring_of_regeneration and default class object has 0 regenerate\n            self.ring_of_reg = found_item\n            print(f\"Quantum Weirdness fills the air...\")\n            print(f\"A Ring of Regeneration + {self.ring_of_reg.regenerate} appears on your finger!\")\n            sleep(1)\n            print(f\"It becomes permanently affixed..fused to your flesh and bone!\")\n            self.regenerate()  # this is fair. this could save you from poison or necrosis\n            pause()\n            return\n\n        elif self.ring_of_reg.regenerate < math.ceil(self.maximum_hit_points * .15):\n            # old_ring = self.ring_of_reg\n            self.ring_of_reg.regenerate = (self.ring_of_reg.regenerate + 1)\n            print(f\"Quantum Weirdness fills the air...\")\n            print(f\"Your {self.ring_of_reg.name} is enhanced to + {self.ring_of_reg.regenerate} !\")\n            pause()\n            return\n\n        else:\n            # print(\"Ring of reg already equal to or more than 15% of max hit points\")  # remove after testing\n            # pause()  # remove after testing\n            return\n\n    def found_ring_of_prot_substitution(self, found_item):\n\n        if self.ring_of_prot.name == \"No Ring of Protection\":  # default ring is transparent placeholder\n            self.ring_of_prot = found_item\n            # (self.pack[found_item.item_type]).append(found_item) you can't sell rings. new rule\n            print(f\"Quantum Weirdness fills the air...\")\n            print(f\"A Ring of Protection + {self.ring_of_prot.protect} appears on your finger!\")\n            sleep(1)\n            print(f\"Tunneling through realities, it permanently fuses to flesh and bone!\")\n            pause()\n            return\n\n        elif self.ring_of_prot.protect < math.ceil(self.wisdom * .20):\n            self.ring_of_prot.protect += 1\n            print(f\"Quantum Weirdness fills the air...\")\n            print(f\"Your {self.ring_of_prot.name} is enhanced to + {self.ring_of_prot.protect} !\")\n            pause()\n            return\n\n        else:\n            # print(\"Ring of prot already equal to or more than 20% of wisdom\")  # remove after testing\n            # pause()  # remove after testing\n            return\n\n    def loot(self):\n        # Called from main loop\n\n        if self.encounter < 21:  # regular monster\n            loot_difficulty_class = 10\n            treasure_chest_difficulty_class = 20\n        else:  # boss\n            loot_difficulty_class = 8\n            treasure_chest_difficulty_class = 16\n\n        # chance to get treasure chest\n        possible_treasure_chest = dice_roll(1, 20)\n        if self.encounter < 21:  # regular monster\n            if possible_treasure_chest >= treasure_chest_difficulty_class:\n                self.treasure_chest()\n                return  # return after treasure chest for regular monster\n        else:  # boss. function then continues to give regular loot after treasure chest\n            if possible_treasure_chest >= treasure_chest_difficulty_class:\n                self.treasure_chest()\n\n        # regular loot\n        loot_dict = top_level_loot_dict\n        while True:\n            # ****** NOTICE THE DIFFERENCE BETWEEN found_item and found_item.item_type !! ************************\n            loot_roll = dice_roll(1, 20)\n            self.hud()\n            # print(f\"Loot roll ---> {loot_roll}\")  # remove after testing ?\n            # pause()\n            # item_class = random.choice(list(loot_dict.keys()))\n            # new_item_instance = random.choice(loot_dict[item_class])()  # Calling class __init__ method\n            if loot_roll >= loot_difficulty_class:\n                key = random.choice(list(loot_dict.keys()))\n                # rndm_item_index = random.randrange(len(loot_dict[key]))\n                # found_item = loot_dict[key][rndm_item_index]\n                found_item = random.choice(loot_dict[key])()  # Calling class __init__ method\n                # print(found_item)  # REMOVE AFTER TESTING *****************************************************\n\n                if self.level >= found_item.minimum_level:\n                    if found_item.item_type == 'Armor':\n                        self.found_armor_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Shields':\n                        self.found_shield_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Cloaks':\n                        self.found_cloak_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Weapons':\n                        self.found_weapon_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Rings of Regeneration':\n                        self.found_ring_of_reg_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Rings of Protection':\n                        self.found_ring_of_prot_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Boots':\n                        self.found_boots_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Town Portal Implements':\n                        print(f\"You see a {found_item.name} !\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.town_portals += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Healing':\n                        print(f\"You see a {found_item.name} !\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.potions_of_healing += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Potions of Strength':\n                        print(f\"You see a {found_item.name} !\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.potions_of_strength += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Elixirs':\n                        print(f\"You see a {found_item.name}!\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.elixirs += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Antidotes':\n                        print(f\"You see a {found_item.name}!\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.antidotes += 1\n                        pause()\n                        continue\n\n                else:\n                    # print(f\"Minimum requirements not met for {found_item.name}.\")  # remove after testing\n                    # pause()  # remove after testing\n                    continue\n            else:\n                # extra chance for potion. this makes it a little too easy. consider restoring it with lower chances\n                \"\"\"extra_chance = dice_roll(1, 20)\n                if extra_chance >= 11  # loot_difficulty_class:\n                    print(f\"You see a potion of healing!\")\n                    sleep(.5)\n                    print(f\"You grab it..\")\n                    self.potions_of_healing += 1\n                    pause()\n                    # continue\n                self.hud()\"\"\"\n                self.hud()\n                return  # self.dungeon_description()\n\n    def treasure_chest(self):\n        # called from treasure_chest_event(),\n        # also called from from loot()\n        successful_tries = 0\n        print(f\"You see a treasure chest!\")\n        sleep(1.5)\n        gold_roll = dice_roll(1, 20) * self.dungeon.level + 1\n        print(f\"Inside is {gold_roll} gold pieces!\")\n        self.gold += gold_roll\n        sleep(1.5)\n        pause()\n        loot_difficulty_class = 7\n        loot_dict = top_level_loot_dict\n        while True:\n            # ****** NOTICE THE DIFFERENCE BETWEEN found_item and found_item.item_type !! ************************\n            loot_roll = dice_roll(1, 20)\n            self.hud()\n            # print(f\"Loot roll ---> {loot_roll}\")  # remove after testing ?\n            # pause()\n            if loot_roll >= loot_difficulty_class:\n                successful_tries += 1\n                key = random.choice(list(loot_dict.keys()))  # this code should negate item key type list\n                # rndm_item_index = random.randrange(len(loot_dict[key]))\n                # found_item = loot_dict[key][rndm_item_index]\n                found_item = random.choice(loot_dict[key])()  # Calling class __init__ method\n                # print(found_item)  # REMOVE AFTER TESTING *****************************************************\n                if self.level >= found_item.minimum_level:\n                    if found_item.item_type == 'Armor':\n                        self.found_armor_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Shields':\n                        self.found_shield_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Cloaks':\n                        self.found_cloak_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Weapons':\n                        self.found_weapon_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Rings of Regeneration':\n                        self.found_ring_of_reg_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Rings of Protection':\n                        self.found_ring_of_prot_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Boots':\n                        self.found_boots_substitution(found_item)\n                        continue\n                    elif found_item.item_type == 'Town Portal Implements':\n                        print(f\"You see a {found_item.name} !\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.town_portals += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Healing':\n                        print(f\"You see a {found_item.name} !\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.potions_of_healing += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Potions of Strength':\n                        print(f\"You see a {found_item.name} !\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.potions_of_strength += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Elixirs':\n                        print(f\"You see a {found_item.name}!\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.elixirs += 1\n                        pause()\n                        continue\n                    elif found_item.item_type == 'Antidotes':\n                        print(f\"You see a {found_item.name}!\")\n                        sleep(.5)\n                        print(f\"You snarf it..\")\n                        self.antidotes += 1\n                        pause()\n                        continue\n                else:\n                    # print(f\"Minimum requirements not met for {found_item.name}.\")  # remove after testing\n                    # pause()  # remove after testing\n                    continue\n            else:\n                if successful_tries == 0:\n                    print(f\"Besides the gold, there remains nothing but cobwebs...\")\n                    sleep(1)\n                    pause()\n                return\n\n    def treasure_chest_event(self):\n        # called from event_logic()\n        # the treasure_chest_event() is explicitly placed in the dungeon object at specific coordinates.\n        # Calls treasure_chest()\n        # treasure_chest() can also be called from loot() and awarded after battle\n        treasure_chest_discovery = f\"level {self.dungeon.level} treasure chest\"\n        if treasure_chest_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(treasure_chest_discovery)\n            return self.treasure_chest()\n\n        else:\n            self.dungeon_description()\n            print(f\"There is an empty treasure chest here.\")\n            # print(f\"An empty treasure chest lies at your feet.\")\n            pause()\n            return\n\n    def quantum_treasure_chest_event(self):\n        # called from event_logic()\n        # quantum_treasure_chest_event is explicitly placed in the dungeon object at specific coordinates\n        successful_tries = 0\n        quantum_treasure_chest_discovery = f\"level {self.dungeon.level} quantum treasure chest\"\n        if quantum_treasure_chest_discovery not in self.discovered_interactives:\n            print(f\"You see a treasure chest with a Quantum lock!\")\n            sleep(1)\n            print(f\"You feel dangerous levels of energy surging from it..\")\n            sleep(1)\n            lock_dc = 10\n            while True:\n                prompt = input(\"Do you wish to attempt to (U)nlock it with your Quantum knowledge or (I)gnore (U/I): \")\n                if prompt == 'i':\n                    return\n                if prompt == 'u':\n                    break\n                self.hud()\n            quantum_roll = dice_roll(1, 20)\n            total = quantum_roll + self.wisdom_modifier\n            print(f\"Quantum Check Roll: {quantum_roll}\")\n            sleep(.5)\n            print(f\"Wisdom Modifier: {self.wisdom_modifier}\")\n            sleep(.5)\n            print(f\"Total: {total}\")\n            sleep(.5)\n            print(f\"Difficulty Class: {lock_dc}\")\n            sleep(.5)\n            if total >= lock_dc:\n                print(f\"Success!\")\n                sleep(1.5)\n                gold_roll = (dice_roll(1, 20) * self.dungeon.level) + 1\n                print(f\"Inside is {gold_roll} gold pieces!\")\n                self.gold += gold_roll\n                sleep(1.5)\n                pause()\n                loot_difficulty_class = 7\n                loot_dict = top_level_loot_dict\n                while True:\n                    # ****** NOTICE THE DIFFERENCE BETWEEN found_item and found_item.item_type !! ***********\n                    loot_roll = dice_roll(1, 20)\n                    self.hud()\n                    print(f\"Loot roll ---> {loot_roll}\")  # remove after testing ?\n                    pause()\n                    if loot_roll >= loot_difficulty_class:\n                        successful_tries += 1\n                        key = random.choice(list(loot_dict.keys()))  # this code should negate item key type list\n                        # rndm_item_index = random.randrange(len(loot_dict[key]))\n                        # found_item = loot_dict[key][rndm_item_index]\n                        found_item = random.choice(loot_dict[key])()  # Calling class __init__ method\n                        # print(found_item)  # REMOVE AFTER TESTING ****************************************************\n                        if found_item.minimum_level - self.level <= 2:\n                            if found_item.item_type == 'Armor':\n                                self.found_armor_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Shields':\n                                self.found_shield_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Cloaks':\n                                self.found_cloak_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Weapons':\n                                self.found_weapon_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Rings of Regeneration':\n                                self.found_ring_of_reg_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Rings of Protection':\n                                self.found_ring_of_prot_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Boots':\n                                self.found_boots_substitution(found_item)\n                                continue\n                            elif found_item.item_type == 'Town Portal Implements':\n                                print(f\"You see a {found_item.name} !\")\n                                sleep(.5)\n                                print(f\"You snarf it..\")\n                                self.town_portals += 1\n                                pause()\n                                continue\n                            elif found_item.item_type == 'Healing':\n                                print(f\"You see a {found_item.name} !\")\n                                sleep(.5)\n                                print(f\"You snarf it..\")\n                                self.potions_of_healing += 1\n                                pause()\n                                continue\n                            elif found_item.item_type == 'Potions of Strength':\n                                print(f\"You see a {found_item.name} !\")\n                                sleep(.5)\n                                print(f\"You snarf it..\")\n                                self.potions_of_strength += 1\n                                pause()\n                                continue\n                            elif found_item.item_type == 'Elixirs':\n                                print(f\"You see a {found_item.name}!\")\n                                sleep(.5)\n                                print(f\"You snarf it..\")\n                                self.elixirs += 1\n                                pause()\n                                continue\n                            elif found_item.item_type == 'Antidotes':\n                                print(f\"You see a {found_item.name}!\")\n                                sleep(.5)\n                                print(f\"You snarf it..\")\n                                self.antidotes += 1\n                                pause()\n                                continue\n                        else:\n                            print(f\"You see {found_item.a_an} {found_item.name}.\")\n                            sleep(1)\n                            print(f\"Even with the Quantum Weirdness of the chest, you are unable to use it.\")\n                            sleep(1)\n                            pause()\n                            continue\n                    else:\n                        # done with loot\n                        if successful_tries == 0:\n                            print(f\"Besides the gold, there remains nothing but cobwebs...\")\n                            sleep(1)\n                            pause()\n                        # add chest to discovered interactives list, so it is no longer interactive\n                        self.discovered_interactives.append(quantum_treasure_chest_discovery)\n                        self.hud()\n                        return  # self.dungeon_description()\n            else:\n                print(f\"Your innate Quantum understanding has failed you.\")\n                sleep(1)\n                print(f\"You are unable to open the Quantum lock...\")\n                sleep(1)\n                print(f\"A wave of Quantum energy shoots toward you!\")\n                damage = dice_roll(self.level, self.hit_dice)\n                self.reduce_health(damage)\n                print(f\"You suffer {damage} hit points!\")\n                pause()\n                return\n        else:\n            print(f\"There is an empty Quantum treasure chest here.\")\n            pause()\n            return\n\n    def increase_random_ability(self):\n        # I was unable to come up with this code on my own.\n        # Thanks to Angus Nicolson from Stack Overflow!\n        # By editing player.__dict__ directly,\n        # or a variable which you derived from it (ability_dict in the code below),\n        # you can edit your object's attributes.\n        # create a dictionary from self.__dict__\n        # Note: Editing ability_dict_subset will not change the object's attributes,\n        # because it was made from a dict comprehension.\n        # You need to edit self.__dict__ or ability_dict.\n        ability_dict = self.__dict__\n        # Define list of attributes you are allowed to change\n        attributes = [\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"]\n        # ability_dict_subset = {k: v for k, v in ability_dict.items() if k in attributes}\n        ability_dict_subset = {key: value for key, value in ability_dict.items() if key in attributes}\n        # Choose random attribute name\n        random_attribute = random.choice(list(ability_dict_subset.keys()))\n        print(f\"Weird Quantum forces surge through your body..\")\n        sleep(1.5)\n        print(f\"You have gained unnatural {random_attribute}!\")\n        ability_dict[random_attribute] += 1\n        self.calculate_modifiers()\n        pause()\n\n    def decrease_random_ability(self):\n        # I was unable to come up with this code on my own.\n        # Thanks to Angus Nicolson from Stack Overflow!\n        # By editing player.__dict__ directly,\n        # or a variable which you derived from it (ability_dict in the code below),\n        # you can edit your object's attributes.\n        # create a dictionary from self.__dict__\n        # Note: Editing ability_dict_subset will not change the object's attributes,\n        # because it was made from a dict comprehension.\n        # You need to edit self.__dict__ or ability_dict.\n        ability_dict = self.__dict__\n        # Define list of attributes you are allowed to change\n        attributes = [\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"]\n        # ability_dict_subset = {k: v for k, v in ability_dict.items() if k in attributes}\n        ability_dict_subset = {key: value for key, value in ability_dict.items() if key in attributes}\n        # Choose random attribute name\n        random_attribute = random.choice(list(ability_dict_subset.keys()))\n        print(f\"You feel as though you have been robbed at the most visceral level..\")\n        sleep(1.5)\n        print(f\"Your {random_attribute} has dropped!\")\n        ability_dict[random_attribute] -= 1\n        self.calculate_modifiers()\n        pause()\n\n    def increase_lowest_ability(self):\n        ability_dict = self.__dict__\n        # Define list of attributes you are allowed to change\n        attributes = [\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"]\n        ability_dict_subset = {key: value for key, value in ability_dict.items() if key in attributes}\n        # Find the minimum attribute name\n        min_attribute = min(ability_dict_subset, key=ability_dict_subset.get)\n        print()  # remove after testing\n        print(f\"Weird sensations surge through your body..\")\n        sleep(1.5)\n        print(f\"You have gained {min_attribute}!\")\n        # Add one to min attribute\n        ability_dict[min_attribute] += 1\n        self.calculate_modifiers()\n        pause()\n\n    def decrease_lowest_ability(self):\n        ability_dict = self.__dict__\n        # Define list of attributes you are allowed to change\n        attributes = [\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"]\n        ability_dict_subset = {key: value for key, value in ability_dict.items() if key in attributes}\n        # Find the minimum attribute name\n        min_attribute = min(ability_dict_subset, key=ability_dict_subset.get)\n        # print(min_attribute)  # remove after testing\n        print(f\"Weird discomfort surges through your body..\")\n        sleep(1.5)\n        print(f\"You have lost {min_attribute}!\")\n        # subtract one from min attribute\n        ability_dict[min_attribute] -= 1\n        self.calculate_modifiers()\n        pause()\n\n    def wicked_queen_event(self):\n        # called from event_logic()\n        wicked_queen_discovery = f\"level {self.dungeon.level} wicked queen\"\n        if wicked_queen_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(wicked_queen_discovery)\n            cls()\n            queen_confrontation_theme()\n            print_txt_file('queen_splash.txt')\n            pause()\n            cls()\n            teletype_txt_file('queen_confrontation.txt')\n            pause()\n            return \"Wicked Queen\"\n        else:\n            return\n\n    def legendary_monster_event(self):\n        # called from event_logic()\n        mini_boss_discovery = f\"level {self.dungeon.level} mini boss\"\n        if mini_boss_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(mini_boss_discovery)\n            return \"Legendary Monster\"\n        else:\n            return\n\n    def elite_monster_event(self):\n        # called from event_logic()\n        micro_boss_discovery = f\"level {self.dungeon.level} micro boss\"\n        if micro_boss_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(micro_boss_discovery)\n            return \"Elite Monster\"\n        else:\n            return\n\n    def altar_event(self):\n        # called from event_logic()\n        altar_demo_exp = self.level * 600\n        altar_discovery = f\"level {self.dungeon.level} altar\"\n        if altar_discovery not in self.discovered_interactives:\n            rndm_occurrence_lst = [undead_prophet_returns, self.increase_random_ability, self.decrease_random_ability,\n                                   undead_prophet_returns, self.increase_lowest_ability,\n                                   self.lose_items, undead_prophet_returns, self.heal_event, undead_prophet_returns]\n            rndm_occurrence = random.choice(rndm_occurrence_lst)\n\n            rndm_altar_descriptions = ['There is a worn and crumbling altar of stone here. Carved into its\\n'\n                                       'cold surface are faded symbols from disgusting ancient religions.',\n                                       'Here stands an altar of stone which has been abandoned long ago.\\n'\n                                       'Ancient and horrible religious symbols, now illegible, cover its cold surface.',\n                                       'There is a mysterious, ancient, crumbling stone altar here.\\n'\n                                       'Inscribed upon its surface are countless half-worn\\n'\n                                       'disgusting symbols left behind by civilizations past.']\n            rndm_altar_description = random.choice(rndm_altar_descriptions)\n            print(f\"{rndm_altar_description}\")\n            print(f\"Along its sides are embedded ornate golden sculptures.\")\n            print(f\"You shudder to think of the innocent lives lost to its many\\n\"\n                  f\"horrible false prophets and priests, now long dead.\")\n            throne_action = input(\n                f\"(R)emove gold, attempt to (D)emolish the altar, (V)andalize,  or (I)gnore: \").lower()\n            if throne_action == 'v':\n                print(f\"With the hilt of your {self.wielded_weapon.name} you violate the ancient site\\n\"\n                      f\"with a bold warning message to any who would dare to revisit such evils upon the world...\")\n                sleep(1.5)\n                print(f\"As you finish, you stand to admire your work..\")\n                pause()\n                return rndm_occurrence()\n            elif throne_action == 'r':\n                difficulty_class = 14\n                remove_gold_roll = dice_roll(1, 20)\n                if remove_gold_roll + self.intelligence_modifier > difficulty_class:\n                    gold_value = (random.randint(7, 10) * self.dungeon.level) * self.acumen\n                    print(f\"The sculpture comes out, though not without difficulty or damage.\")\n                    sleep(1)\n                    print(f\"It is worth {gold_value} GP!\")\n                    self.gold += gold_value\n                    pause()\n                    return\n                else:\n                    return \"Undead Prophet\"  # undead_prophet_returns()\n            elif throne_action == 'd':\n                print(f\"Removing the hammer from your pack, you begin hacking at the crumbling stone..\")\n                primary_difficulty_class = 15\n                demolish_roll = dice_roll(1, 20)\n                if demolish_roll + self.strength_modifier > primary_difficulty_class:  # strength to topple\n                    print(f\"You succeed in toppling the upper portion!\")\n                    sleep(1)\n                    print(f\"Using your rope and timbers from the refuse, you set up rigging.\\n\"\n                          f\"Then, with minimal effort, you are able to pull the foundation stones out.\")\n                    sleep(1.5)\n                    print(f\"You successfully demolish the altar!\")\n                    sleep(1.5)\n                    self.experience += altar_demo_exp\n                    print(f\"You gain {altar_demo_exp} experience points!!\")\n                    self.discovered_interactives.append(altar_discovery)\n                    sleep(1.5)\n                    pause()\n                    self.hud()\n                    return self.increase_random_ability()\n                else:\n                    return \"Undead Prophet\"  # undead_prophet_returns()\n\n            else:\n                return  # ignore the altar\n        else:\n            print(f\"The remains of a demolished ancient altar are here..Who would dare?\")\n            pause()\n            return\n\n    def throne_event(self):\n        # because the throne has been stolen and repurposed by many kingdoms, it remains infinitely interactive.\n        # however, the gems may only be pried once.\n        # throne_discovery = f\"level {self.dungeon.level} throne\" # uncomment to only allow 1 interaction\n        rndm_occurrence_lst = [nothing_happens, king_returns, self.increase_random_ability, self.teleporter_event,\n                               nothing_happens, king_returns, self.increase_lowest_ability, self.lose_items,\n                               king_returns, nothing_happens, self.heal_event, king_returns,\n                               self.decrease_random_ability,\n                               self.decrease_lowest_ability]\n        rndm_occurrence = random.choice(rndm_occurrence_lst)\n        rndm_throne_descriptions = ['There is a magnificent, gem-encrusted throne of gold here. Throughout its\\n'\n                                    'shimmering surface are countless runes and symbols.',\n                                    'In the center of the room stands a majestic throne encrusted with many\\n'\n                                    'gems and jewels, all laid in gold. Ancient runes cover its glimmering surface.',\n                                    'A great, golden throne, replete with many gems and inscribed with countless '\n                                    'runes stands here.']\n        rndm_throne_description = random.choice(rndm_throne_descriptions)\n        print(f\"{rndm_throne_description}\")\n        print(f\"Judging by the sheer number of unique origins of the runes, this throne was undoubtedly\")\n        print(f\"stolen from, and reclaimed by many different ancient kings, now long dead.\")\n        # pause()\n        # if throne_discovery not in self.discovered_interactives:  # uncomment to only allow 1 interaction\n        throne_action = input(f\"(P)ry gems, attempt to (R)ead the Runes, (S)it on the throne or (I)gnore: \").lower()\n        if throne_action == 's':\n            print(f\"You sit on the throne...\")\n            # self.discovered_interactives.append(throne_discovery)  # uncomment to only allow 1 interaction\n            sleep(1.5)\n            return rndm_occurrence()\n\n        elif throne_action == 'p':\n            gems_pried = f\"level {self.dungeon.level} gems pried from throne\"\n            if gems_pried not in self.discovered_interactives:\n                difficulty_class = 12\n                pry_roll = dice_roll(1, 20)\n                if pry_roll > difficulty_class:\n                    gem_value = (random.randint(7, 15) * self.dungeon.level) * self.acumen\n                    print(f\"They pop out into your greedy hands!\")\n                    sleep(1.5)\n                    print(f\"They are worth {gem_value} GP!\")\n                    self.gold += gem_value\n                    self.discovered_interactives.append(gems_pried)\n                    pause()\n                    return\n                else:\n                    return \"King Boss\"  # king_returns()\n            else:\n                print(f\"There are no gems left to pry...\")\n                pause()\n        elif throne_action == 'r':\n            rune_experience = self.level * 700\n            difficulty_class = 15\n            read_roll = dice_roll(1, 20)\n            if read_roll + self.wisdom_modifier > difficulty_class:  # wisdom to recognize language\n                print(f\"You recognize the ancient language!\")\n                sleep(1)\n                translate = input(f\"Do you want to attempt to translate it into the common tongue? (y/N)? \").lower()\n                if translate == 'y':\n                    difficulty_class = 8\n                    translate_roll = dice_roll(1, 20)\n                    if translate_roll + self.intelligence_modifier > difficulty_class:  # intelligence to translate\n                        rndm_ancient_wisdom = [\"Do not withhold good from those to whom you should give it\\n\"\n                                               \"If it is within your power to help.\",\n                                               \"Do not plot harm against your \"\n                                               \"neighbor when he lives in a sense of security with you.\",\n                                               \"The wise will inherit honor, but the stupid ones glorify \"\n                                               \"dishonor.\",\n                                               \"Do not enter the path of the wicked, and do not walk in \"\n                                               \"the way of evil men.\\nShun it, do not take it; \"\n                                               \"Turn away from it, and pass it by.\",\n                                               \"The way of the wicked is like \"\n                                               \"the darkness;\\nThey do not know what makes them stumble.\",\n                                               \"Above all the things that you guard, safeguard your heart, \"\n                                               \"For out of it are the sources of life.\",\n                                               \"Drink water from your own \"\n                                               \"cistern\\nAnd flowing water from your own well.\"]\n                        rndm_wisdom = random.choice(rndm_ancient_wisdom)\n                        print(f\"The literal translation is, '{rndm_wisdom}...'\")\n                        sleep(1.5)\n                        self.experience += rune_experience\n                        print(f\"You gain {rune_experience} experience points!!\")\n                        sleep(1.5)\n                        pause()\n                        self.loot()\n                        return self.increase_random_ability()\n                    else:\n                        return \"King Boss\"  # king_returns()  # unable to translate\n                else:\n                    return  # player chooses not to translate\n            else:\n                return \"King Boss\"  # king_returns()  # player unable to recognize runes\n        else:\n            return  # ignore the throne\n\n    def heal_event(self):\n        # healing event called from fountain\n        hit_point_overage = ((6 * self.dungeon.level) + 1)\n        print(f\"You feel vitality bubbling up within you...\")\n        sleep(1.5)\n        if self.poisoned or self.necrotic:\n            print(f\"Your flesh no longer crawls with agony..\")\n            sleep(1)\n            self.poisoned = False\n            self.poisoned_turns = 0\n            self.necrotic = False\n            self.necrotic_turns = 0\n            print(f\"The foul corruption leaves your body..\")\n            sleep(1)\n        if self.hit_points < self.maximum_hit_points:\n            print(f\"The restorative powers heal you to full strength!\")\n            sleep(1)\n            self.hit_points = self.maximum_hit_points\n        else:\n            self.hit_points += hit_point_overage\n            print(f\"Your hit points have been unnaturally raised to {self.hit_points}!\")\n            sleep(1)\n            print(f\"You wonder how long this advantage will last..\")\n            sleep(1)\n        pause()\n        return\n\n    def lose_items(self):\n        # pack items get lost first, then if belt_items_to_lose sum > 0, belt items get lost\n        belt_item_types_to_lose = [self.potions_of_strength, self.potions_of_healing,\n                                   self.town_portals, self.elixirs, self.antidotes]\n        available_item_types_to_lose = []\n        for i in self.pack.keys():  # gather all available\n            if len(self.pack[i]) > 0:  # item types to lose based on player's current item TYPES and put them\n                available_item_types_to_lose.append(i)  # in available_item_types_to_lose = []\n        if len(available_item_types_to_lose) > 0:\n            item_type = random.choice(available_item_types_to_lose)  # Get random item *TYPE* you want to \"steal\"\n            if len(self.pack[item_type]) > 0:  # If the player has an item of type \"item_type\"\n                # pop random item from that item type. -1 because indexes start at 0\n                lost_item = (self.pack[item_type].pop(random.randint(0, len(self.pack[item_type]) - 1)))\n                print(f\"Your load feels lighter..\")\n                sleep(1)\n                print(f\"The {lost_item.name} from your pack is gone!\")  # from your {item_type}\")  # dungeoneer's pack\n                pause()\n                return\n        elif sum(belt_item_types_to_lose) > 0:\n\n            item_string = \"\"\n            # Define list of attributes you are allowed to change\n            self_dict = self.__dict__  # create variable as actual copy of player dict attribute\n            stealing_lst = []\n            # the working dict and 'for' loop just takes the place of many 'if:' statements\n            working_dict = {'potions_of_strength': self.potions_of_strength,\n                            'potions_of_healing': self.potions_of_healing,\n                            'town_portals': self.town_portals, 'elixirs': self.elixirs,\n                            'antidotes': self.antidotes}\n            # add all items > 0 in working dict to stealing list\n            for key, value in working_dict.items():\n                if value > 0:\n                    stealing_lst.append(key)\n            random_stolen_item = random.choice(stealing_lst)\n            # I am proud of this next bit of code :)\n            grammar_dict = {'potions_of_strength': 'potion of strength',\n                            'potions_of_healing': 'potion of healing',\n                            'town_portals': 'scroll of town portal', 'elixirs': 'clarifying elixir',\n                            'antidotes': 'vial of antidote'}\n            for key, value in grammar_dict.items():\n                if random_stolen_item == key:\n                    item_string = value\n            print(f\"Your load feels lighter...\")\n            sleep(1)\n            print(f\"A {item_string} has disappeared from your belt!\")\n            self_dict[random_stolen_item] -= 1\n            pause()\n            return\n        else:\n            return nothing_happens()  # pack and belt inventory empty\n\n    def fountain_event(self):\n        # WHITE GREEN CLEAR RED BLACK\n        # Telengard has these 5 random events:\n        # heal 3 * dungeon level + 1 hit points\n        # poison 3 * dungeon level + 1 hit points\n        # drunk\n        # lose items\n        # increase num of spells: Magic power SURGES through your body\n        water_colors = ['white', 'green', 'bright green ', 'crystal clear',\n                        'deep red', 'red', 'black', 'pitch black']\n        water_color = random.choice(water_colors)\n        print(f\"A fountain flowing with {water_color} water is here.\")\n        sleep(1)\n        print(f\"The tranquil sound eases your mind.\")\n        sleep(1)\n        drink = input(f\"Do you wish to drink? \").lower()\n        if drink == 'y':\n            random_occurrence_list = [nothing_happens, self.recover_quantum_energy, self.poison_ingestion,\n                                      self.increase_random_ability, self.lose_items, self.decrease_random_ability,\n                                      self.increase_lowest_ability, self.heal_event, nothing_happens,\n                                      self.decrease_lowest_ability]\n            random_occurrence = random.choice(random_occurrence_list)\n            random_occurrence()\n        else:\n            print(\"Ignore.\")\n            sleep(.25)\n            return\n\n    def teleporter_event(self):\n        print(f\"Zzzzzzap....You've been teleported.....\")\n        sleep(2)\n        # self.dungeon_key += 1  # this will become random.randint(1, deepest dungeon level) in future\n        # self.dungeon = dungeon_dict[self.dungeon_key]\n        # self.x = random.randint(1, 18)\n        # self.y = random.randint(1, 18)\n        (self.x, self.y) = self.dungeon.teleporter_landing\n        self.coordinates = (self.x, self.y)\n        self.previous_x = self.x\n        self.previous_y = self.y\n        self.position = self.dungeon.grid[self.y][self.x]\n        pause()\n        self.hud()\n        return\n\n    def pit_event(self):\n        # falling into pits lands you at the dungeon.pit_landing coordinates\n        print(f\"The ground here is slippery, and quite unsteady..\")\n        sleep(1.5)\n        print(f\"You see a pit..\")\n        sleep(1.5)\n        pit_difficulty_class = 9\n        pit_outcome = dice_roll(1, 20)\n        if (pit_outcome + self.dexterity_modifier + self.intelligence_modifier) > pit_difficulty_class:\n            print(f\"It appears to be about 3 fathoms deep.\")\n            sleep(1)\n            descend_or_not = input(f\"Do you wish to descend (y/N)? \").lower()\n            if descend_or_not == 'y':\n                self.in_a_pit = True\n                print(f\"Retrieving the rope from your belt, you deftly repel down the slick, \"\n                      f\"treacherous pit walls.\")\n                # self.dungeon_key += 1\n                # self.dungeon = dungeon_dict[self.dungeon_key]\n                (self.x, self.y) = self.dungeon.pit_landing\n                self.coordinates = (self.x, self.y)  # beta self.dungeon.pit_landing\n                self.previous_x = self.x\n                self.previous_y = self.y\n                self.position = self.dungeon.grid[self.y][self.x]\n                pause()\n                self.hud()\n                print(f\"You have landed at the bottom of a pit. The foul, humid air hangs in a mist around you.\")\n                # print(self.dungeon.pit_intro)\n                self.dungeon_theme()  # dungeon_theme() method logic determines which musical theme to play\n                pause()\n                return\n            else:\n                return\n        else:\n            print(f\"The ground beneath your feet collapses!\")\n            sleep(1)\n            # print(f\"Desperately, you grope for a crag!\")\n            # sleep(1)\n            # removed this code. now, either you fall in or you don't\n            # if dice_roll(1, 20) >= 15:\n            #    print(f\"You succeed!\")\n            #    pause()\n            #    return\n            # else:\n            self.in_a_pit = True\n            print(f\"You fall in!\")\n            damage = dice_roll(1, (3 * self.dungeon.level))  # dice_roll(1, self.dungeon.level)\n            self.hit_points -= damage\n            sleep(1)\n            print(f\"You suffer {damage} hit points..\")\n            sleep(1)\n            pause()\n            # falling into pits lands you on the same dungeon level, at the dungeon.pit_landing coordinates\n            # self.dungeon_key += 1  # this can be used to land you on the next level down\n            # self.dungeon = dungeon_dict[self.dungeon_key]  # this can be used to land you on the next level down\n            (self.x, self.y) = self.dungeon.pit_landing\n            self.coordinates = (self.x, self.y)  # beta\n            self.previous_x = self.x\n            self.previous_y = self.y\n            self.position = self.dungeon.grid[self.y][self.x]\n            self.hud()\n            print(f\"You have landed at the bottom of the pit. The foul, humid air hangs in a mist around you.\")\n            # print(self.dungeon.pit_intro)\n            self.dungeon_theme()  # dungeon_theme() method logic determines which musical theme to play\n            pause()\n            return\n\n    def staircase_description(self):\n        # called from dungeon_description()\n        # this is a 'description' of the spiral staircase, if player navigates to it *after* the map is initialized\n        # it is not an 'event', since it is not really interactive, so it is called from dungeon_description()\n        # and not from event_logic()\n        print(f\"The spiral staircase entrance to {self.dungeon.name} is here.\")\n        if self.dungeon.level > 1:\n            previous_place = f\"dungeon level {self.dungeon.level - 1}\"\n        else:\n            previous_place = f\"the Dark Mountain entrance\"\n        print(f\"The stairs lead up to {previous_place}. However, there is no returning;\\n\"\n              f\"The door has been locked and barricaded. You must continue onward!\")\n\n    def pit_landing_description(self):\n        # called from dungeon_description()\n        # this is a 'description' of the pit landing.\n        # it is not an 'event', since it is not really interactive, so it is called from dungeon_description()\n        # and not from event_logic()\n        print(f\"High above you is a wide, gaping hole leading up to \"\n              f\"{self.dungeon.name}.\")\n\n    def deaf_one_fog_remnant_description(self):\n        # called from dungeon_description()\n        # a description of the area where deaf one was, if he has been discovered on current dungeon level\n        deaf_one_discovery = f\"level {self.dungeon.level} deaf_one\"\n        if deaf_one_discovery in self.discovered_interactives:\n            print(f\"There is a lingering remnant of fog and a marshy smell here.\")\n\n    def elevator_landing_description(self):\n        # called from dungeon_description()\n        # this is a 'description' of the elevator landing.\n        # it is not an 'event', since it is not really interactive, so it is called from dungeon_description()\n        # and not from event_logic()\n        # print(f\"Mechanical Landing, {self.dungeon.name}\")\n        print(f\"There is a landing for a mechanical contraption of ropes, pulleys and counterweights here.\")\n        print(f\"The base is covered in an iron mesh, allowing the horribly foul air from deep below\\n\"\n              f\"{self.dungeon.casual_name} to escape to this level.\")\n\n    def teleporter_landing_description(self):\n        # called from dungeon_description()\n        # this is a 'description' of the teleporter landing.\n        # it is not an 'event', since it is not really interactive, so it is called from dungeon_description()\n        # and not from event_logic()\n        print(f\"The floor of {self.dungeon.name} has been scorched here, and there is a subtle, but discernible\\n\"\n              f\"bowl shape, about 3 yards across, which seems to have been perfectly carved from it.\")\n\n    def elevator_event(self):\n        # elevators bring you 'up' from pits to main dungeon level: self.dungeon.elevator_landing\n        # self.in_a_pit will be false at end of function\n        # player must pass intelligence protection roll\n        print(f\"You feel a slight whirring..\")\n        sleep(1)\n        difficulty_class = 9\n        if dice_roll(1, 20) + self.intelligence_modifier >= difficulty_class:\n            stay_or_jump = input(f\"You see an elevation mechanism which can return you to the \"\n                                 f\"main dungeon level.\\nDo you wish to go back (U)p, or \"\n                                 f\"(S)tay to explore this level further? \").lower()\n            if stay_or_jump == 'u':\n                print(f\"A cage closes on your position.\")\n                sleep(1)\n                print(f\"You feel heavy for a moment..\")\n                sleep(2)\n                self.hud()\n                self.in_a_pit = False\n                # self.dungeon_key -= 1  # this can be used for more powerful elevator, perhaps at advanced levels\n                # self.dungeon = dungeon_dict[self.dungeon_key]  # when player has more experience?\n                (self.x, self.y) = self.dungeon.elevator_landing\n                self.coordinates = (self.x, self.y)\n                self.previous_x = self.x\n                self.previous_y = self.y\n                self.position = self.dungeon.grid[self.y][self.x]\n                print(f\"You have arrived back at {self.dungeon.name}, dungeon level {self.dungeon.level}.\")\n                sleep(1)\n                self.dungeon_theme()  # dungeon_theme() method logic determines which musical theme to play\n                print(f\"Watch your step.\")\n                sleep(1)\n                pause()\n                return\n            else:\n                return\n        else:\n            print(f\"A cage closes upon you!\")  # intelligence not enough to realize what is happening.\n            sleep(1)\n            print(f\"You are being drawn upward!\")\n            sleep(2)\n            self.hud()\n            # self.dungeon_key -= 1\n            # self.dungeon = dungeon_dict[self.dungeon_key]\n            print(f\"You have arrived back at {self.dungeon.name}, dungeon level {self.dungeon.level}.\")\n            sleep(2)\n            self.in_a_pit = False\n            (self.x, self.y) = self.dungeon.elevator_landing\n            self.coordinates = (self.x, self.y)\n            self.previous_x = self.x\n            self.previous_y = self.y\n            self.position = self.dungeon.grid[self.y][self.x]\n            print(f\"Watch your step.\")\n            sleep(1)\n            self.dungeon_theme()  # dungeon_theme() method logic determines which musical theme to play\n            pause()\n            return\n\n    def npc_defeats_monster_logic(self, monster, damage):\n        # called from npc_attack_logic() to discern if npc defeats monster, and\n        # monster dies mid-party-turn\n        monster.reduce_health(damage)\n        if monster.check_dead():\n            self.hud()\n            if self.encounter > 20:  # if fighting boss\n                gong()\n                if monster.proper_name != \"None\":\n                    print(f\"The party has vanquished {monster.proper_name}! \"\n                          f\"You are victorious!\")\n                    self.vanquished_foes.append(monster.proper_name)\n                else:\n                    print(f\"The party has vanquished the {monster.name}!\")\n                sleep(4)\n                self.dungeon_theme()\n            else:\n                print(f\"The party has defeated the {monster.name}..\")\n\n            return True\n        else:\n            return False\n\n    def npc_attack_logic(self, monster):\n        # called from main loop after player quantum or melee attack (or potion)\n        if self.sikira_ally or self.vozzbozz_ally or self.torbron_ally or self.magnus_ally:\n            victory = False\n            if self.sikira_ally:\n                if not self.sikira.retreating:\n                    ally_dmg1 = self.npc_melee(self.sikira, monster.name, monster.armor_class)\n                    if self.npc_defeats_monster_logic(monster, ally_dmg1):\n                        victory = True\n                        return victory\n                    else:\n                        victory = False\n\n            if self.torbron_ally:\n                if not self.torbron.retreating:\n                    ally_dmg2 = self.npc_melee(self.torbron, monster.name, monster.armor_class)\n                    if self.npc_defeats_monster_logic(monster, ally_dmg2):\n                        victory = True\n                        return victory\n                    else:\n                        victory = False\n\n            if self.magnus_ally:\n                if not self.magnus.retreating:\n                    ally_dmg3 = self.npc_melee(self.magnus, monster.name, monster.armor_class)\n                    if self.npc_defeats_monster_logic(monster, ally_dmg3):\n                        victory = True\n                        return victory\n                    else:\n                        victory = False\n\n            if self.vozzbozz_ally:\n                if not self.vozzbozz.retreating:\n                    ally_dmg4 = self.vozzbozz_attack(monster)\n                    if self.npc_defeats_monster_logic(monster, ally_dmg4):\n                        victory = True\n                        return victory\n                    else:\n                        victory = False\n\n            return victory\n\n        else:  # player has no NPC allies\n            return\n\n    def encounter_deaf_one_event1(self):\n        # called from event_logic()\n        deaf_one_discovery = f\"level {self.dungeon.level} deaf_one\"\n        random_orientation_lst = [\"north\", \"south\", \"east\", \"west\"]\n        random_orientation = random.choice(random_orientation_lst)\n        if deaf_one_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(deaf_one_discovery)\n            self.hud()\n            teletype(f\"From the {random_orientation}, a seemingly autonomous, marshy, and knee-deep fog stretches \"\n                     f\"toward you from out of the mire\\nas a dark humanoid silhouette begins to emerge. \"\n                     f\"You behold his elongated, troll-like nose and ears, and deep-set eyes\\nshrouded in black, \"\n                     f\"the whites of which shine with a luminescence as brilliant as any moon you have ever beheld. \"\n                     f\"\\nHis garb is a mere patchwork of cloth strip wrappings, as though he were once \"\n                     f\"mummified. His exposed portions\\nof flesh appear gray and lifeless, with arms covered in \"\n                     f\"tattoo markings, and his long, dark hair drapes down\\npast his shoulders.\\n\")\n            pause()\n            cls()\n            print_txt_file(\"deafone.txt\")\n            pause()\n            self.hud()\n            teletype(f\"Drawing your {self.wielded_weapon.name}, you attack!\\n\")\n            pause()\n            self.hud()\n            teletype(f\"Your weapon strikes his left arm and splinters into shards of white-hot steel! \\n\"\n                     f\"Unaffected and dismissive, he opens his palm, and your {self.wielded_weapon.name} \\n\"\n                     f\"re-appears, completely restored! He hands it to you with a nod.\\n\")\n            pause()\n            self.hud()\n            teletype(f\"'Be at ease, {self.name}.', he says in a smooth, even tone. 'I am not an enemy, and I cannot \"\n                     f\"be harmed by such weapons.'\\n'Who are you?', you insist.\\nHe regards your question for a brief \"\n                     f\"moment before saying, 'You may call me Deaf One'.\\n'Deaf One?', You blurt out, almost \"\n                     f\"involuntarily.\\nWith a nod, he answers in a subdued, faraway voice, 'Though hearing, I hear \"\n                     f\"in vain..'\\nStill on your guard, yet feeling powerless in contrast to his obvious \"\n                     f\"invulnerability, you begin to explain your quest.\\n'Yes, I know why *you* are here.', \"\n                     f\"he interrupts, plainly. \"\n                     f\"'*I* am here', he pauses, 'to guide you. \\nThe exit of this dungeon is guarded by an enemy whom \"\n                     f\"you are not yet \\nprepared to face.'\\n\")\n            pause()\n            self.hud()\n            teletype(f\"Thinking back to your training, you recall Gorndam's words and warnings about physical power \"\n                     f\"and its limitations in\\nthe face of mighty foes.\\n'Your teacher was correct', Deaf one states \"\n                     f\"with inexplicable context and knowledge, 'you must pursue and hone \\nyour innane \"\n                     f\"understanding of the Quantum nature of our world.'\\n\")\n            pause()\n            self.hud()\n            teletype(f\"'Is it not too late for training, now that I am here?', you ask.\\nPatiently, he responds, \"\n                     f\"'I will ask you to simply ponder this question.' \\n'Ask yourself, is Uncertainty essentially \"\n                     f\"ontological, or, epistemological?'\\n'Ontological..?', you begin.\\n'Yes, is \"\n                     f\"Quantum Uncertainty simply a feature of our reality, \\nrather than a reflection of the \"\n                     f\"limitations of our knowledge, or, is it epistemological; \\nfundamentally due to our own \"\n                     f\"Uncertainty of Quantum Nature?'\\n\")\n            pause()\n            self.hud()\n            teletype(f\"'That is quite a concept to ponder..', you respond, rather incredulously.\\n\"\n                     f\"'Indeed.', he says, 'This question is at the heart of your advancement.'\\nIt is the concept \"\n                     f\"which will either facilitate or prevent your comprehension of Weirdness.'\\n\"\n                     f\"'It is the principle which must be embraced, and never understood.', he concludes.\"\n                     f\"\\nBefore you can respond with the myriad of \"\n                     f\"questions in your mind, \\nthe marshy fog envelopes Deaf One, and his form becomes \"\n                     f\"obscured with\\nits whisperings until he is simply gone. \\nAll that remains is the cold, \"\n                     f\"creeping mist.\\n\")\n            pause()\n            if self.hit_points < self.maximum_hit_points:\n                self.hud()\n                teletype(f\"The remnants of the low-lying fog pulse with Weirdness...\")\n                sleep(1.5)\n                self.heal_event()\n            return\n\n    def encounter_deaf_one_event2(self):\n        # called from event_logic()\n        deaf_one_discovery = f\"level {self.dungeon.level} deaf_one\"\n        random_orientation_lst = [\"north\", \"south\", \"east\", \"west\"]\n        random_orientation = random.choice(random_orientation_lst)\n        if deaf_one_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(deaf_one_discovery)\n            cls()\n            teletype(f\"From the {random_orientation}, a seemingly autonomous, marshy, and knee-deep fog stretches \"\n                     f\"toward you.\\nFrom out of the mire, Deaf One emerges and approaches you!\\n\")\n            pause()\n            cls()\n            allies = []\n            if self.sikira_ally:\n                allies.append(\"Si'Kira\")\n            if self.magnus_ally:\n                allies.append(\"Magnus\")\n            if self.torbron_ally:\n                allies.append(\"Tor'bron\")\n            if self.vozzbozz_ally:\n                allies.append(\"Vozzbozz\")\n\n            if len(allies):\n                if len(allies) > 1:\n                    teletype(f\"With nearly perfectly synchronized actions, your allies ready themselves toward the \"\n                             f\"perceived threat,\\nas Deaf One remains perfectly still, relaxed, and disaffected.\\n\"\n                             f\"'Peace, my friends! Peace!', you cry out, while gesturing to the party to calm \"\n                             f\"themselves.\\n'He is not an enemy!'\\nDeaf One nods, and you detect the hint of a smile \"\n                             f\"forming on his gray flesh.\")\n\n            teletype(f\"'Quite a journey it has been for you, {self.name}.', he begins in his smooth, even tone, \"\n                     f\"his voice filling your mind, and the space around you.\\n'Your adversary awaits at the end of \"\n                     f\"this artery, to the east.', he says.\\nThen, with genuine curiosity, he adds, \"\n                     f\"'I have watched your progress with satisfaction. Have you pondered my question?'\\n\"\n                     f\"'I have', you say plainly.\\n'And?' he queries.\\n\"\n                     f\"'And, the answer is; Yes. Quantum Uncertainty is either a feature of our reality, or a \"\n                     f\"refection of the limitations of our knowledge.'\\nA wide, toothy grin grows over his undying \"\n                     f\"face. 'That is a good answer..', he says with sincerity.\\nThen, his smile fades and is \"\n                     f\"replaced with solemnity. '..but not the only answer!'\\nHe smiles again and turns to leave.\\n\"\n                     f\"'Wait!' you call out impulsively. 'Will we ever meet again?', you ask.\\n'Yes.', he says, \"\n                     f\"pausing to turn over his shoulder. '*That* I can say with certainty.', he adds, with a cryptic \"\n                     f\"narrowing of his eyes.\\n\")\n            pause()\n            cls()\n            teletype(f\"The marshy fog begins to envelope Deaf One, until his form becomes obscured and he is simply \"\n                     f\"gone, along with the cold, creeping mist.\\n\")\n            pause()\n            if self.hit_points < self.maximum_hit_points:\n                self.hud()\n                teletype(f\"The remnants of the low-lying fog pulse with Weirdness...\")\n                sleep(1.5)\n                self.heal_event()\n            return\n\n    def encounter_the_party_event(self):\n        # called from event_logic()\n        party_discovery = f\"level {self.dungeon.level} party_encounter\"\n        if party_discovery not in self.discovered_interactives:\n            cls()\n            self.discovered_interactives.append(party_discovery)\n            self.torbron_ally = True\n            self.magnus_ally = True\n            self.vozzbozz_ally = True\n            teletype(f\"Due east, you see a group of 3 adventurers whom you immediately recognize. 'My friends!' \"\n                     f\"you cry aloud.\\n\"\n                     f\"Tor'Bron, Magnus and Vozzbozz approach, and against the ominous backdrop and setting, \"\n                     f\"you find new respect for their imposing appearance.\\n'Well met, {self.name}.', states Vozzbozz \"\n                     f\"plainly. 'And I speak for us all when I say you are a welcome ally, Si'Kira!', he adds.\\n\")\n            pause()\n            cls()\n            teletype_txt_file('encounter_the_party.txt')\n            pause()\n            cls()\n\n    def encounter_sikira_event(self):\n        # called from event_logic()\n        ally_discovery = f\"level {self.dungeon.level} ally\"\n        rndm_orientation_lst = [\"left\", \"right\", \"rear\"]\n        rndm_orientation = random.choice(rndm_orientation_lst)\n        if ally_discovery not in self.discovered_interactives:\n            self.discovered_interactives.append(ally_discovery)\n            # this is really an unnecessary check, but I decided to include it\n            # just in case I forget to make level 21 monsters.\n            if self.level < 20:\n                monster_key = (self.level + 1)\n            else:\n                monster_key = self.level\n            monster_cls = random.choice(monster_dict[monster_key])\n            monster = monster_cls()\n            self.hud()\n            print(f\"You see a beautiful Elven warrior here, battling an especially fierce {monster.name}.\")\n            print(f\"Instinctively, you ready your {self.wielded_weapon.name} and rush to help.\")\n            print(f\"The {monster.name} strikes at her wickedly, but she nimbly springs back, just out of reach.\\n\"\n                  f\"Noticing you, she motions to the {monster.name}'s {rndm_orientation} with a subtle twitch\\n\"\n                  f\"of her head, as she strikes back with her glorious, finely crafted sword.\")\n            pause()\n            self.hud()\n            print(f\"Moving to the {monster.name}'s {rndm_orientation}, as directed, the {monster.name} suddenly\"\n                  f\" senses your presence!\\n\"\n                  f\"{monster.attack_5_phrase}\")\n            print(f\"The distraction serves as a perfect opportunity for attack, as she swings her great blade from\\n\"\n                  f\"a blind angle, felling her enemy with a single, precise cut. The {monster.name} falls dead\\n\"\n                  f\"without ever realizing it was in danger.\")\n            print(f\"Placing your {self.wielded_weapon.name} on your back, you extend a hand. You remember a greeting\\n\"\n                  f\"that elves who visited Tinbar appreciated, and say, Well met, illuminated one!'.\")\n            pause()\n            self.hud()\n            print(f\"You immediately sense a shift in the air. The petite warrior's alabaster countenance falls to\\n\"\n                  f\"a twisted grimace and her crimson eyes burn with hate. Her blade is at your throat before you\\n\"\n                  f\"can even react. 'What did ye call me?' she queries in a beautifully perfect voice, smoother\\n\"\n                  f\"than oil.\")\n            pause()\n            self.hud()\n            print(f\"'Forgive me, friend!', you manage to respond. 'It was meant with deep respect! It is how\\n\"\n                  f\"Elf-kind enjoy being greeted where I am from!..'\")\n            print(f\"'I AM NOT OF-THE-LIGHT!', she asserts, directly into your face. \"\n                  f\"Your disarmed look speaks to your\\n\"\n                  f\"confusion, and she responds, 'And I have no need of your assistance, nor of\\n\"\n                  f\"your life!' You feel her blade move within a hair's breadth of your throat.\")\n            pause()\n            self.hud()\n            print(f\"Again you plead, 'Please forgive my ignorance. I am from a far-off land. My name is {self.name}\\n\"\n                  f\"of Tinbar! My people and the Northern Library have all been destroyed by a terrible evil that\\n\"\n                  f\"I have been sent to seek out and destroy...she bears the mark of a crowned woman surrounded\\n\"\n                  f\"by skulls!'\")\n            pause()\n            self.hud()\n            print(f\"Her face and mood again shift, and she removes her blade and begins to smile! It is then that you\\n\"\n                  f\"begin to notice the signs you missed earlier; Her teeth- black and smooth as raven's claws,\\n\"\n                  f\"tiny fangs, deep red eyes and her unusually petite, yet athletic build. But how could a Dark \"\n                  f\"Elf have\\n\"\n                  f\"such a pale complexion, you wonder silently...Are they not grey-skinned?\")\n            pause()\n            cls()\n            print_txt_file('sikira.txt')\n            pause()\n            self.hud()\n            print(f\"'Well. {self.name} of Tinbar, well met!', she says with an evil chuckle. 'I am Si'Kira,\\n\"\n                  f\"Child of the Waning Moon. My people too, have all been slain. I also seek to destroy the\\n\"\n                  f\"wicked Queen Jannbrielle.'. She sheathes her blade, and her long silver hair glistens gorgeously\\n\"\n                  f\"in the darkness, as does her wondrous weaponry and armor.\")\n            pause()\n            self.hud()\n            print(f\"'Queen Jannbrielle..', you repeat thoughtfully. Si'Kira looks at you as you say the name.\\n\"\n                  f\"'I have met allies above who dare not even utter that word, and at last I learn it...'\\n\"\n                  f\"'Thank you for finally revealing the name of our common enemy, my good Elf-of-the-darkness!' \"\n                  f\"you say with\\n\"\n                  f\"a hint of humor.\")\n            pause()\n            self.hud()\n            print(f\"Si'Kira laughs gleefully again. 'This is most interesting!', she says, with sincere intrigue\\n\"\n                  f\"in her voice, and visible excitement in her eyes. 'How odd that our paths cross in such a \"\n                  f\"way..and in such a place! I shall\\n\"\n                  f\"'be accompanying you, {self.name} of Tinbar! For good or ill, we are bound in purpose and\\n\"\n                  f\"outcome.'\")\n            pause()\n            self.hud()\n            print(f\"'I suppose..that settles it..?', you say somewhat ironically.\\n\"\n                  f\"'Aye. It does.', says Si'Kira, plainly.\")\n            pause()\n            self.hud()\n            print(f\"You cannot help but wish that you had a voice in the matter; Dark Elves are notoriously \"\n                  f\"duplicitous, and\\nvery clever, but you trust your instincts and move on, together.\")\n            self.sikira_ally = True\n            pause()\n        else:\n            return\n\n    def deaf_one_forced_portal_conditionals(self):\n        # called from self.deaf_one_portal_dungeon_levelX_event() methods below\n        # sets conditions checked elsewhere\n        self.forced_portal = True  # checked in town_navigation()\n        cls()\n        teletype(f\"A portal opens before you; Strange, erratic, and \"\n                 f\"pulsating with incredible power\\nthat you feel in your bones. Within the Weird \"\n                 f\"opening, you see Deaf One, silently standing in front\\nof the Slumbering Bear Inn! \"\n                 f\"He beckons you with a gesture to join him. Instinctively, you step through to find\\n\"\n                 f\"him vanished in an instant..\\n\")\n        pause()\n        town_theme()\n        self.in_town = True  # checked in main loop, to break out of dungeon loops and remain in town loop\n        self.in_dungeon = False  # checked in main loop to break out of dungeon loops\n        self.town_portal_exists = True  # checked to ensure proper prompt to enter or re-enter dungeon\n\n    def deaf_one_portal_dungeon_level2_event(self):\n        # called from self.event_logic()\n        # on dungeon level 2, force player to tavern to trigger boss_hint_1_event if not done so already\n        # to move story along.\n        if not self.boss_hint_1_event:\n            self.deaf_one_forced_portal_conditionals()\n            return \"DeafOnePortal\"\n\n    def deaf_one_portal_dungeon_level3_event(self):\n        # called from self.event_logic()\n        # on dungeon level 3, force player to tavern to trigger boss_hint_2_event if not done so already\n        # to move story along\n        if not self.boss_hint_2_event:\n            self.deaf_one_forced_portal_conditionals()\n            return \"DeafOnePortal\"\n\n    def deaf_one_portal_dungeon_level4_event(self):\n        # called from self.event_logic()\n        # on dungeon level 4, force player to tavern to trigger boss_hint_3_event if not done so already\n        # because, otherwise the party members will just show up without explanation\n        if not self.boss_hint_3_event:\n            self.deaf_one_forced_portal_conditionals()\n            return \"DeafOnePortal\"\n\n    def event_logic(self):\n        # interactive events, items etc.\n        # the event dictionary *key* is a tuple trigger corresponding to\n        # dungeon x y coordinates of an event or item e.g. (2, 3)\n        # the event dictionary *value* is the corresponding player function/event.\n        # if the player's coordinates exist as a key in event_dict,\n        # the dictionary value is given the variable 'event_function'\n        # finally, the proper function (method) is called and any\n        # function values are returned to the main program\n        # using 'return event_function()'\n        # monster_encounter = dice_roll(1, 20)\n        self.coordinates = (self.x, self.y)\n        event_dict = {self.dungeon.quantum_treasure_chest: self.quantum_treasure_chest_event,\n                      self.dungeon.encounter_sikira: self.encounter_sikira_event,\n                      self.dungeon.encounter_deaf_one_1: self.encounter_deaf_one_event1,\n                      self.dungeon.encounter_deaf_one_2: self.encounter_deaf_one_event2,\n                      self.dungeon.deaf_one_portal_dungeon_level2: self.deaf_one_portal_dungeon_level2_event,\n                      self.dungeon.deaf_one_portal_dungeon_level3: self.deaf_one_portal_dungeon_level3_event,\n                      self.dungeon.deaf_one_portal_dungeon_level4: self.deaf_one_portal_dungeon_level4_event,\n                      self.dungeon.encounter_the_party: self.encounter_the_party_event,\n                      self.dungeon.treasure_chest: self.treasure_chest_event,\n                      self.dungeon.altar: self.altar_event,\n                      self.dungeon.throne: self.throne_event,\n                      self.dungeon.fountain: self.fountain_event,\n                      self.dungeon.teleporter: self.teleporter_event,\n                      self.dungeon.elevator: self.elevator_event,\n                      self.dungeon.pit: self.pit_event,\n                      self.dungeon.elite_monster: self.elite_monster_event,\n                      self.dungeon.legendary_monster: self.legendary_monster_event,\n                      self.dungeon.wicked_queen: self.wicked_queen_event,\n                      self.dungeon.exit: self.dungeon_exit_event\n                      }\n        if self.coordinates in event_dict.keys():\n            event_function = (event_dict[self.coordinates])  # (event_dict[self.coordinates])\n            return event_function()\n        else:\n            return\n\n        # NAVIGATION\n\n    def town_navigation(self):\n        # called from main loop\n        if self.forced_portal:\n            # if self.boss_hint_3 and not self.boss_hint_3_event:  # if player defeats level 3 exit boss and has not yet\n            self.forced_portal = False  # reset forced portal condition\n            tavern_theme()  # visited tavern, then player automatically placed at tavern\n            self.tavern()\n            town_theme()\n        if self.town_portal_exists:  # or self.loaded_game:\n            town_functions = input(\"(The Town of Fieldenberg)\\n(Quit) to desktop, (R)estart game (I)nventory, \"\n                                   \"(B)lacksmith, (C)hemist , (T)avern, or re-(E)nter dungeon --> \").lower()\n        else:\n            town_functions = input(\"(The Town of Fieldenberg)\\n(Quit) to desktop, (R)estart game (I)nventory, \"\n                                   \"(B)lacksmith, (C)hemist , (T)avern, or (E)nter dungeon --> \").lower()\n        if town_functions == 'r':\n            return self.restart()\n\n        elif town_functions == 'quit':\n            quit_game()\n\n        #  elif town_functions == 's':\n        #    self.save_character()\n\n        elif town_functions == 'i':\n            self.inventory()\n\n        elif town_functions == 'b':\n            print(\"You visit the blacksmith..\")\n            sleep(1.5)\n            blacksmith_theme()\n            self.blacksmith_main()\n            town_theme()\n\n        elif town_functions == 'c':\n            print(\"You make your way to the chemist manipulator..\")\n            sleep(1.5)\n            chemist_theme()\n            self.chemist_main()\n            town_theme()\n\n        elif town_functions == 't':\n            print(f\"You make your way to the tavern..\")\n            sleep(1.25)\n            tavern_theme()\n            self.tavern()\n            town_theme()\n\n        elif town_functions == 'e':\n\n            if self.town_portal_exists:  # or self.loaded_game:\n                same_line_print(f\"You re-enter the portal.\")\n\n            else:\n                sad_cello_theme()\n                teletype_txt_file('first_descent.txt')\n                pause()\n            random_floppy_rw_sound()\n            loading_screen()\n            dot_dot_dot(15)\n            return 'e'\n\n        else:\n            unknown_command()\n\n    def dungeon_navigation(self, dungeon_command):\n        if dungeon_command == 'w':\n            self.hud()\n            print(\"North\")\n            self.y -= 1\n            sleep(.5)\n            return\n        elif dungeon_command == 'a':\n            self.hud()\n            print(\"West\")\n            self.x -= 1\n            sleep(.5)\n            return\n        elif dungeon_command == 's':\n            self.hud()\n            print(\"South\")\n            self.y += 1\n            sleep(.5)\n            return\n        elif dungeon_command == 'd':\n            self.hud()\n            print(\"East\")\n            self.x += 1\n            sleep(.5)\n            return\n        elif dungeon_command == 'nw':\n            self.hud()\n            print(\"Northwest\")\n            self.y -= 1  # north\n            self.x -= 1  # west\n            sleep(.5)\n            return\n        elif dungeon_command == 'ne':\n            self.hud()\n            print(\"Northeast\")\n            self.y -= 1  # north\n            self.x += 1  # east\n            sleep(.5)\n            return\n        elif dungeon_command == 'se':\n            self.hud()\n            print(\"Southeast\")\n            self.y += 1  # south\n            self.x += 1  # east\n            sleep(.5)\n            return\n        elif dungeon_command == 'sw':\n            self.hud()\n            print(\"Southwest\")\n            self.y += 1  # south\n            self.x -= 1  # west\n            sleep(.5)\n            return\n        elif dungeon_command == 'l':\n            # this will call dungeon_description().\n            self.dungeon_description()\n            self.coordinates = (self.x, self.y)\n            self.position = self.dungeon.grid[self.y][self.x]\n            return\n        elif dungeon_command == 'map':\n            self.display_map(self.dungeon.player_grid)  #\n            pause()\n            self.dungeon_description()\n            return\n        elif dungeon_command == 'm':\n            self.item_management_sub_menu()\n            return\n        elif dungeon_command == 'i':\n            self.inventory()\n            return\n        elif dungeon_command == 'stay':\n            print(f\"Stay.\")\n            sleep(1)\n            return\n        else:  # remove after testing\n            print(f\"This should be unreachable.\")\n            return\n\n    def boss_clue_1(self):\n        # player finds first clue about wicked queen boss\n        self.hud()\n        rndm_hint_list = [\"a piece of parchment\", \"a torn piece of fabric\", \"a broken necklace\", \"a broken ring\"]\n        clue_item = random.choice(rndm_hint_list)\n        print(f\"On the ground before you lays {clue_item}. You carefully pick it up.\")\n        sleep(1)\n        print(f\"You see a symbol on it; A woman with a crown, surrounded by many skulls.\")\n        sleep(1)\n        print(f\"Without warning, it begins to deteriorate in your hands until it is nothing but ashes!\")\n        sleep(1)\n        print(f\"You ponder this, and commit the image to memory. You wonder if there is someone in town who can shed\\n\"\n              f\"light on the strange symbol.\")\n        pause()\n        self.hud()\n        self.boss_hint_1 = True\n        return\n\n    def boss_clue_2(self):\n        self.hud()\n        print(\"You see a nasty-looking knife in a hand-etched sheath of gold!\")\n        sleep(1)\n        print(\"Turning it over in your hands reveals runes that are foreign to you, which cover its entire surface.\")\n        sleep(1)\n        print(f\"You carefully place the dagger on your belt.\")\n        pause()\n        self.hud()\n        self.boss_hint_2 = True\n        return\n\n    def boss_clue_3(self):\n        self.hud()\n        print(\"You hear the flapping of wings nearby...\")\n        sleep(1)\n        print(f\"You catch a glimpse of a flying creature overhead, just before it disappears into the darkness.\")\n        pause()\n        self.hud()\n        self.boss_hint_3 = True\n        return\n\n    # def boss_clue_4(self):\n    #    self.hud()\n    #    print(\"You find a clue about the boss4\")\n    #    pause()\n    #    self.hud()\n    #    self.boss_hint_4 = True\n    #    return\n\n    def boss_hint_logic(self):\n        # called from victory_over_boss_logic (if self.encounter ==99),\n        # which is called from main loop, after exit bosses are defeated\n        if not self.boss_hint_1:\n            self.boss_clue_1()\n            return\n        if not self.boss_hint_2:\n            self.boss_clue_2()\n            return\n        if not self.boss_hint_3:\n            self.boss_clue_3()\n            return\n        # if not self.boss_hint_4:\n        #    self.boss_clue_4()\n        #   return\n        # if not self.boss_hint_5:\n        # return self.boss_clue_5()\n        # if not self.boss_hint_6:\n        # return self.boss_clue_6()\n        return\n\n    def wide_open_space_logic(self):\n        # called from automatic_dungeon_description_and_room_exit_finder()\n        level_7_openness_phrase = f\"This is a rather wide-open area of {self.dungeon.name}.\"\n        level_8_openness_phrase = f\"This is a wide open area of {self.dungeon.name}.\"\n        if self.in_a_pit:\n            level_7_openness_phrase = f\"The pit seems rather wide open here.\"\n            level_8_openness_phrase = f\"The pit is wide open here.\"\n        north_of_you = self.dungeon.grid[self.y - 1][self.x]\n        west_of_you = self.dungeon.grid[self.y][self.x - 1]\n        south_of_you = self.dungeon.grid[self.y + 1][self.x]\n        east_of_you = self.dungeon.grid[self.y][self.x + 1]\n        northeast_of_you = self.dungeon.grid[self.y - 1][self.x + 1]\n        northwest_of_you = self.dungeon.grid[self.y - 1][self.x - 1]\n        southeast_of_you = self.dungeon.grid[self.y + 1][self.x + 1]\n        southwest_of_you = self.dungeon.grid[self.y + 1][self.x - 1]\n        perimeter = []\n        if north_of_you != \"*\":\n            perimeter.append(\"North\")\n        if south_of_you != \"*\":\n            perimeter.append(\"South\")\n        if east_of_you != \"*\":\n            perimeter.append(\"East\")\n        if west_of_you != \"*\":\n            perimeter.append(\"West\")\n        if northeast_of_you != \"*\":\n            perimeter.append(\"Northeast\")\n        if northwest_of_you != \"*\":\n            perimeter.append(\"Northwest\")\n        if southeast_of_you != \"*\":\n            perimeter.append(\"Southeast\")\n        if southwest_of_you != \"*\":\n            perimeter.append(\"Southwest\")\n        openness = len(perimeter)\n        if openness == 7:\n            return level_7_openness_phrase\n        if openness == 8:\n            return level_8_openness_phrase\n        else:\n            return f\"This is a non-descript area of {self.dungeon.name}.\"\n\n    def atrium_check(self):\n        # an atrium connects a corridor to a wide-open chamber.\n        # called from automatic_dungeon_description_and_room_exit_finder() *after* intersection_check\n        # this only works if intersection check is called first, and is False\n        directions = []\n        corridor_found = False\n        north_of_you = self.dungeon.grid[self.y - 1][self.x]\n        west_of_you = self.dungeon.grid[self.y][self.x - 1]\n        south_of_you = self.dungeon.grid[self.y + 1][self.x]\n        east_of_you = self.dungeon.grid[self.y][self.x + 1]\n        northeast_of_you = self.dungeon.grid[self.y - 1][self.x + 1]\n        northwest_of_you = self.dungeon.grid[self.y - 1][self.x - 1]\n        southeast_of_you = self.dungeon.grid[self.y + 1][self.x + 1]\n        southwest_of_you = self.dungeon.grid[self.y + 1][self.x - 1]\n        if northeast_of_you == \"*\" and northwest_of_you == \"*\" and north_of_you != \"*\":\n            directions.append(\"Northern\")\n            corridor_found = True\n            # return \"Northern\"\n        if southeast_of_you == \"*\" and southwest_of_you == \"*\" and south_of_you != \"*\":\n            directions.append(\"Southern\")\n            corridor_found = True\n            # return \"Southern\"\n        if northeast_of_you == \"*\" and southeast_of_you == \"*\" and east_of_you != \"*\":\n            directions.append(\"Eastern\")\n            corridor_found = True\n            # return \"Eastern\"\n        if northwest_of_you == \"*\" and southwest_of_you == \"*\" and west_of_you != \"*\":\n            directions.append(\"Western\")\n            corridor_found = True\n            # return \"Western\"\n        if corridor_found:\n            return directions\n        else:\n            return False\n\n    def intersection_check(self):\n        # called from automatic_dungeon_description_and_room_exit_finder()\n        northeast_of_you = self.dungeon.grid[self.y - 1][self.x + 1]\n        northwest_of_you = self.dungeon.grid[self.y - 1][self.x - 1]\n        southeast_of_you = self.dungeon.grid[self.y + 1][self.x + 1]\n        southwest_of_you = self.dungeon.grid[self.y + 1][self.x - 1]\n        if northeast_of_you == \"*\" and northwest_of_you == \"*\" and southeast_of_you == \"*\" and southwest_of_you == \"*\":\n            return True\n        else:\n            return False\n\n    def auto_intersection_description(self):\n        # called from automatic_dungeon_description_and_room_exit_finder()\n        intersection_name = self.dungeon.intersection_name\n        if self.in_a_pit:\n            intersection_name = self.dungeon.pit_intersection_name\n        north_of_you = self.dungeon.grid[self.y - 1][self.x]\n        west_of_you = self.dungeon.grid[self.y][self.x - 1]\n        south_of_you = self.dungeon.grid[self.y + 1][self.x]\n        east_of_you = self.dungeon.grid[self.y][self.x + 1]\n        exits_list = []\n        if north_of_you != \"*\":\n            exits_list.append(\"North\")\n        if south_of_you != \"*\":\n            exits_list.append(\"South\")\n        if east_of_you != \"*\":\n            exits_list.append(\"East\")\n        if west_of_you != \"*\":\n            exits_list.append(\"West\")\n        number_of_ways = len(exits_list)\n        if number_of_ways > 1:\n            # exits = convert_list_to_string_with_and(exits_list)\n            description = f\"You are in {intersection_name} which \" \\\n                          f\"forms a {number_of_ways}-way intersection.\"\n            return description\n        else:\n            # this code is ostensibly unreachable\n            exits = convert_list_to_string(exits_list)\n            print(f\"There appears to have been an intersection here at one time, but all except one corridor has \"\n                  f\"collapsed. The only exit is to the {exits}\")\n\n    def automatic_dungeon_description_and_room_exit_finder(self):\n        # I am very proud of this code. I wrote it all from scratch,\n        # which is quite an accomplishment for me.\n        # called from dungeon_description()\n        multiple_corridors = False\n        barrier_name = self.dungeon.barrier_name\n        barrier_name_plural = self.dungeon.barrier_name_plural\n        corridor_phrase = self.dungeon.corridor_phrase\n        corridor_name = self.dungeon.corridor_name\n        large_atrium_phrase = self.dungeon.large_atrium_phrase\n        one_walled_atrium_phrase = self.dungeon.one_walled_atrium_phrase\n        if self.in_a_pit:\n            barrier_name = self.dungeon.pit_barrier_name\n            barrier_name_plural = self.dungeon.pit_barrier_name_plural\n            corridor_phrase = self.dungeon.pit_corridor_phrase\n            corridor_name = self.dungeon.pit_corridor_name\n            large_atrium_phrase = self.dungeon.pit_large_atrium_phrase\n            one_walled_atrium_phrase = self.dungeon.pit_one_walled_atrium_phrase\n\n        corridor_direction = \"\"\n        auto_description_phrase = \"\"\n        north_of_you = self.dungeon.grid[self.y - 1][self.x]\n        west_of_you = self.dungeon.grid[self.y][self.x - 1]\n        south_of_you = self.dungeon.grid[self.y + 1][self.x]\n        east_of_you = self.dungeon.grid[self.y][self.x + 1]\n        exits_list = []\n        walls_list = []\n\n        if north_of_you != \"*\":\n            exits_list.append(\"North\")\n        else:\n            walls_list.append(\"North\")\n        if south_of_you != \"*\":\n            exits_list.append(\"South\")\n        else:\n            walls_list.append(\"South\")\n        if east_of_you != \"*\":\n            exits_list.append(\"East\")\n        else:\n            walls_list.append(\"East\")\n        if west_of_you != \"*\":\n            exits_list.append(\"West\")\n        else:\n            walls_list.append(\"West\")\n        number_of_exits = len(exits_list)\n        number_of_walls = len(walls_list)\n\n        if number_of_walls == 0:  # 4-way intersection, large atrium, or wide-open area\n\n            if not self.intersection_check():  # if you are not at an intersection\n\n                if not self.atrium_check():  # and you are not in an atrium\n                    auto_description_phrase = self.wide_open_space_logic()  # you must be in a wide open space\n\n                else:  # you must be in a large atrium with 0 walls\n                    auto_description_phrase = large_atrium_phrase\n                    corridor_direction = self.atrium_check()\n\n                    if len(corridor_direction) > 1:  # beta if more than 1 corridor\n                        corridor_direction = convert_list_to_string_with_and(corridor_direction)\n                        multiple_corridors = True\n\n                    else:  # only one corridor\n                        corridor_direction = convert_list_to_string(corridor_direction)\n\n            else:  # you must be at a 4-way intersection; intersections do not need to detect corridor_direction\n                auto_description_phrase = self.auto_intersection_description()\n\n        if number_of_walls == 1:  # 3-way intersection, wall-lined atrium, or against a wall\n\n            if not self.intersection_check():  # if you are not at an intersection\n\n                if not self.atrium_check():  # and you are not in an atrium lined with one wall\n                    # you must be against a wall\n                    direction = convert_list_to_string(walls_list)\n                    auto_description_phrase = f\"You are against {barrier_name} to the {direction}.\"\n\n                else:  # you must be in an atrium lined with one wall\n                    direction = convert_list_to_string(walls_list)\n                    auto_description_phrase = f\"{one_walled_atrium_phrase} The {direction} \" \\\n                                              f\"side is lined with {barrier_name}.\"\n                    corridor_direction = self.atrium_check()\n\n                    if len(corridor_direction) > 1:\n                        corridor_direction = convert_list_to_string_with_and(corridor_direction)\n                        multiple_corridors = True\n\n                    else:  # beta\n                        corridor_direction = convert_list_to_string(corridor_direction)\n\n            else:  # you must be at a 3-way intersection; intersections do not need to detect corridor_direction\n                auto_description_phrase = self.auto_intersection_description()\n\n        if number_of_walls == 2:  # corridor, corner, or corner-atrium\n            e_w_walls = ['East', 'West']\n            n_s_walls = ['North', 'South']\n\n            # if there are walls to your east and west *or* to your north and south:\n            if set(e_w_walls) == set(walls_list) or set(n_s_walls) == set(walls_list):  # you must be in a corridor:\n                directions = convert_list_to_string_with_and(walls_list)\n                auto_description_phrase = f\"{corridor_phrase} \" \\\n                                          f\"There are {barrier_name_plural} to the {directions}.\"\n\n            else:  # otherwise, you must be in a corner:\n                directions = convert_list_to_string_with_and(walls_list)\n                auto_description_phrase = f\"You are in a corner. \" \\\n                                          f\"There are {barrier_name_plural} to the {directions}.\"\n\n                if self.atrium_check():\n                    corridor_direction = self.atrium_check()\n                    # you can sometimes be in a corner and also be in an atrium. i.e. there are 2 proximal corridors.\n                    # in that case, the atrium description is ignored, because it is not really an atrium\n                    # by human definition, but corridor directions are still calculated:\n                    if len(corridor_direction) > 1:\n                        corridor_direction = convert_list_to_string_with_and(corridor_direction)  # beta\n                        multiple_corridors = True\n\n                    else:\n                        corridor_direction = convert_list_to_string(corridor_direction)  # beta\n\n        if number_of_walls == 3:  # 3 walls must be a dead end\n            directions = convert_list_to_string_with_and(walls_list)\n            auto_description_phrase = f\"This is a dead end. \" \\\n                                      f\"There are {barrier_name_plural} to the {directions}.\"\n\n        if number_of_walls == 4:  # this must never happen! :P\n            directions = convert_list_to_string_with_and(walls_list)\n            print(f\"Ostensibly, you are in a cell. \"\n                  f\"There are {barrier_name_plural} to the {directions}.\\n\"\n                  f\"You are completely trapped due to a programming error. The grid should never \"\n                  f\"have been created\\nwith coordinates that place you in such a predicament. \"\n                  f\"Placing you back at staircase..\")\n            pause()\n            (self.x, self.y) = self.dungeon.staircase\n            self.coordinates = (self.x, self.y)\n            return\n\n        # finally, print auto_description_phrase and exits:\n        if number_of_exits > 1:\n            exits = convert_list_to_string_with_and(exits_list)\n            print(f\"{auto_description_phrase} Exits are to the {exits}.\")\n\n            # if there are corridors, calculate which exits lead to them and print out:\n            if corridor_direction != \"\":  # you must be at an atrium, or corner-atrium\n\n                if not self.dungeon_level_exit_check():  # if player is not proximal to dungeon_level exit\n\n                    if multiple_corridors:\n                        print(f\"The {corridor_direction} exits each lead to {corridor_name}.\")\n                    else:\n                        print(f\"The {corridor_direction} exit leads to {corridor_name}.\")\n\n                else:  # player IS proximal to the dungeon_level exit\n                    if multiple_corridors:\n                        print(f\"The {corridor_direction} exits each lead to corridors.\")\n                        dungeon_exit_direction = self.dungeon_level_exit_check()\n                        print(f\"The {dungeon_exit_direction} corridor leads to a staircase..\"\n                              f\" ***** IT IS THE EXIT OF {self.dungeon.name}!!! *****\")\n                        #\n                    else:\n                        corridor_direction = self.dungeon_level_exit_check()\n                        print(f\"The {corridor_direction} corridor leads to a staircase..\"\n                              f\" ***** IT IS THE EXIT OF {self.dungeon.name}!!! *****\")\n                        #\n            else:  # you must be at an intersection. intersections are auto-described above.\n                # just check to see if player is proximal to the dungeon_level_exit:\n                if self.dungeon_level_exit_check():\n                    corridor_direction = self.dungeon_level_exit_check()\n                    print(f\"The {corridor_direction} corridor leads to a staircase..\"\n                          f\" ***** IT IS THE EXIT OF {self.dungeon.name}!!! *****\")\n                    #\n        else:  # you must be at a dead end\n            exits = convert_list_to_string(exits_list)\n            print(f\"{auto_description_phrase} The only exit is to the {exits}.\")\n\n    def you_cannot_go_that_way(self):\n        # called from dungeon_description()\n        barrier_name = self.dungeon.barrier_name\n        if self.in_a_pit:\n            barrier_name = self.dungeon.pit_barrier_name\n        random_statement_list = [f\"The {barrier_name} blocks your way...\", \"You cannot go that way...\",\n                                 f\"The {barrier_name} prevents movement in that direction...\"]\n        random_statement = random.choice(random_statement_list)\n        print(random_statement)\n        self.x = self.previous_x\n        self.y = self.previous_y\n        self.coordinates = (self.x, self.y)\n        self.position = self.dungeon.grid[self.y][self.x]\n\n    def dungeon_level_exit_check(self):\n        # called from dungeon_description()\n        north_of_you = (self.x, (self.y - 1))\n        west_of_you = ((self.x - 1), self.y)\n        south_of_you = (self.x, (self.y + 1))\n        east_of_you = ((self.x + 1), self.y)\n        level_exit = self.dungeon.exit\n        if north_of_you == level_exit:\n            return \"Northern\"\n        if west_of_you == level_exit:\n            return \"Western\"\n        if east_of_you == level_exit:\n            return \"Eastern\"\n        if south_of_you == level_exit:\n            return \"Southern\"\n        else:\n            return False\n\n    def navigation_position_coordinates(self):\n        # called from end of each navigation turn in main loop\n        self.position = self.dungeon.grid[self.y][self.x]\n        self.coordinates = (self.x, self.y)\n\n    def navigation_turn_initialize(self):\n        # called from main loop at beginning of each navigation turn while in dungeon\n        self.coordinates = (self.x, self.y)\n        self.previous_x = self.x\n        self.previous_y = self.y\n\n    def dungeon_description(self):\n        # meta-function called from navigation() and main loop.\n        self.hud()\n        north_south = \"\"\n        east_west = \"\"\n        if self.x > 9:\n            east_west = \"eastern\"\n        elif self.x < 10:\n            east_west = \"western\"\n        if self.y > 9:\n            north_south = \"South\"\n        elif self.y < 10:\n            north_south = \"North\"\n\n        # You cannot go that way; Player has hit a dungeon wall and is returned to previous position\n        if self.position == \"*\":  # asterisk represents barrier\n            self.you_cannot_go_that_way()\n\n        # call the automatic description function\n        self.automatic_dungeon_description_and_room_exit_finder()\n\n        # Dungeon logical descriptions. They correspond to dungeon instance coordinates and events.\n        # They are printed out after automatic description function\n        if self.coordinates == self.dungeon.staircase:\n            self.staircase_description()\n        if self.coordinates == self.dungeon.elevator_landing:\n            self.elevator_landing_description()\n        if self.coordinates == self.dungeon.teleporter_landing:\n            self.teleporter_landing_description()\n        if self.coordinates == self.dungeon.pit_landing:\n            self.pit_landing_description()\n        if self.coordinates == self.dungeon.encounter_deaf_one_1:\n            self.deaf_one_fog_remnant_description()\n        if self.coordinates == self.dungeon.encounter_deaf_one_2:\n            self.deaf_one_fog_remnant_description()\n        # self.coordinates = (self.x, self.y)  # commented out. seems to be unnecessary at this point in program.\n\n        # print out dungeon level and coordinates before returning\n        if self.in_a_pit:\n            # assuming pit landing coordinates are at 1, 14:\n            print(f\"(In a pit below {self.dungeon.name}) Coordinates: {self.x, (self.y - 13)}\")\n        else:\n            if self.coordinates != self.dungeon.exit:\n                print(f\"(Dungeon level {self.dungeon.level} - {self.dungeon.name}, \"\n                      f\"{north_south}{east_west} region) Coordinates: {self.coordinates}\")\n        return\n\n    def display_map(self, maps):\n        if self.in_a_pit:\n            print(f\"You are in uncharted territory..\")\n            sleep(1)\n            return\n        else:\n            cls()\n            print(\"You look at the map..\")\n            # print(f\"Position key: {self.position}\")  # remove after testing\n\n            self.coordinates = (self.x, self.y)\n            print(f\"(Dungeon level {self.dungeon.level} - {self.dungeon.name}) Coordinates: {self.coordinates}\")\n\n            if self.coordinates != self.dungeon.staircase:\n                self.dungeon.player_grid[self.y][self.x] = \"X\"\n                for element in range(0, 20):\n                    print(*maps[element])\n                # replace the X with a dot after printing map so that it doesn't leave a trail of x's:\n                self.dungeon.player_grid[self.y][self.x] = \".\"\n                print(f\"S = Staircase X = your position E = Exit\")\n\n            else:\n                for element in range(0, 20):\n                    print(*maps[element])\n                print(f\"S = Staircase E = Exit\\nYou are currently at the staircase.\")\n\n            # place the next line in the main file to leave a trail of x's throughout the map to see where you've been.\n            # player_1.dungeon.player_grid[player_1.y][player_1.x] = \"x\"\n            return\n\n    def dungeon_exit_event(self):\n        # dungeon dictionary in dungeons.py file\n        print(f\"You approach the exit. With quiet resolve, you turn to briefly look\\n\"\n              f\"behind you, and then continue onward, toward your goal.\")\n        sleep(2)\n        # the deepest dungeon level will have no exit, so there should be no chance of a KeyError by adding 1.\n        # at end of game, transport player back to dungeon level 1 with:\n        # self.dungeon_key = 1\n        # self.dungeon = dungeon_dict[self.dungeon_key]\n        self.dungeon_key += 1\n        self.dungeon = dungeon_dict[self.dungeon_key]\n        (self.x, self.y) = self.dungeon.staircase  # simplified with tuple instead of self.x = and self.y =\n        self.coordinates = (self.x, self.y)  # beta testing\n        # for a while, self.coordinates would be set after first move. otherwise, the intro would be printed 1st,\n        # followed by the staircase description, which was awkward. after migrating to automatic_description, this\n        # seems to no longer be the case\n        self.previous_x = self.x\n        self.previous_y = self.y\n        self.position = 0\n        pause()\n        return \"Exit Boss\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/player_module.py b/player_module.py
--- a/player_module.py	(revision 2893e437dcc41c959e7a02a55bf2fba5d41b130e)
+++ b/player_module.py	(date 1755803020108)
@@ -7,6 +7,9 @@
 import random
 import time
 import os
+import subprocess
+import threading
+import atexit
 import sys
 from collections import Counter
 from dungeons import dungeon_dict
@@ -14,7 +17,14 @@
 from pathlib import Path
 import itertools
 from termios import tcflush, TCIFLUSH
+import termios
+import tty
+import select
 
+# --- internal state ---
+_sound_proc = None
+_sound_loop_thread = None
+_sound_stop_event = threading.Event()
 
 # if you call a function and expect to use a return value, like, by printing it, you must first assign a variable in
 # the call itself!!!
@@ -263,7 +273,7 @@
         sys.stdout.write('\b')  # erase the last written char
         sleep(.005)
 
-
+"""
 def escape_key_interrupt_teletype(message):
     # I am proud of this little snippet I figured out,
     # but unfortunately, it does not work reliably on *nix due to permissions problems with the 'keyboard' module.
@@ -281,7 +291,34 @@
 
     #else:
     #    return False
+"""
+def escape_key_interrupt_teletype(message):
+    """
+    Works on OpenBSD 7.7: detect ESC immediately (no Enter needed).
+    """
+    fd = sys.stdin.fileno()
+    old_settings = termios.tcgetattr(fd)
+
+    # Copy settings we can modify
+    new_settings = termios.tcgetattr(fd)
+    # Local flags: disable canonical mode (ICANON) and echo (ECHO)
+    new_settings[3] = new_settings[3] & ~(termios.ICANON | termios.ECHO)
+    termios.tcsetattr(fd, termios.TCSADRAIN, new_settings)
 
+    try:
+        dr, _, _ = select.select([sys.stdin], [], [], 0)
+        if dr:
+            ch = sys.stdin.read(1)
+            if ch == '\x1b':  # ESC key
+                print("\033c", end="")  # clear screen
+                print()
+                print(message)
+                return True
+    finally:
+        # Always restore original terminal state
+        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
+
+    return False
 
 def same_line_print(string):
     # simple function that does not add a carriage return, allowing next item to be printed on same line
@@ -678,46 +715,104 @@
     pause()
 
 
+def _resolve_sound_path(sound_file: str):
+    from pathlib import Path
+    sound_folder = Path(__file__).with_name("sound")
+    return sound_folder / sound_file
+
+
+def _launch_aucat_once(filepath):
+    """Start one asynchronous play of filepath via aucat."""
+    global _sound_proc
+    try:
+        _sound_proc = subprocess.Popen(
+            ["aucat", "-i", str(filepath)],
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
+            close_fds=True,
+        )
+    except FileNotFoundError:
+        print("Error: 'aucat' not found. Install/enable sndio utilities.")
+    except Exception as e:
+        print(f"Error starting playback: {e}")
+
+
 def stop_sound():
-    pass
-    #winsound.PlaySound(None, 0)
+    """
+    Stop any current/looping playback, like winsound.PlaySound(None, 0).
+    """
+    global _sound_proc, _sound_loop_thread, _sound_stop_event
+
+    _sound_stop_event.set()
+
+    # terminate any active aucat process
+    p = _sound_proc
+    if p and p.poll() is None:
+        try:
+            p.terminate()
+        except Exception:
+            pass
+    _sound_proc = None
+
+    # wait for loop thread to exit (avoid self-join)
+    t = _sound_loop_thread
+    if t and t.is_alive() and t is not threading.current_thread():
+        t.join(timeout=1.0)
+    _sound_loop_thread = None
 
 
 def sound_player(sound_file):
-    # a sound player function which simply plays sound_file asynchronously
-    pass
-    #if os.name == 'nt':
-    #    p = ""
-    #    try:
-    #        sound_folder = Path(__file__).with_name("sound")
-    #        p = sound_folder / sound_file
-    #        # p = Path(__file__).with_name(sound_file)
-    #        with p.open('rb') as sound:
-    #            if sound.readable():
-    #                winsound.PlaySound(str(p), winsound.SND_FILENAME | winsound.SND_ASYNC)
-    #    except FileNotFoundError:
-            # pass  # restore after testing
-    #        print(f"{p} not found.")  # remove after testing
-    #        pause()  # remove after testing
+    """Asynchronously play a sound file once (returns immediately)."""
+    try:
+        path = _resolve_sound_path(sound_file)
+        if not path.exists():
+            # fail silently (or log once if debugging)
+            print(f"[sound] {path} not found, skipping playback.")
+            return
+
+        stop_sound()
+        _launch_aucat_once(path)
+
+    except Exception as e:
+        print(f"[sound] error starting playback: {e}")
 
 
 def sound_player_loop(sound_file):
-    # a sound player function which plays sound_file asynchronously on a continuous loop
-    pass
-    #if os.name == 'nt':
-    #    p = ""
-    #    try:
-    #        sound_folder = Path(__file__).with_name("sound")
-    #        p = sound_folder / sound_file
-    #        # print(p)
-    #        # p = Path(__file__).with_name(sound_file)
-    #        with p.open('rb') as sound_loop:
-    #            if sound_loop.readable():
-    #                winsound.PlaySound(str(p), winsound.SND_FILENAME | winsound.SND_LOOP | winsound.SND_ASYNC)
-    #    except FileNotFoundError:
-            # pass  # restore after testing
-    #        print(f"{p} not found.")  # remove after testing
-    #        pause()  # remove after testing
+    """Asynchronously play a sound file in a continuous loop (returns immediately)."""
+    global _sound_loop_thread, _sound_stop_event
+
+    try:
+        path = _resolve_sound_path(sound_file)
+        if not path.exists():
+            print(f"[sound] {path} not found, skipping playback.")
+            return
+
+        stop_sound()
+        _sound_stop_event.clear()
+
+        def _loop_runner():
+            while not _sound_stop_event.is_set():
+                _launch_aucat_once(path)
+                proc = _sound_proc
+                if proc is None:
+                    break
+                while proc.poll() is None and not _sound_stop_event.is_set():
+                    try:
+                        proc.wait(timeout=0.2)
+                    except subprocess.TimeoutExpired:
+                        pass
+
+        t = threading.Thread(target=_loop_runner, daemon=True)
+        _sound_loop_thread = t
+        t.start()
+
+    except Exception as e:
+        print(f"[sound] error starting loop: {e}")
+
+
+# --- Ensure sound always stops on exit ---
+atexit.register(stop_sound)
+
 
 
 def gong():
@@ -1699,11 +1794,10 @@
         }
 
     def dungeon_theme(self):
-        if os.name == 'nt':
-            if not self.in_a_pit:
-                sound_player_loop('dungeon_theme_2.wav')
-            else:
-                pit_theme()
+        if not self.in_a_pit:
+            sound_player_loop('dungeon_theme_2.wav')
+        else:
+            pit_theme()
 
     def regenerate(self):
         if self.hit_points < self.maximum_hit_points and self.ring_of_reg.regenerate > 0:
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"7d6c30c1-177c-4c8e-8b52-6874b926dc23\" name=\"Changes\" comment=\"edit typo in installation and running\">\n      <change beforePath=\"$PROJECT_DIR$/README.md\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/README.md\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;Misfit-138&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">{\n  &quot;selectedUrlAndAccountId&quot;: {\n    &quot;url&quot;: &quot;https://github.com/Misfit-138/OpenBSD_Sauengard.git&quot;,\n    &quot;accountId&quot;: &quot;f1c0213a-53b4-4ec8-a534-d9c602ddff9a&quot;\n  }\n}</component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 6\n}</component>\n  <component name=\"ProjectId\" id=\"2ygB1u0C3ELdrQkNvPheXhlYulc\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;Python.main.executor&quot;: &quot;Run&quot;,\n    &quot;Python.player_module.executor&quot;: &quot;Run&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/home/jules/PycharmProjects/PythonProject/text&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;configurable.group.appearance&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/text\" />\n      <recent name=\"$PROJECT_DIR$\" />\n    </key>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"7d6c30c1-177c-4c8e-8b52-6874b926dc23\" name=\"Changes\" comment=\"\" />\n      <created>1750246124735</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1750246124735</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"commit1\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750857487827</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750857487827</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"commit1\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750857514200</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750857514200</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"commit1\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750858254487</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750858254487</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"commit edits to licenses and ABOUT\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750858686453</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750858686453</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"commit edits to readme\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750858910285</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750858910285</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"commit edits to copyright\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750859459311</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750859459311</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"commit edits to copyright\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750861117437</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750861117437</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"commit edits including removing showing monster hit points\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750861211649</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750861211649</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"edit typo in installation and running\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1750861408225</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1750861408225</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"10\" />\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"commit1\" />\n    <MESSAGE value=\"commit edits to licenses and ABOUT\" />\n    <MESSAGE value=\"commit edits to readme\" />\n    <MESSAGE value=\"commit edits to copyright\" />\n    <MESSAGE value=\"commit edits including removing showing monster hit points\" />\n    <MESSAGE value=\"edit typo in installation and running\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"edit typo in installation and running\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 2893e437dcc41c959e7a02a55bf2fba5d41b130e)
+++ b/.idea/workspace.xml	(date 1755802181128)
@@ -4,8 +4,9 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="7d6c30c1-177c-4c8e-8b52-6874b926dc23" name="Changes" comment="edit typo in installation and running">
-      <change beforePath="$PROJECT_DIR$/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/README.md" afterDir="false" />
+    <list default="true" id="7d6c30c1-177c-4c8e-8b52-6874b926dc23" name="Changes" comment="added space to deaf one's explanation">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/player_module.py" beforeDir="false" afterPath="$PROJECT_DIR$/player_module.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -38,17 +39,17 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;Python.main.executor&quot;: &quot;Run&quot;,
-    &quot;Python.player_module.executor&quot;: &quot;Run&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
-    &quot;last_opened_file_path&quot;: &quot;/home/jules/PycharmProjects/PythonProject/text&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;configurable.group.appearance&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Python.main.executor": "Run",
+    "Python.player_module.executor": "Run",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "RunOnceActivity.git.unshallow": "true",
+    "git-widget-placeholder": "master",
+    "last_opened_file_path": "/home/jules/PycharmProjects/PythonProject",
+    "settings.editor.selected.configurable": "configurable.group.appearance"
   }
-}</component>
+}]]></component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
       <recent name="$PROJECT_DIR$/text" />
@@ -136,7 +137,15 @@
       <option name="project" value="LOCAL" />
       <updated>1750861408225</updated>
     </task>
-    <option name="localTasksCounter" value="10" />
+    <task id="LOCAL-00010" summary="added space to deaf one's explanation">
+      <option name="closed" value="true" />
+      <created>1750863785019</created>
+      <option name="number" value="00010" />
+      <option name="presentableId" value="LOCAL-00010" />
+      <option name="project" value="LOCAL" />
+      <updated>1750863785019</updated>
+    </task>
+    <option name="localTasksCounter" value="11" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -157,6 +166,7 @@
     <MESSAGE value="commit edits to copyright" />
     <MESSAGE value="commit edits including removing showing monster hit points" />
     <MESSAGE value="edit typo in installation and running" />
-    <option name="LAST_COMMIT_MESSAGE" value="edit typo in installation and running" />
+    <MESSAGE value="added space to deaf one's explanation" />
+    <option name="LAST_COMMIT_MESSAGE" value="added space to deaf one's explanation" />
   </component>
 </project>
\ No newline at end of file
